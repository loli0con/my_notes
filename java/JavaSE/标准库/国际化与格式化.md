# 国际化与格式化

## 国际化

### 定义
国际化是指应用程序运行时，可根据客户端请求来自的国家/地区、语言的不同而显示不同的界面。引入国际化的目的是为了提供自适应、更友好的用户界面，并不需要改变程序的逻辑功能。

国际化的英文单词是Internationalization，简称**I18N**，其中I是这个单词的第一个字母，18表示中间省略的字母个数，而N代表这个单词的最后一个字母。一个国际化支持很好的应用，在不同的区域使用时，会呈现出本地语言的提示。这个过程也被称为Localization，即本地化。类似于国际化可以称为I18N，本地化也可以称为**L10N**。

### 资源文件
Java程序的国际化思路是将程序中的标签、提示等信息放在资源文件中，程序需要支持哪些国家、语言环境，就对应提供相应的资源文件。资源文件是key-value对，每个资源文件中的key是不变的，但value则随不同的国家、语言而改变。

为了实现程序的国际化，必须先提供程序所需要的资源文件。资源文件的内容是很多key-value对，其中key是程序使用的部分，而value则是程序界面的显示字符串。资源文件的命名可以有如下三种形式：
1. baseName_language_country.properties
2. baseName_language.properties
3. baseName.properties
其中baseName是资源文件的基本名，用户可随意指定；而language和country都不可随意变化，必须是Java所支持的语言和国家，可调用Locale类的getAvailableLocales()方法返回一个包含了Java所支持的国家和语言的Locale数组。不同国家、语言环境的资源文件的baseName是相同的，通过language和country来对应不同的国家、语言环境的资源文件。


### 相关类
Java程序的国际化主要通过如下三个类完成：
* java.util.ResourceBundle：用于加载国家、语言资源包。
* java.util.Locale：用于封装特定的国家/区域、语言环境。
* java.text.MessageFormat：用于格式化带占位符的字符串。

#### ResourceBundle
Java程序国际化的关键类是ResourceBundle和Locale，ResourceBundle有一个静态方法：getBundle(String baseName, Locale locale)，该方法将根据Locale加载资源文件，再根据指定的key取得已加载语言资源文件中的字符串。

```Java
// 取得系统默认的国家和语言环境
Locale myLocale = Locale.getDefault(Locale.Category.FORMAT);
// 根据指定的国家和语言环境加载资源文件
ResourceBundle bundle = ResourceBundle.getBundle("baseName", myLocale);
// 从资源文件中取得消息
System.out.println(bundle.getString("key"));
```

#### MessageFormat
如果需要的文本中包含动态的内容，例如，这些内容是从程序中取得的。在这种情况下，可以在资源文件中使用带占位符的文本，然后使用MessageFormat类的静态方法`format(String pattern, Object...values)`，该方法返回后面的多个参数值填充前面的pattern字符串，其中pattern字符串不是正则表达式，而是一个带占位符的字符串。
* 资源文件：`text=你好，{0}！今天是{1}。`
* 代码：`MessageFormat.format(bundle.getString("text"),"猪猪",new Date())`


### 使用类文件代替资源文件
除使用属性文件作为资源文件外，Java也允许使用类文件代替资源文件，即将所有的key-value对存入class文件，而不是属性文件。使用类文件来代替资源文件必须满足如下条件：
1. 该类的类名必须是baseName_language_country，这与属性文件的命名相似。
2. 该类必须继承ListResourceBundle，并重写getContents()方法，该方法返回Object数组，该数组的每一项都是key-value对。

#### 优先级
如果系统同时存在资源文件、类文件，系统将以类文件为主，而不会调用资源文件。对于简体中文的Locale，ResourceBundle搜索资源文件的顺序是：
1. baseName_zh_CN.class
2. baseName_zh_CN.properties
3. baseName_zh.class
4. baseName_zh.properties
5. baseName.class
6. baseName.properties

系统按上面的顺序搜索资源文件，如果前面的文件不存在，才会使用下一个文件。如果一直找不到对应的文件，系统将抛出异常。