# Object类

Object类是所有类、数组、枚举类的父类，也就是说，Java允许把任何类型的对象赋给Object类型的变量。当定义一个类时没有使用extends关键字为它显式指定父类，则该类默认继承Object父类。
因为所有的Java类都是Object类的子类，所以任何Java对象都可以调用Object类的方法。Object类提供了如下几个常用方法。
* boolean equals(Object obj)：判断指定对象与该对象是否相等。此处相等的标准是，两个对象是同一个对象，因此该equals()方法通常没有太大的实用价值。
* protected void finalize()：当系统中没有引用变量引用到该对象时，垃圾回收器调用此方法来清理该对象的资源。
* Class<?> getClass()：返回该对象的运行时类，该方法在本书第18章还有更详细的介绍。
* int hashCode()：返回该对象的hashCode值。在默认情况下，Object类的hashCode()方法根据该对象的地址来计算（即与System.identityHashCode(Object x)方法的计算结果相同）。但很多类都重写了Object类的hashCode()方法，不再根据地址来计算其hashCode()方法值。
* String toString()：返回该对象的字符串表示，当程序使用System.out.println()方法输出一个对象，或者把某个对象和字符串进行连接运算时，系统会自动调用该对象的toString()方法返回该对象的字符串表示。Object类的toString()方法返回“运行时类名@十六进制hashCode值”格式的字符串，但很多类都重写了Object类的toString()方法，用于返回可以表述该对象信息的字符串。
* wait()、notify()和notifyAll()方法可以控制线程的暂停和运行。
* protected clone()：该方法用于帮助其他对象来实现“自我克隆”，所谓“自我克隆”就是得到一个当前对象的副本，而且二者之间完全隔离。由于Object类提供的clone()方法使用了protected修饰，因此该方法只能被子类重写或调用。

## 浅克隆
自定义类实现“克隆”的步骤如下。
1. 自定义类实现Cloneable接口。这是一个标记性的接口，实现该接口的对象可以实现“自我克隆”，接口里没有定义任何方法。
2. 自定义类实现自己的clone()方法。
3. 实现clone()方法时通过super.clone()，即调用Object实现的clone()方法来得到该对象的副本，并返回该副本。

Object类提供的Clone机制只对对象里各实例变量进行“简单复制”，如果实例变量的类型是引用类型，Object的Clone机制也只是简单地复制这个引用变量，这样原有对象的引用类型的实例变量与克隆对象的引用类型的实例变量依然指向内存中的同一个实例。这只是一种“浅克隆”——它只克隆该对象的所有成员变量值，不会对引用类型的成员变量值所引用的对象进行克隆。如果开发者需要对对象进行“深克隆”，则需要开发者自己进行“递归”克隆，保证所有引用类型的成员变量值所引用的对象都被复制了。

Object类提供的clone()方法十分高效。比如clone一个包含100个元素的int[]数组，用系统默认的clone方法比静态copy方法快近2倍。