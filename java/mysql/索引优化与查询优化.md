# 索引优化与查询优化



## 索引优化
1. 查询条件和索引全值匹配最好
2. 查询条件覆盖索引的左前部分，即最佳左前缀法则
3. 主键顺序插入，避免页分裂
4. 运算、函数、类型转换导致索引失效
5. 范围条件右边的列索引失效，即对联合索引中某一列进行范围查询后，该列可以使用索引，但该列右边(即后面)的列的索引会失效。创建的联合索引中，务必把范围涉及到的字段写在最后
6. 不等于(!=或<>)索引失效
7. is null可以使用索引，is not null无法使用索引
8. like以通配符%开头索引失效
9. or前后存在非索引的列，索引失效
10. 统一使用utf8mb4编码，防止字符集转换函数的调用

### 覆盖索引
一个索引包含了满足查询结果的数据就叫做覆盖索引，它包括在查询里的SELECT、JOIN和WHERE子句用到的所有列 (即建索引的字段正好是覆盖查询条件中所涉及的字段)。

好处：
1. 避免Innodb表进行索引的二次查询(回表)
2. 可以把随机IO(回表)变成顺序IO(索引B+树叶子结点在同一个页内)加快查询效率

弊端：索引字段的维护总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。

### 前缀索引
MySQL是支持前缀索引的。默认地，如果创建索引的语句不指定前缀长度，那么索引就会包含整个字符串。

#### demo
```SQL
mysql> alter table teacher add index index1(email);
#或
mysql> alter table teacher add index index2(email(6));
```

index1示意图：
![索引优化与查询优化+20220923110130](https://raw.githubusercontent.com/loli0con/picgo/master/images/%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E4%B8%8E%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%2B20220923110130.png%2B2022-09-23-11-01-31)

index2示意图：
![索引优化与查询优化+20220923110154](https://raw.githubusercontent.com/loli0con/picgo/master/images/%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E4%B8%8E%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%2B20220923110154.png%2B2022-09-23-11-01-55)

如果使用的是index1 (即email整个字符串的索引结构)，执行顺序是这样的:
1. 从index1索引树找到满足索引值是’zhangssxyz@xxx.com’的这条记录，取得ID2的值;
2. 到主键上查到主键值是ID2的行，判断email的值是正确的，将这行记录加入结果集;
3. 取index1索引树上刚刚查到的位置的下一条记录，发现已经不满足email='zhangssxyz@xxx.com’的条件了，循环结束。

如果使用的是index2 (即email(6)索引结构)，执行顺序是这样的:
1. 从index2索引树找到满足索引值是’zhangs’的记录，找到的第一个是ID1;
2. 到主键上查到主键值是ID1的行，判断出email的值不是’zhangssxyz@xxx.com’，这行记录丢弃;
3. 取index2上刚刚查到的位置的下一条记录，发现仍然是’zhangs’，取出ID2，再到ID索引上取整行然后判断，这次值对了，将这行记录加入结果集;
4. 重复上一步，直到在idxe2上取到的值不是’zhangs’时，循环结束。

也就是说 使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。 前面 已经讲过区分度，区分度越高越好。因为区分度越高，意味着重复的键值越少。

#### 对覆盖索引的影响
使用前缀索引就用不上覆盖索引对查询性能的优化了，这也是在选择是否使用前缀索引时需要考虑的一个因素。

### 索引下推
Index Condition Pushdown(ICP)是一种在存储引擎层使用索引过滤数据的一种优化方式。ICP可以减少存储引擎访问基表的次数以及MySQL服务器访问存储引擎的次数。

#### 使用前
![索引优化与查询优化+20220923110821](https://raw.githubusercontent.com/loli0con/picgo/master/images/%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E4%B8%8E%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%2B20220923110821.png%2B2022-09-23-11-08-22)

* storage层: 只将满足index key条件的索引记录对应的整行记录取出，返回给server层
* server层: 对返回的数据，使用后面的where条件过滤，直至返回最后一行。

#### 使用后
![索引优化与查询优化+20220923110914](https://raw.githubusercontent.com/loli0con/picgo/master/images/%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E4%B8%8E%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%2B20220923110914.png%2B2022-09-23-11-09-15)

* storage层: 首先将index key条件满足的索引记录区间确定，然后在索引上使用index filter进行过滤。将满足的index filter条件的索引记录才去回表取出整行记录返回server层。不满足index filter条件的索引记录丢弃，不回表、也不会返回server层。
* server层: 对返回的数据，使用table filter条件做最后的过滤。

#### 使用前后的成本差别
使用前，存储层多返回了需要被index filter过滤掉的整行记录；使用ICP后，直接就去掉了不满足index filter条件的记录，省去了他们回表和传递到server层的成本。ICP的加速效果取决于在存储引擎内通过ICP筛选掉的数据的比例。

#### 使用条件
1. 只能用于二级索引(secondary index)
2. explain显示的执行计划中type值(join类型)为range、ref、eq_ref或者ref_or_null。
3. 如果where条件的字段不在索引列中，还是得读取整表的记录到server端做where过滤。
4. ICP可以用于MyISAM和InnnoDB存储引擎。
5. 当SQL使用覆盖索引时，不支持ICP优化方法。

### 唯一索引 和 普通索引

#### 查询
对于普通索引来说，查找到满足条件的第一个记录后，需要查找下一个记录，直到碰到第一个不满足条件的记录。对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。这个不同带来的性能差距是微乎其微的。

#### 更新
当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InooDB会将这些更新操作缓存在change buffer中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。

将change buffer中的操作应用到原数据页，得到最新结果的过程称为merge。除了访问这个数据页会触发merge外，系统有后台线程会定期merge。在数据库正常关闭的过程中，也会执行merge操作。

如果能够将更新操作先记录在change buffer，减少读磁盘，语句的执行速度会得到明显的提升。而且，数据读入内存是需要占用buffer pool的，所以这种方式还能够避免占用内存，提高内存利用率。

唯一索引的更新就不能使用change buffer，实际上也只有普通索引可以使用。在实际使用，普通索引和change buffer的配合使用，对于数据量大的表的更新优化还是很明显的。如果所有的更新后面，都马上伴随着对这个记录的查询，那么应该关闭change buffer。而在其他情况下，change buffer都能提升更新性能。由于唯一索引用不上change buffer的优化机制，因此如果业务可以接受，从性能角度出发建议优先考虑非唯一索引。





## 查询优化

### 关联查询优化

#### 左外连接
1. 被驱动表的连接字段添加索引（此时，被驱动表的访问类型为ref）
2. 驱动表的连接字段也可以添加索引（此时，驱动表的访问类型为index）

#### 内连接
对于内连接来说，查询优化器会根据两个表连接字段是否有索引、表的记录数量等因素综合考量，决定驱动表和被驱动表。如果连接条件中，只有一边有索引，另一边没有，那么有索引的表就会作为被驱动表。如果两边都有索引或者都没有索引，会选择表的记录数量少的表作为驱动表。

### JOIN的底层原理
join方式连接多个表，本质就是各个表之间数据的循环匹配。

#### 驱动表和被驱动表
对于内连接来说，优化器会根据查询语句做优化，以此来决定先查哪张表。对于外连接来说，优化器能对查询语句进行改造，可以把外连接改造成内连接，因此无法保证写在前面的表一定是驱动表。除非使用 straight_join 让MySQL使用固定的连接方式执行查询，优化器才会完全按照查询语句编写的顺序去选择驱动表和被驱动表。

#### Simple Nested-Loop Join（简单嵌套循环连接）
从表A中取出一条数据，遍历表B，将匹配到的数据放到结果中。以此类推，驱动表A中的每一条记录与被驱动表B的记录进行比较：
![索引优化与查询优化+20220921165347](https://raw.githubusercontent.com/loli0con/picgo/master/images/%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E4%B8%8E%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%2B20220921165347.png%2B2022-09-21-16-53-48)

开销统计如下：
|项目|SNLJ的成本|
|----|----|----|
|外表扫描次数|1|
|内表扫描次数|A|
|读取记录次数|A+B×A|
|JOIN比较次数|B×A|
|回表读取记录次数|0|

大致可以知道，表A相较于表B而言，次数越少查询的开销越低。因此外层表(驱动表)的数据越少越好。

#### Index Nested-Loop Join（索引嵌套循环连接）
Index Nested-Loop Join的优化思路是为了减少内层表数据的匹配次数，是通过内层表添加索引来实现。添加索引后，外层表匹配条件可以直接和内层表索引进行匹配，避免和内层表的每条记录去进行匹配，极大地减少了匹配的次数。

![索引优化与查询优化+截屏2022-09-21 17.09.43](https://raw.githubusercontent.com/loli0con/picgo/master/images/%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E4%B8%8E%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%2B%E6%88%AA%E5%B1%8F2022-09-21%2017.09.43.png%2B2022-09-21-17-12-26)

外中的每条记录和内表的索引进行匹配，因为索引查询的成本较为固定，所以优化器倾向使用记录数少的表作为驱动表。开销统计如下：
|项目|SNLJ的成本|INLJ的成本|
|----|----|----|
|外表扫描次数|1|1|
|内表扫描次数|A|0|
|读取记录次数|A+B×A|A+B匹配的个数(B索引树的叶子结点)|
|JOIN比较次数|B×A|B索引树的高度×A|
|回表读取记录次数|0|(如果需要回表的)B匹配的个数，(如果不需要回表)0|


#### Block Nested-Loop Join（块嵌套循环连接）
如果存在索引，那么会使用索引进行匹配。如果没有索引，就只能不断地扫描被驱动表，此时IO次数过高。为了减少被驱动表的IO次数，出现了Block Nested-Loop Join的连接方式。通过将驱动表相关的部分数据列缓存到内存中（缓存的大小受到join buffer的控制），然后全表扫描被驱动表，将被驱动表的每一条记录和join buffer缓冲区中所有驱动表的记录进行匹配，将Simple Nested-Loop Join中的多次合并为一次，降低被驱动表的访问率。

不仅仅能缓存关联的列，还能缓存SELECT子句中的列。在一个有N个join关联的sql中会分配N-1个join buffer，查询时候尽量减少不必要的字段，可以让join buffer中缓存更多的数据。

![索引优化与查询优化+20220921174112](https://raw.githubusercontent.com/loli0con/picgo/master/images/%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E4%B8%8E%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%2B20220921174112.png%2B2022-09-21-17-41-14)

|项目|SNLJ的成本|INLJ的成本|BNLJ的成本|
|----|----|----|----|
|外表扫描次数|1|1|1|
|内表扫描次数|A|0|A×匹配中使用到的字段的内存大小/join_buffer的大小|
|读取记录次数|A+B×A|A+B匹配的个数(B索引树的叶子结点)|A+B×(A×匹配中使用到的字段的内存大小/join_buffer的大小)|
|JOIN比较次数|B×A|B索引树的高度×A|B×A|
|回表读取记录次数|0|(如果需要回表的)B匹配的个数，(如果不需要回表)0|0|

#### 总结
1. 整体效率：INLJ > BNLJ > SNLJ。
2. 用小结果集驱动大结果集，减少外层循环的数据量。这里的“小”包括表的行数和每行的大小。
3. 为被驱动表匹配的条件增加索引，减少内层表的循环匹配次数。
4. 增大 join buffer size 的大小，缓存的数据越多，内层表的扫描次数越少。
5. 减少驱动表不必要的字段查询


### 子查询优化
子查询是 MySQL 的一项重要的功能，可以帮助我们通过一个 SQL 语句实现比较复杂的查询。但是，子查询的执行效率不高。原因:
1. 执行子查询时，MySQL需要为内层查询语句的查询结果建立一个临时表，然后外层查询语句从临时表中查询记录。查询完毕后，再撤销这些临时表。这样会消耗过多的CPU和IO资源，产生大量的慢查询。
2. 子查询的结果集存储的临时表，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会受到一定的影响。
3. 对于返回结果集比较大的子查询，其对查询性能的影响也就越大。

因此在MySQL中，可以使用连接(JOIN)查询来替代子查询。连接查询不需要建立临时表，其速度比子查询要快，如果查询中使用索引的话，性能就会更好。尽量不要使用NOT IN或者NOT EXISTS，用LEFT JOIN xxx ON xx WHERE xx IS NULL替代。

### 排序优化
在MySQL中支持两种排序方式，分别是FileSort和Index排序：
* Index排序中，索引可以保证数据的有序性，不需要再进行排序，效率更高。
* FileSort排序则一般在内存中进行排序，占用CPU较多。如果待排结果较大，会产生临时文件I/O到磁盘进行排序的情况，效率较低。

因此可以进行如下优化：
1. SQL 中，可以在 WHERE 子句和 ORDER BY 子句中使用索引，目的是在 WHERE 子句中，在 ORDER BY 子句。当然，某些情况下全表扫描，或者 FileSort 排序不一定比索引慢。但总的来说，还是要避免，以提高查询效率。
2. 尽量使用 Index 完成 ORDER BY 排序。如果 WHERE 和 ORDER BY 后面是相同的列就使用单索引列;如果不同就使用联合索引。
3. 无法使用 Index 时，需要对 FileSort 方式进行调优。

### GROUP BY优化
1. group by 即使没有过滤条件用到索引，也可以直接使用索引。
2. group by 先排序再分组，遵照索引建的最佳左前缀法则。
3. 当无法使用索引列，增大 max_length_for_sort_data 和 sort_buffer_size 参数的设置。
4. where效率高于having，能写在where限定的条件就不要写在having中了。
5. 减少使用order by，和业务沟通能不排序就不排序，或将排序放到程序端去做。Order by、group by、distinct这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。
6. 包含了order by、group by、distinct这些查询的语句，where条件过滤出来的结果集请保持在1000行以内，否则SQL会很慢。

### 分页查询优化
1. 在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容。
2. 该方案适用于主键自增的表，可以把Limit查询转换成某个位置的查询。


### EXISTS 和 IN
假设索引都建好了
```SQL
SELECT * FROM a WHERE cc (SELECT cc FROM b);

SELECT * FROM a WHERE EXISTS (SELECT cc FROM b WHERE b.cc = a.cc);
```

当a小于b时，用EXISTS。因为EXISTS的实现，相当于外层循环，实现的逻辑类似于：
```
for i in a:
    for j in b:
        if j.cc == i.cc then ...
```
当b小于a时，用IN。因为实现的逻辑类似于：
```
for i in b:
    for j in a:
        if j.cc == i.cc then ...
```

哪个表小就用哪个表来驱动（作为外层），a表小就用EXISTS，B表小就用IN。

### 统计行数
count(*)和count(1)在myisam和innode都是最优解。

### select(*)
在表查询中，建议明确字段，不要使用 * 作为查询的字段列表，推荐使用SELECT <字段列表> 查询。原因:
1. MySQL 在解析的过程中，会通过查询数据字典 将"*"按序转换成所有列名，这会大大的耗费资源和时间。
2. 无法使用覆盖索引。

### LIMIT 1
针对的是会扫描全表的SQL语句，如果你可以确定结果集只有一条，那么加上LIMIT 1的时候，当找到一条结果的时候就不会继续扫描了，这样会加快查询速度。

如果数据表已经对字段建立了唯一索引，那么可以通过索引进行查询，不会全表扫描的话，就不需要加上LIMIT 1了。