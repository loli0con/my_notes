# 事务

## 事务的定义
数据库事务(transaction)是访问并可能操作各种数据项的一个数据库操作序列，这些操作要么全部执行，要么全部不执行，是一个不可分割的工作单位。

## 事务的ACID特性

### 原子性(atomicity)
事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行(成功提交)，要么都不执行(失败回滚)。

### 一致性(consistency)
事务应确保数据库的状态从一个**一致状态**转变为另一个**一致状态**。这种状态是语义上的而不是语法上的，跟具体的业务有关。**一致状态**的含义是数据库中的数据应满足完整性约束(预定的约束)，这状态是由开发者来定义的(比如满足现实世界中的约束)。满足这个状态，数据就是一致的，不满足这个状态，数据就是不一致的；如果事务中的某个操作失败了，系统就会自动撤销当前正在执行的事务，返回到事务操作之前的状态。

### 隔离型(isolation)
事务的隔离性是指一个事务的执行不能被其他事物干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。

### 持久性(durability)
持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。

持久性是通过 **事务日志** 来保证的。日志包括了 **重做日志** 和 **回滚日志** 。当我们通过事务对数据进行修改的时候，首先会将数据库的变化信息记录到重做日志中，然后再对数据库中对应的行进行修改。这样做的好处是，即使数据库系统崩溃，数据库重启后也能找到没有更新到数据库系统中的重做日志，重新执行，从而使事务具有持久性。


## 事务的状态
事务是一个抽象的概念，它其实对应着一个或多个数据库操作，MySQL根据这些操作所执行的不同阶段把事务大致划分成几个状态:
* 活动的(active)：事务对应的数据库操作正在执行过程中时，我们就说该事务处在**活动的**状态。
* 部分提交的(partially committed)：当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并没有刷新到磁盘时，我们就说该事务处在**部分提交的**状态。
* 失败的(failed)：当事务处在**活动的**或者**部分提交的**状态时，可能遇到了某些错误(数据库自身的错误、操作系统错误或者直接断电等)而无法继续执行，或者人为的停止当前事务的执行，我们就说该事务处在**失败的**状态。
* 中止的(aborted)：如果事务执行了一部分而变为**失败的**状态，那么就需要把已经修改的事务中的操作还原到事务执行前的状态。换句话说，就是要撤销失败事务对当前数据库造成的影响。我们把这个撤销的过程称之为**回滚**。当回滚操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，我们就说该事务处在了**中止的**状态。
* 提交的(committed)：当一个处在**部分提交的**状态的事务将修改过的数据都同步到磁盘上之后，我们就可以说该事务处在了**提交的**状态。

![事务+20221011112630](https://raw.githubusercontent.com/loli0con/picgo/master/images/%E4%BA%8B%E5%8A%A1%2B20221011112630.png%2B2022-10-11-11-26-32)


## 事务的使用
使用事务有两种方式，分别为**显式事务**和**隐式事务**。

### 显式事务
1. `START TRANSACTION`或者`BEGIN`，作用是显式开启一个事务。`START TRANSACTION`语句相较于`BEGIN`特别之处在于，后边能跟随几个修饰符:
   1. `READ ONLY`: 标识当前事务是一个**只读事务**，也就是属于该事务的数据库操作只能读取数据，而不能修改数据。
   2. `READ WRITE`: 标识当前事务是一个**读写事务**，也就是属于该事务的数据库操作既可以读取数据，也可以修改数据。
   3. `WITH CONSISTENT SNAPSHOT`: 启动一致性读。
2. 一系列事务中的操作(主要是DML，不含DDL)
3. `COMMIT`提交事务或中止事务(即`ROLLBACK [TO SAVEPOINT]`回滚事务)

### 隐式事务
MySQL中有一个系统变量**autocommit**控制事务的自动提交：
1. 当我们设置 autocommit=0 时，将关闭**自动提交**的功能。不论是否采用`START TRANSACTION`或者`BEGIN`的方式来开启事务，都需要用`COMMIT`进行提交让事务生效，或使用`ROLLBACK`对事务进行回滚。
2. 当我们设置 autocommit=1 时，将开启**自动提交**的功能，每条 SQL 语句都会自动进行提交。不过这时，如果你采用`START TRANSACTION`或者`BEGIN`的方式来显式地开启事务，本次事务提交或者回滚前会暂时关闭掉自动提交的功能，该事务只有在`COMMIT`时才会生效，或在`ROLLBACK`时才会回滚。

隐式提交数据的情况：
* 数据定义语言(Data definition language，缩写为:DDL)
* 隐式使用或修改Mysql数据库中的表
* 加载数据的语句
* 关于MySQL复制的一些语句
* 事务控制或关于锁定的语句
  * 当我们在一个事务还没提交或者回滚时就又使用`START TRANSACTION`或者`BEGIN`语句开启了另一个事务时，会隐式的提交上一个事务。
  * 当前的**autocommit**系统变量的值为*OFF*，我们手动把它调为*ON*时，也会隐式的提交前边语句所属的事务。
  * 使用`LOCK TABLES`、`UNLOCK TABLES`等关于锁定的语句也会隐式的提交前边语句所属的事务。


## 事务的隔离级别
MySQL是一个**客户端/服务器**架构的软件，对于同一个服务器来说，可以有若干个客户端与之连接，每个客户端与服务器连接上之后，就可以称为一个会话(Session)。每个客户端都可以在自己的会话中向服务器发出请求语句，一个请求语句可能是某个事务的一部分，也就是对于服务器来说可能同时处理多个事务。事务有**隔离性**的特性，理论上在某个事务对某个数据进行访问时，其他事务应该进行排队，当该事务提交之后，其他事务才可以继续访问这个数据。但是这样对**性能影响太大**，我们既想保持事务的隔离性，又想让服务器在处理访问同一数据的多个事务时**性能尽量高些**，那就看二者如何权衡取舍了。

### 数据并发问题
访问相同数据的事务在**不保证串行执行**(也就是执行完一个再执行另一个)的情况下可能会出现的并发问题(按照严重性排序)：
1. 脏写(Dirty Write)：对于两个事务Session A、Session B，如果事务Session A修改了另一个未提交事务Session B修改过的数据，那就意味着发生了脏写。
2. 脏读(Dirty Read)：对于两个事务Session A、Session B，Session A读取了已经被Session B更新但还没有被提交的字段。之后若Session B回滚，Session A读取的内容就是临时且无效的。
3. 不可重复读(Non-Repeatable Read)：对于两个事务Session A、Session B，Session A读取了一个字段，然后Session B更新了该字段。之后Session A再次读取同一个字段，值就不同了。那就意味着发生了不可重复读。
4. 幻读(Phantom)：对于两个事务Session A、Session B，Session A从一个表中读取了一个字段，然后Session B在该表中插入了一些新的行（新插入的那些记录称之为幻影记录）。之后，如果Session A再次读取同一个表，就会多出几行。那就意味着发生了幻读。


### 隔离级别
舍弃一部分隔离性来换取一部分性能在这里就体现在：设立一些隔离级别，隔离级别越低，并发问题发生的就越多。SQL标准中设立了4个隔离级别：
1. READ UNCOMMITTED：读未提交，在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。不能避免脏读、不可重复读、幻读。
2. READ COMMITTED：读已提交，它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这是大多数数据库系统的默认隔离级别(但不是MySQL默认的)。可以避免脏读，但不可重复读、幻读问题仍然存在。
3. REPEATABLE READ：可重复读，事务A在读到一条数据之后，此时事务B对该数据进行了修改并提交，那么事务A再读该数据，读到的还是原来的内容。可以避免脏读、不可重复读，但幻读问题仍然存在。这是MySQL的默认隔离级别。
4. SERIALIZABLE：可串行化，确保事务可以从一个表中读取相同的行。在这个事务持续期间，禁止他事务对该表执行插入、更新和删除操作。所有的并发问题都可以避免，但性能十分低下。能避免脏读、不可重复读和幻读。

SQL标准中规定，针对不同的隔离级别，并发事务可以发生不同严重程度的问题，具体情况如下:
|隔离级别|脏写可能性|脏读可能性|不可重复读可能性|幻读可能性|加锁读|
|---|---|---|---|---|---|
|READ UNCOMMITTED|no|yes|yes|yes|no|
|READ COMMITTED|no|no|yes|yes|no|
|REPEATABLE READ|no|no|no|yes|no|
|SERIALIZABLE|no|no|no|no|yes|

不同的隔离级别有不同的现象，并有不同的锁和并发机制，隔离级别越高，数据库的并发性能就越差，4种事务隔离级别与并发性能的关系如下:
![事务+20221012103611](https://raw.githubusercontent.com/loli0con/picgo/master/images/%E4%BA%8B%E5%8A%A1%2B20221012103611.png%2B2022-10-12-10-36-12)


### 配置Mysql级别
MySQL的默认隔离级别为REPEATABLE READ

#### 查看隔离级别

##### 方式一
`SHOW VARIABLES LIKE 'transaction_isolation'`

##### 方式二
`SELECT @@transaction_isolation`

#### 设置隔离级别

##### 方式一
`SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL 隔离级别`，其中隔离级别格式:
* READ UNCOMMITTED
* READ COMMITTED
* REPEATABLE READ
* SERIALIZABLE

##### 方式二
`SET [GLOBAL|SESSION] TRANSACTION_ISOLATION = '隔离级别'`，其中隔离级别格式:
* READ-UNCOMMITTED
* READ-COMMITTED
* REPEATABLE-READ
* SERIALIZABLE