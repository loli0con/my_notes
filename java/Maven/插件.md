# 插件
<b>插件(plugin)</b>是扩展Maven功能的可执行组件，每个插件包含一个或多个<b>目标(goals)</b>，用于执行特定任务（如编译、测试、打包等）。

## 插件与生命周期的关系
在Maven<b>生命周期(Lifecycle)</b>中都包含着一系列的<b>阶段(phase)</b>，这些阶段就相当于Maven提供的统一的接口，然后这些阶段的实现由插件来完成。

![20251217090516](https://raw.githubusercontent.com/loli0con/picgo/master/20251217090516.png)

例如输入`mvn clean`命令，clean对应clean生命周期中的clean阶段，该阶段的具体操作是由 maven-clean-plugin插件实现的。

Maven 实际上是一个依赖插件执行的框架，每个任务实际上是由插件完成。

插件通常提供了一个目标的集合，这些目标可能被绑定到多个阶段或者无绑定，不绑定到任何构建阶段的目标可以在构建生命周期之外通过直接调用执行。在给不同的生命周期阶段绑定不同的插件目标后，这些目标的执行自然是按阶段的顺序逐个执行。如果在一个阶段上绑定了多个目标则按插件声明的顺序执行。

## 插件的坐标
插件通过groupId、artifactId、version唯一标识。

|属性|说明|常见值|
|---|---|---|
|groupId|插件组织|org.apache.maven.plugins（官方插件）|
|artifactId|插件名称|maven-compiler-plugin|
|version|插件版本|3.8.1|

## 插件的类型
Maven提供了下面两种类型的插件：
* Build plugins：在构建时执行，并在pom.xml的元素中配置。
* Reporting plugins：在网站生成过程中执行，并在pom.xml的元素中配置。

## 常用的插件
下面是一些常用插件的列表：
* clean：构建之后清理目标文件。删除目标目录。
* compiler：编译Java源文件。
* surefile：运行JUnit单元测试。创建测试报告。
* jar：从当前工程中构建JAR文件。
* war：从当前工程中构建WAR文件。
* javadoc：为工程生成Javadoc。
* antrun：从构建过程的任意一个阶段中运行一个ant任务的集合。

## 插件的绑定方式
Maven的生命周期和插件需要实现相互绑定，让Maven构建工程时自动调用插件完成指定的任务。将生命周期的阶段和插件目标进行绑定的方式一共有两种：内置绑定和自定义绑定。

### 内置绑定
Maven在安装好后，自动为生命周期的主要阶段绑定很多插件的目标。当用户通过命令或图形界面执行生命周期的某个阶段时，对应的插件目标就会自动执行，从而完成任务。

#### 内置绑定的示例
Maven已为生命周期阶段预绑定插件目标：
|生命周期阶段|绑定的插件目标|
|---|---|
|compile|maven-compiler-plugin:compile|
|test|maven-surefire-plugin:test|
|package|maven-jar-plugin:jar（或 maven-war-plugin:war）|

### 自定义绑定
除了Maven内置的绑定外，也可以指定在某个阶段绑定某个插件的某个目标，这样就使得Maven在构建项目时能够执行更多的任务。这样的任务，Maven没有内置绑定到生命周期的阶段上，所以这就需要用户自己配置了。这样的配置可以加在pom.xml中。

##### 自定义绑定的示例
使用maven-antrun-plugin插件把数据输出到控制台上。
```xml
<project
    xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
    http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <groupId>com.companyname.projectgroup</groupId>
    <artifactId>project</artifactId>
    <version>1.0</version>
    <!-- 构建的相关信息 -->
    <build>
        <!-- 插件的相关信息 -->
        <plugins>
            <plugin>
                <!-- 插件坐标 -->
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-antrun-plugin</artifactId>
                <version>1.1</version>
                <!-- 插件运行的相关信息 -->
                <executions>
                    <execution>
                        <id>id.clean</id>
                        <!-- 绑定的阶段 -->
                        <phase>clean</phase> 
                        <!-- 目标 -->
                        <goals>
                            <goal>run</goal>
                        </goals>
                        <!-- 插件的运行参数，局部参数 -->
                        <configuration>
                            <tasks>
                                <echo>clean phase</echo>
                            </tasks>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>
</project>
```

打开命令终端跳转到pom.xml所在的目录，并执行下面的mvn命令：
```shell
mvn clean
```

Maven将开始处理并显示clean生命周期的clean阶段：
```log
[INFO] Scanning for projects...
[INFO] ------------------------------------------------------------------
[INFO] Building Unnamed - com.companyname.projectgroup:project:jar:1.0
[INFO]    task-segment: [post-clean]
[INFO] ------------------------------------------------------------------
[INFO] [clean:clean {execution: default-clean}]
[INFO] [antrun:run {execution: id.clean}]
[INFO] Executing tasks
     [echo] clean phase
[INFO] Executed tasks
[INFO] ------------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ------------------------------------------------------------------
[INFO] Total time: < 1 second
[INFO] Finished at: Sat Jul 07 13:38:59 IST 2012
[INFO] Final Memory: 4M/44M
[INFO] ------------------------------------------------------------------
```
上面的例子展示了以下关键概念：
* 插件是在pom.xml中使用plugins元素定义的。
* 每个插件可以有多个目标。
* 可以定义阶段，插件会使用它的phase元素开始处理。例子中使用了clean阶段。
* 可以通过绑定到插件的目标的方式来配置要执行的任务。例子中绑定了echo任务到maven-antrun-plugin的run目标。
* Maven将处理剩下的事情，它将下载本地仓库中获取不到的插件，并开始处理。


### 插件的运行参数
通过命令行和pom配置两种方式给这些<b>目标(goal)</b>设置参数值。

#### 命令行配置参数
在命令行中，使用`-D参数名称=参数值`的方式配置目标参数。

例如，maven-surefire-plugin插件中提供了一个skipTests参数，当它的值为true时，就不会执行单元测试。具体语法是：
```shell
mvn test -DskipTests=true
```

#### pom配置参数
上面的示例maven-antrun-plugin示例中已经展示过了在pom中配置**局部参数**的方法，下面的示例展示的是配置**全局参数**的方法。
```xml
<project
    xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
    http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <groupId>com.companyname.projectgroup</groupId>
    <artifactId>project</artifactId>
    <version>1.0</version>
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-antrun-plugin</artifactId>
                <version>1.1</version>
                <!-- 插件运行参数，全局参数 -->
                <configuration>
                    <tasks>
                        <echo>clean phase</echo>
                    </tasks>
                </configuration>
                <executions>
                    <execution>
                        <id>id.clean</id>
                        <phase>clean</phase>
                        <goals>
                            <goal>run</goal>
                        </goals>
                        <!-- 插件运行参数，局部参数 -->
                        <!-- <configuration>
                            <tasks>
                                <echo>clean phase</echo>
                            </tasks>
                        </configuration> -->
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>
</project>
```


## 获取插件信息

### 在线查找插件
插件基本上都来源于两处，一个是Apache（官方）；另一个是Codehaus（三方）。

### 使用maven-help-plugin查看插件
语法如下，可以选择查询整个插件或某个目标，并指定是否要查看详情。
```shell
mvn help:describe -dplugin=插件 -Dgoal=目标 -Ddetail
```

## 直接调用插件
可以直接在命令行执行插件，例如前面的查看插件信息的命令，就是在调用help插件的describe目标来完成查看任务的。

使用命令行执行 Maven 插件的语法如下：
```shell
mvn <插件名称|前缀>:<目标> [-D参数名=参数值 ...]
```



## 插件前缀
Maven为了方便用户提供的一种执行插件的简单方式：可以使用**插件前缀**来指定插件。

例如，在不指定插件的坐标信息（groupId、artifactId、version）的情况下，可以成功执行命令`mvn compiler:compile`。命令中的`compiler`就是**插件前缀**。

### 插件仓库
同依赖构件一样，插件构件也是基于坐标存储在Maven仓库中的。在需要时，Maven先从本地仓库中查找插件，如果没有，就从远程仓库查找。找到插件后，下载到本地仓库使用。

### groupId
在使用插件或者在pom中配置插件的时候，如果使用的是Maven官方插件的话，是可以不指定groupId的，因为这些插件的groupId都是一样的，都是org.apache.maven.plugins。

如果没有配置指定groupId的话，则默认是org.apache.maven.plugins。

### version
如果没有指定插件的版本，Maven对版本处理的方式是：如果插件不属于核心插件范畴，Maven会去检测所有仓库中的版本，最终会选择**最新版本**，而且这个最新版本不排除是快照版本。

### 解析插件的前缀
**插件前缀**与**groupId:artifactId**是一一对应的（也就是知道插件前缀，就可以找到groupId和artifactId）。这种对应关系保存在仓库的元数据中，该元数据是groupId/maven-metadata.xml。

目前绝大部分插件都是放在<u>Maven官方仓库(http://repo1.maven.org)</u>和<u>codehaus第三方仓库(http://repository.codehaus.org)</u>中的，它们的groupId对应的是<u>org.apache.maven.plugins</u>和<u>org.codehaus.mojo</u>。

Maven在解析插件仓库元数据的时候，会默认使用<u>org.apache.maven.plugins</u>和<u>org.codehaus.mojo</u>两个groupId，也就是说，Maven 会自动检测 http://repo1.maven.org/maven2/org/apache/maven/plugins/maven-metadata.xml 和 http://repository.codehaus.org/org/codehaus/mojo/maven-metadata.xml 中的元数据。

插件仓库数据的内容是大概是这样的：
```xml
<!-- org.apache.maven.plugins 中 groupId 部分的内容 -->
<metadata>
    <plugins>
        <plugin>
            <name>Maven Compiler Plugin</name>
            <prefix>compiler</prefix>
            <artifactId>maven-compiler-plugin</artifactId>
        </plugin>
        <plugin>
            <name>Maven Clean Plugin</name>
            <prefix>clean</prefix>
            <artifactId>maven-clean-plugin</artifactId>
        </plugin>
        <plugin>
            <name>Maven Dependency Plugin</name>
            <prefix>dependency</prefix>
            <artifactId>maven-dependency-plugin</artifactId>
        </plugin>
            ...
    </plugins>
</metadata>
```
从上面的内容中可以发现：
* maven-compiler-plugin的前缀是compiler
* maven-clean-plugin的前缀是clean
* maven-dependency-plugin的前缀是dependency

当Maven解析到`compiler:compile`命令后，它首先基于默认的groupId归并所有插件仓库的元数据org/apache/maven/plugins/maven-metadata.xml。接着检查归并后的元数据，找到对应的artifactId为maven-compiler-plugin。

接下来再结合当前元数据的groupId为org.apache.maven.plugins。最后找到仓库中最新的version，从而就可以得到一个插件的完整坐标信息。

如果在第一个metadata.xml中没有找到目标插件，就用同样的流程找其他的metadata.xml，包括用户自己定义的metadata.xml。如果所有的地方都没有找到对应的前缀，这就以报错的形式结束了。