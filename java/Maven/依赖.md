# 依赖
Maven依赖机制是构建工具的核心功能之一，它能够自动下载和管理项目所需的外部库（JAR 文件）及其依赖关系。当你在项目中声明某个依赖时，Maven会自动从仓库中下载该库及其所有依赖项。

## 依赖的声明方式
依赖是在项目的pom.xml中声明的，具体内容如下：
```xml
<project>
    ...
    <dependencies>
        <dependency>
            <groupId>...</groupId>
            <artifactId>...</artifactId>
            <version>...</version>
            <type>...</type>
            <scope>...</scope>
            <!-- 不推荐使用optional标签 -->
            <optional>...</optional>
            <exclusions>
                <exclusion>...</exclusion>
            </exclusions>
        </dependency>
        ...
    </dependencies>
    ...
</project>
```

这些元素的作用如下：
* groupId、artifactId和version：依赖的坐标，Maven以此来唯一标识一个依赖项。
* type：依赖的类型，同项目中的packaging对应。大部分情况不需要声明，默认是jar。
* scope：依赖的范围。
* optional：标记依赖是否可选（不推荐使用）。
* exclusions：排除传递性依赖。

## 依赖的范围
<b>依赖范围(Scope)</b>定义了依赖包在项目构建生命周期不同阶段（*编译*、*测试*、*运行*）的可用性，总共包括以下6种。

|依赖范围|编译时|测试时|运行时|描述|
|---|---|---|---|---|
|compile|Y|Y|Y|默认值，全程需要|
|test|N|Y|N|仅用于测试|
|runtime|N|Y|Y|运行时需要|
|provided|Y|Y|N|容器已提供|
|system|Y|Y|N|指定本地路径|
|import|-|-|-|管理依赖版本|


### compile
如果在配置的时候没有指定，就默认使用这个范围。使用此范围的依赖，将参与当前项目的编译、测试、运行和打包。

### test
使用此范围的依赖，仅参与当前项目的测试流程。在编译主代码或运行项目的时候，该依赖项是无效的。

### runtime
使用此范围的依赖，将参与测试、运行和打包流程，但在编译主代码时是无效的。

例如JDBC驱动实现类，需要在运行测试和运行主代码时候使用，在编译的时候，只需JDBC接口即可。

### provided
我们使用**provided**来标记应由JDK或容器在运行时提供的依赖项。

使用此范围的依赖，可以参与当前项目的编译、测试、运行流程，但打包时被排除。

例如Web应用中的servlet-api，编译和测试的时候就需要该依赖。在Web容器中运行该应用的时候，因为容器中自带了servlet-api，所以Web应用就没必要再携带多一个servlet-api。否则，有可能出现版本不一致的冲突。

### system
使用此范围的依赖，同**provided**一样。但是，必须通过systemPath元素指定依赖文件的路径。该依赖不在Maven的仓库中进行查找。

如下代码是一个使用 system 范围的案例。
```xml
<dependency>
    <groupId>xxx</groupId>
    <artifactId>xxx</artifactId>
    <version>xx</version>
    <scope>system</scope>
    <systemPath>e:/xxxx/xxx/xx.jar</systemPath>
</dependency>
```

### import
**import**是一种特殊的依赖范围，只能在`<dependencyManagement>`标签内部使用，并且要求被导入的依赖的类型（type）必须是pom。它的作用是将另一个POM文件中的`<dependencyManaement>`配置导入并合并到当前项目中，实现集中管理和版本控制，通常用于BOM（Bill of Materials，物料清单）导入，让项目统一管理一组依赖的版本，无需在各处重复指定版本号。

#### 示例场景
比如有个SpringPOM Maven工程，它的pom.xml的`<dependencyManagement>`配置如下：
```xml
<project>
    ...
    <groupId>cn.com.mvn.pom</groupId>
    <artifactId>SpringPOM</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <packaging>pom</packaging>
    ...
    <dependencyManagement>
        <dependencies>
            <!-- 以下三个是spring框架需要导入的依赖 -->
            <dependency>
                <groupId>org.springframework</groupId>
                <artifactId>spring-core</artifactId>
                <version>${project.build.spring.version}</version>
            </dependency>
            <dependency>
                <groupId>org.springframework</groupId>
                <artifactId>spring-aop</artifactId>
                <version>${project.build.spring.version}</version>
            </dependency>
            <dependency>
                <groupId>org.springframework</groupId>
                <artifactId>spring-beans</artifactId>
                <version>${project.build.spring.version}</version>
            </dependency>
        </dependencies>
    </dependencyManagement>
    ...
</project>
```

接下来创建一个新的Maven工程，要将SpringPOM Maven工程pom.xml中定义的`<dependencyManagement>`原样合并过来，除了手工复制粘贴或Maven项目继承之外，还可以编写如下代码，将它们导入进去：
```xml
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>cn.com.mvn.pom</groupId>
            <artifactId>SpringPOM</artifactId>
            <version>0.0.1-SNAPSHOT</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
```

## 依赖的传递
Maven会解析项目中的每个直接依赖，然后将那些必要的间接依赖以传递依赖的形式引入项目中。传递依赖在将间接依赖引入项目的过程中有它自己的规则和范围。

现在有三个项目（A、B和C项目），假设“A依赖B，B依赖C”，那么：
* A对B的依赖叫第一直接依赖
* B对C的依赖叫第二直接依赖
* A对C的依赖叫传递依赖（通过B传递的）。

<u>A到B第一直接依赖的范围</u>和<u>B到C第二直接依赖的范围</u>，共同决定了<u>A到C的传递依赖范围</u>。它们的影响效果如下表所示。坐标第一列表示第一直接依赖的范围，第一行表示第二直接依赖的范围，中间的交叉点为共同影响后的传递依赖的范围。

|第一直接依赖⬇ / 第二直接依赖➡|compile|test|runtime|provided|
|---|:---:|:---:|:---:|:---:|
|compile|compile|-|runtime|-|
|test|test|-|test|-|
|runtime|runtime|-|runtime|-|
|provided|provided|-|provided|provided|

## 依赖的调解
当多个直接依赖都带来了同一个间接依赖，而且是不同版本的间接依赖时，就会引起重复依赖的问题，因此需要进行调解。

### 依赖调解原则
Maven 依赖调解原则有两个：一个是路径优先原则；另一个是声明优先原则。当路径优先原则搞不定的时候，再使用声明优先原则。

#### 路径优先原则
如果有个项目A，它有两个依赖：A→B→C→T<sub>v1</sub>和A→D→T<sub>v2</sub>。

项目A最终对T<sub>v1</sub>和T<sub>v2</sub>都有间接依赖。这时候Maven会自动判断它的路径，发现T<sub>v2</sub>的路径长度为2，T<sub>v1</sub>的路径长度为3，以最短路径为原则，将T<sub>v2</sub>引入当前项目A。

#### 声明优先原则
如果有个项目A，它有两个依赖：A→B→TT<sub>v1</sub>和A→C→T<sub>v2</sub>。

这时候两条路径都是一样的长度2，Maven会判断哪个依赖在pom.xml中先声明，选择引入先声明的依赖。

## 依赖的排除
在依赖的配置里面添加`<exclusions>`和`<exclusion>` 元素，指定要排除依赖的`groupId`和`artifactId`，这样可以排除依赖。
```xml
<dependencies>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-context</artifactId>
        <version>5.2.0.RELEASE</version>
        <!--依赖排除
            介绍：排除指定的间接依赖jar包
            目标：排除'spring-core:5.2.0'
            排除后的结果：'spring-core:5.1.0'生效（被spring-webmvc引入）
        -->
        <exclusions>
            <exclusion>
                <groupId>org.springframework</groupId>
                <artifactId>spring-core</artifactId>
            </exclusion>
        </exclusions>
    </dependency>
    <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-webmvc</artifactId>
            <version>5.1.0.RELEASE</version>
    </dependency>
</dependencies>
```

## 可选依赖
父项目中的依赖设置成可选依赖，在子项目中再具体指定使用哪个依赖：
```xml
<!-- 父项目 -->
<dependencies>
    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
        <version>5.1.34</version>
        <!--
            目标：可选依赖
            介绍：optional，含义“可选的”，即不传递（需要手动写）
                值1：<optional>true</optional>, 不进行依赖传递
                值2：<optional>false</optional>, 进行依赖传递,也是默认值
        -->
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>oracle</groupId>
        <artifactId>ojdbc14</artifactId>
        <version>10.2.0.4</version>
        <optional>true</optional>
    </dependency>
</dependencies>

<!-- 子项目 -->
<dependencies>
    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
        <version>5.1.34</version>
    </dependency>
</dependencies>
```

## 依赖的优化
在软件开发过程中，需要通过重构等方式不断优化代码，使其变得更简洁、灵活、高效。同样，程序员也应该对 Maven 项目的依赖了然于胸，并对其进行优化。因此程序员必须对项目中的依赖有全面的了解，这样才能更有效地达到目的。

可以使用如下的命令查看依赖：
* `mvn dependency:list`：列出所有的依赖列表。
* `mvn dependency:tree`：以树形结构方式，列出依赖和层次关系，有助于分析依赖关系和解决依赖冲突。
* `mvn dependency:analyze`：分析依赖问题，如项目中使用但未声明的依赖，以及声明但未使用的依赖。
* `mvn dependency:sources`：下载项目依赖的源代码。
* `mvn dependency:copy-dependencies`：复制依赖到目录。
* `mvn dependency:purge-local-repository`：清除本地依赖缓存（删除整个本地仓库中的依赖）。
* `mvn versions:display-dependency-updates`：检查可用更新，检查项目中哪些依赖有更新的版本可用。