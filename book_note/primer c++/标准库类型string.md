# string
标准库类型**string**表示可变长的字符序列，使用string类型必须首先包含string头文件。作为标准库的一部分，string定义在命名空间std中。



## 定义和初始化string对象
如何初始化类的对象是由类本身决定的。一个类可以定义很多种初始化对象的方式，只不过这些方式之间必须有所区别：或者是初始值的数量不同，或者是初始值的类型不同。初始化string对象的方式：
```c++
string s1;           // 默认初始化，s1是一个空字符串
string s2(s1);       // s2是s1的副本
string s2 = s1;      // 等价于s2(s1)，s2是s1的副本
string s3("value");  // s3是字面值"value"的副本，除了字面值最后的那个空字符外
string s3 = "value"; // 等价于s3("value")，s3是字面值"value"的副本
string s4(n, 'c');   // 把s4初始化为由连续n个字符c组成的串
```

### 直接初始化和拷贝初始化
如果使用等号（=）初始化一个变量，实际上执行的是**拷贝初始化（copy initialization）**，编译器把等号右侧的初始值拷贝到新创建的对象中去。与之相反，如果不使用等号，则执行的是**直接初始化（direct initialization）**。

当初始值只有一个时，使用直接初始化或拷贝初始化都行。如果初始化要用到的值有多个，一般来说只能使用直接初始化的方式：
```c++
string s5 = "value"; // 拷贝初始化
string s6("value");  // 直接初始化
string s7(10, 'c');  // 直接初始化，s7的内容是cccccccccc
```

对于用多个值进行初始化的情况，非要用拷贝初始化的方式来处理也不是不可以，不过需要显式地创建一个（临时）对象用于拷贝：
```c++
string s8 = string(10, 'c'); // 拷贝初始化，s8的内容是cccccccccc
// 上面这条语句本质上等价于下面的两条语句
string temp(10, 'c'); // temp的内容是cccccccccc
string s8 = temp;     // 将temp拷贝给s8
```
尽管初始化s8的语句合法，但和初始化s7的方式比较起来可读性较差，也没有任何补偿优势。



## string对象上的操作
一个类除了要规定初始化其对象的方式外，还要定义对象上所能执行的操作。其中，类既能定义通过函数名调用的操作，也能定义<<、+等各种运算符在该类对象上的新含义。下面列举了string的大多数操作。
|操作|含义|
|---|---|
|os<<s|将s写到输出流os当中，返回os|
|is>>s|从is中读取字符串赋给s，字符串以空白分隔，返回is|
|getline(is, s)|从is中读取一行赋给s，返回is|
|s.empty()|s为空返回true，否则返回false|
|s.size()|返回s中字符的个数|
|s\[n]|返回s中第n个字符的引用，位置n从0计起|
|s1+s2|返回s1和s2连接后的结果|
|s1=s2|用s2的副本代替s1中原来的字符|
|s1==s2<br>s1!=s2|如果s1和s2中所含的字符完全一样，则它们相等；string对象的相等性判断对字母的大小写敏感|
|<，<=，>，>=|利用字符在字典中的顺序进行比较，且对字母的大小写敏感|

### getline
getline函数的参数是一个输入流和一个string对象，函数从给定的输入流中读入内容，直到遇到换行符为止（注意换行符也被读进来了），然后把所读的内容存入到那个string对象中去（注意不存换行符）。getline只要一遇到换行符就结束读取操作并返回结果，哪怕输入的一开始就是换行符也是如此。

### size
size函数返回string对象的长度，是一个string::size_type类型的值。它是一个无符号类型的值，而且能足够存放下任何string对象的大小。所有用于存放string类的size函数返回值的变量，都应该是string::size_type类型的，允许使用编译器通过auto或decltype来推断变量的类型。

string类及其他大多数标准库类型都定义了几种配套的类型。这些配套类型体现了标准库类型与机器无关的特性，类型size_type即是其中的一种。在具体使用的时候，通过作用域操作符来表示名字size_type是在类中定义的。

### 比较string对象
string类定义了几种用于比较字符串的运算符。这些比较预算符逐一比较string对象中的字符，并且对大小写敏感。

相等性运算符（==和!=）分别检验两个string对象相等或不相等，string对象相等意味着它们的长度相同而且所包含的字符也全部相同。关系运算符<、<=、>、>=分别检验一个string对象是否小于、小于等于、大于、大于等于另外一个string对象。上述这些运算符都依照（大小写敏感的）字典顺序：
1. 如果两个string对象的长度不同，而且较短的string对象的每个字符都与较长string对象对应位置上的字符相同，就说较短string对象小于较长string对象。
2. 如果两个string对象在某些对应的位置上不一致，则string对象比较的结果其实是string对象中第一对相异字符比较的结果。

### 字面值和string对象相加
C++语言中的字符串字面值并不是标准库类型string的对象。标准库允许把字符字面值和字符串字面值转换成string对象，所以在需要string对象的地方就可以使用这两种字面值来代替。

当把string对象和字符字面值及字符串字面值混在一条语句中使用时，必须确保每个加法运算符（+）的两侧的对象至少有一个是string。



## 处理string对象中的字符
我们经常需要单独处理string对象中的字符，这类处理的一个关键问题是如何获取字符本身，另一个关键问题是要知道能改变某个字符的特性。在cctype头文件中定义了一组标准库函数处理这部分工作，下面列出主要的函数名及其含义。
|函数名|含义|
|---|---|
|isalnum(c)|当c是字母或数字时为真|
|isalpha(c)|当c是字母时为真|
|iscntrl(c)|当c是控制字符时为真|
|isdigit(c)|当c是数字时为真|
|isgraph(c)|当c不是空格但可打印时为真|
|islower(c)|当c是小写字母时为真|
|isprint(c)|当c是可打印字符时为真（即c是空格或c具有可视形式）|
|ispunct(c)|当c是标点符号时为真（即c不是控制字符、数字、字母、可打印空白中的一种）|
|isspace(c)|当c是空白时为真（即c是空格、横向制表符、纵向制表符、回车符、换行符、进纸符中的一种）|
|isupper(c)|当c是大写字母时为真|
|isxdigit(c)|当c是十六进制数字时为真|
|tolower(c)|如果c是大写字母，输出对应的小写字母；否则原样输出c|
|toupper(c)|如果c是小写字母，输出对应的大写字母；否则原样输出c|

### 处理每个字符
如果想对string对象中的每个字符做点操作，最好的办法是使用**范围for（range for）语句**，这种语句编译给定序列中的每个元素并对序列中的每个值执行某种操作，其语法形式是：
```c++
for (declaration : expresion)
    statement
```
其中expression部分是一个对象，用于表示一个序列。declaration部分负责定义一个变量，该变量将被用于访问序列中的基础元素。每次迭代，declaration部分的变量会被初始化为expression部分的下一个元素值。

一个string对象表示一个字符的序列，因此string对象可以作为范围for语句中的expression部分。

### 使用范围for语句改变字符串中的字符
如果想要改变string对象中字符的值，必须把循环变量定义成引用类型。所谓引用只是给定对象的一个别名，因此当使用引用作为循环控制变量时，这个变量实际上被依次绑定到了序列的每个元素上。使用这个引用，我们就能改变它绑定的字符。

### 只处理一部分字符
想要访问string对象中的单个字符有两种方式：一种是使用下标，另外一种是使用迭代器。

**下标运算符（[]）**接收的输入参数是string::size_type类型的值，这个参数表示要访问的字符的位置；返回值是该位置上字符的引用。

string对象的下标从0计起，下标必须大于等于0而小于s.size()，使用超出范围的下标将引发不可预知的后果，以此类推，使用下标访问空string也会引发不可预知的后果。一种简便易行的方法是，总是设下标的类型为string::size_type，因为此类型是无符号数。可以确保下标不会小于0。此时，代码只需要保证下标小于size()的值就行了。

下标的值称作“下标”或“**索引**”，任何表达式只要它的值是一个整型值就能作为索引。不过，如果某个索引是带引符号类型的值将自动转换成由string::size_type表达的无符号类型。

只要字符串不是常量，就能为下标运算符返回的字符赋新值。