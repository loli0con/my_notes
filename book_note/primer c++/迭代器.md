# 迭代器
有一种更通用的机制可以实现对string对象的字符或vector对象的元素进行访问，这就是**迭代器（iterator）**。除了vector之外，标准库还定义了其他几种容器。所有标准库容器都可以使用迭代器，但是其中只有少数几种才同时支持下标运算符。

类似于指针类型，迭代器也提供了对对象的间接访问。就迭代器而言，其对象是容器中的元素或者string对象中的字符。使用迭代器可以访问某个元素，迭代器也能从一个元素移动到另外一个元素。迭代器有有效和无效之分，这一点和指针差不多。有效的迭代器或者指向某个元素，或者指向容器中尾元素的下一位置；其他情况都属于无效。



## 使用迭代器
和指针不一样的是，获取迭代器不是使用取地址符，有迭代器的类型同时拥有返回迭代器的成员。比如，这些类型都拥有名为**begin**和**end**的成员，其中begin成员负责返回指向第一个元素（或第一个字符）的迭代器。如有下述语句：
```C++
// 由编译器决定b和e的类型
// b表示v的第一个元素，e表示v尾元素的下一个位置
auto b = v.begin(), e = v.end(); // b和e的类型相同
```
end成员则负责返回指向容器（或string对象）“尾元素的下一位置（one past the end）”的迭代器，也就是说，该迭代器指示的是容器的一个本不存在的“**尾后（off the end）**”元素。这样的迭代器没什么实际含义，仅是个标记而已，表示我们已经处理完了容器中的所有元素。end成员返回的迭代器常被称作**尾后迭代器（off-the-end iterator）**或者简称为尾迭代器（end iterator）。特殊情况下如果容器为空，则begin和end返回的是同一个迭代器，都是尾后迭代器。

一般来说，我们不清楚（不在意）迭代器准确的类型到底是什么。在上面的例子中，使用auto关键字定义变量b和e，这两个变量的类型也就是begin和end的返回值类型。

### 迭代器运算符
|标准容器迭代器的运算符|解释|
|---|---|
|*iter|返回迭代器iter所指元素的引用|
|iter->mem|解引用iter并获取该元素名为mem的成员，等价于(*iter).mem|
|++iter|令iter指示容器中的下一个元素|
|--iter|令iter指示容器中的上一个元素|
|iter1 == iter2<br>iter1 != iter2|判断两个迭代器是否相等（不相等），如果两个迭代器指示的是同一个元素或者它们是同一个容器的尾后迭代器，则相等；反之，不相等|

和指针类似，也能通过解引用迭代器来获得它所指示的元素，执行解引用的迭代器必须合法且确实指示着某个元素。试图解引用一个非法迭代器或者尾后迭代器都是未被定义的行为。

### 将迭代器从一个元素移动到另外一个元素
迭代器使用递增（++）运算符来从一个元素移动到下一个元素。从逻辑上来说，迭代器的递增和整数的递增类似，整数的递增是在整数值“加1”，迭代器的递增则是将迭代器“向前移动一个位置”。

因为end返回的迭代器不实际指示某个元素，所以不能对其进行递增或解引用的操作。

原来使用C或Java的程序员在转而使用C++语言之后，会对for循环中使用!=而非<进行判断有点儿奇怪，这是因为这种编程风格在标准库提供的所有容器上都有效。所有标准库容器的迭代器都定义了==和!=，但是它们中的大多数都没有定义<运算符。

### 迭代器类型
一般来说我们无须知道迭代器的精确类型。实际上，那些拥有迭代器的标准库类型使用iterator和const_iterator来表示迭代器的类型。

const_iterator和常量指针差不多，能读取但不能修改它所指的元素值。相反，iterator的对象可读可写。如果vector对象或string对象是一个常量，只能使用const_iterator；如果vector对象或string对象不是常量，那么既能使用iterator也能使用const_iterator。

### 迭代器和迭代器类型
迭代器这个名词有三种不同的含义：
* 可能是迭代器概念本身
* 也可能是指容器定义的迭代器类型
* 还可能是指某个迭代器对象

重点是理解存在一组概念上相关的类型，我们认定某个类型是迭代器当且仅当它支持一套操作，这套操作使得我们能访问容器的元素或者从某个元素移动到另一个元素。

每个容器类定义了一个名为iterator的类型，该类型支持迭代器概念所规定的一套操作。

### begin和end运算符
begin和end返回的具体类型由对象是否是常量决定，如果对象是常量，begin和end返回const_iterator；如果不是常量，返回iterator。

为了便于专门得到const_iterator类型的返回值，可以使用cbegin和cend函数。类似于begin和end，上述两个函数也返回指示容器第一个元素或最后元素下一个位置的迭代器。有所不同的是，不论vector对象（或string对象）本身是否是常量，返回值都是const_iterator。

### 结合解引用和成员访问操作
解引用迭代器可获得迭代器所指的对象，如果该对象的类型恰好是类，就有可能希望进一步访问它的成员。C++语言定义了**箭头运算符**（->），箭头运算符能把解引用和成员访问两个操作结合在一起，也就是说，it->men和(*it).men表达的意思相同。

### 某些对vector对象的操作会使迭代器失效
任何一种可能改变vector对象容量的操作，比如push_back，都会使该vector对象的迭代器失效。



## 迭代器运算
string和vector的迭代器提供了更多额外的运算符，一方面可使得迭代器的每次移动跨过多个元素，另外也支持迭代器进行关系运算。所有这些运算被称作**迭代器运算（iterator arithmetic）**，其细节如下：
* iter + n：迭代器加上一个整数值仍得一个迭代器，迭代器指示的新位置与原来相比向前移动了若干个元素。结果迭代器或指示容器内的一个元素，或者指示容器尾元素的下一位置。
* iter - n：迭代器加上一个整数值仍得一个迭代器，迭代器指示的新位置与原来相比向后移动了若干个元素。结果迭代器或指示容器内的一个元素，或者指示容器尾元素的下一位置。
* iter1 += n：迭代器加法的复合赋值语句，将iter1加n的结果赋给iter1。
* iter1 -= n：迭代器减法的复合赋值语句，将iter1减n的结果赋给iter1。
* iter1 - iter2：两个迭代器相减的结果是它们之间的距离，也就是说，将运算符右侧的迭代器向前移动差值个元素后将得到左侧的迭代器。参与运算的两个迭代器必须指向的是同一个容器中的元素或者尾元素的下一个位置。
* \>、 >=、 <、 <=：迭代器的关系运算符，如果某迭代器指向的容器位置在另一个迭代器所指位置之前，则说明前者小于后者。参与运算的两个迭代器必须指向的是同一个容器中的元素或者尾元素的下一个位置。

### 迭代器的算术运算
只要两个迭代器指向的是同一个容器中的元素或者尾元素的下一位置，就能将其相减，所得结果是两个迭代器的距离。所谓距离指的是右侧的迭代器向前移动多少位置就能追上左侧的迭代器，其类型是名为**difference_type**的带符号整型数。