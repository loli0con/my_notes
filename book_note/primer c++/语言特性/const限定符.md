# const限定符
如果使用关键字**const**对变量的类型加以限定，那么该变量的值将不能被改变，这样就把该变量定义成了一个常量，任何试图为该变量赋值的行为都将引发错误。

## 初始化和const
因为const对象一旦创建后其值就不能再改变，所以const对象必须初始化，初始值可以是任意复杂的表达式。

在const类型的对象上只能执行不改变其内容的操作。

## 有效范围
当以编译时初始化的方式定义一个const变量时，编译器将在编译过程中把用到该变量的地方都替换成对应的值。

为了执行上述替换，编译器必须知道变量的初始值。如果程序包含多个文件，则每个用了const对象的文件都必须得访问到它的初始值才行。要做到这一点，就必须在每一个用到变量的文件中都对它有定义。为了支持这一用法，同时避免对同一变量的重复定义，默认情况下，const对象被设定为仅在文件内有效。当多个文件中出现了同名的const变量时，其实等同于在不同的文件中分别定义了独立的变量。

如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字。在其他文件中的声明也添加extern关键字，其指明了变量并非本文件所独有，它的定义将在别处出现。



## const的引用
可以把引用绑定到const对象上，就像绑定到其他对象上一样，我们称之为**对常量的引用（reference to const）**，简称为“常量引用”。与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象。试图让一个非常量引用指向一个常量对象会引发错误。

### 初始化和对const的引用
引用的类型必须与其所引用对象的类型一致，但是有两个例外。第一种例外情况就是在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。

当一个常量引用被绑定到另一种类型时，编译器临时创建了一个未命名的对象来暂存表达式的求值结果，这个**临时量对象（temporary）**也被简称为临时量。

### 对const的引用可能引用一个并非const的对象
常量引用仅对引用可参与的操作做出了限定，对于引用的对象本身是不是一个常量未作限定。因为对象也可能是个非常量，所以允许通过其他途径改变它的值。



## 指针和const
可以令指针指向常量，**指向常量的指针（pointer to const）**不能用于改变其所指对象的值。想要存放常量对象的地址，只能使用指向常量的指针。

指针的类型必须与其所指对象的类型一致，但是有两个例外。第一种例外情况时令一个指向常量的指针指向一个非常量对象。指向常量的指针没有规定所指的对象必须是一个常量，仅仅要求不能通过该指针改变对象的值，没有规定那个对象的值不能通过其他途径改变。

### const指针
指针是对象，允许把指针本身定为常量。**常量指针（const pointer）**必须初始化，而且一旦初始化完成，则它的值（也就是存放在指针中的那个地址）就不能再改变了。把*放在const关键字之前用以说明指针是一个常量，这样的书写形式隐含着一层意味，即不变的是指针本身的值而非所指向的那个值。

指针本身是一个常量并不意味着不能通过指针修改其所指对象的值，能否这样做完全依赖于所指对象的类型。

### 顶层const
指针本身是一个对象，它又可以指向另外一个对象。因此，指针本身是不是常量以及指针所指是不是一个常量就是两个独立的问题。用名词**顶层const（top-level const）**表示指针本身是个常量，而用名词**底层const（low-level const）**表示指针所指的对象是一个常量。

顶层const可以表示任意的对象是常量，这一点对任何数据类型都适用。底层const则与指针和引用等复合类型的基本类型部分有关。比较特殊的是，指针类型既可以是顶层const也可以是底层const，这一点和其他类型相比区别明显。

当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层const资格，或者两个对象的数据类型必须能够转换。一般来说，非常量可以转化为常量，反之则不行。



## constexpr和常量表达式
**常量表达式（const expression）**是指值不会改变并且在编译过程就能得到计算结果的表达式。显然，字面值属于常量表达式，用常量表达式初始化的const对象也是常量表达式。

一个对象（或表达式）是不是常量表达式由它的数据类型（const类型）和初始值（编译可得）共同决定。

### constexpre变量
在一个复杂的系统中，很难（几乎肯定不能）分辨一个初始值到底是不是常量表达式。

允许将变量声明为**constexpr**类型以便由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化。

允许定义一种特殊的constexpr函数，这种函数应该足够简单以使得编译时就可以计算其结果，这样就能用constexpr函数去初始化constexpr变量。

### 字面值类型
常量表达式的值需要在编译时就得到计算，因此对声明constexpr时用到的类型必须有所限制。因为这些类型一般比较简单，值也显而易见、容易得到，就把它们称为“字面值类型”（literal type）。

算术类型、引用和指针都属于字面值类型。尽管指针和引用都能定义成constexpr，但它们的初始值却受到严格限制。一个constexpr指针的初始值必须是nullptr或者0，或者是存储于某个固定地址中的对象。

函数体内定义的变量一般来说并非存放在固定地址中，因此constexpr指针不能指向这样的变量。相反，定义余所有函数体之外的对象其地址固定不变，能用来初始化constexpr指针。允许函数定义一类有效范围超出函数本身的变量，这类变量和定义在函数体之外的变量一样也有固定地址。因此，constexpr引用能绑定到这样的变量上，constexpr指针也能指向这样的变量。

### 指针和const
在constexpr声明中如果定义了一个指针，限定符constexpr仅仅对指针有效，与指针所指的对象无关：
```c++
const int *p = nullptr;      // p是一个指向整型常量的指针
constexpr int *q = nullptr;  // q是一个指向整数的常量指针
```
其中的关键在于constexpr把它所定义的对象置为了顶层const。

与其他常量指针类似，constexpr指针既可以指向常量也可以指向一个非常量。