# 复合类型
**复合类型（compound type）**是指基于其他类型定义的类型。



## 声明语句
一条声明语句由一个**基本数据类型（base type）**和紧随其后的一个**声明符（declarator）**列表组成。每个声明符命名了一个变量并指定该变量为与基本数据类型有关的某种类型。

最简单的声明符就是变量名，此时变量的类型也就是声明的基本数据类型。还可以有更复杂的声明符，它基于基本数据类型得到更复杂的类型，并把它指定给变量。



## 引用
**引用（reference）**为对象起了另外一个名字，引用类型**引用（refers to）**另外一种类型。通过将声明符写成&d的形式来定义引用类型，其中d是声明的变量名。

一般在初始化变量时，初始值会被拷贝到新建的对象中。然而定义引用时，程序把引用和它的初始值**绑定（bind）**在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。

### 引用即别名
引用并非对象，它只是为一个已经存在的对象所起的另外一个名字。定义了一个引用之后，对其进行的所有操作都是在与之绑定的对象上进行的。

为引用赋值，实际上是把值赋给了与引用绑定的对象。获取引用的值，实际上是获取了与引用绑定的对象的值。同理，以引用作为初始值，实际上是以与引用绑定的对象作为初始值。

因为引用本身不是一个对象，所以不能定义引用的引用。

### 引用的定义
允许在一条语句中定义多个引用，其中每个引用标识符都必须以符号&开头。

除了某些例外情况，其他所有引用的类型都要和与之绑定的对象严格匹配。而且，引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起。



## 指针
**指针（pointer）**是“指向（point to）”另外一种类型的复合类型。指针本身是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。指针无须在定义时赋值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。

定义指针类型的方法将声明符写成\*d的形式，其中d是变量名。如果在一条语句中定义了几个指针变量，每个变量前面都必须有符号*。

### 获取对象的地址
指针存放某个对象的地址，想要获取该地址，需要使用**取地址符（操作符&）**。

因为引用不是对象，没有实际地址，所以不能定义指向引用的指针。

除了某些例外情况，其他所有指针的类型都要和它所指向的对象严格匹配。因为在声明语句中指针的类型实际上被用于指定它所指向的类型，所以二者必须匹配。如果指针指向了一个其他类型的对象，对该对象的操作将发生错误。

### 指针值
指针的值（即地址）应属于下列4种状态之一：
1. 指向一个对象。
2. 指向紧邻对象所占空间的下一个位置。
3. 空指针，意味着指针没有指向任何对象。
4. 无效指针，也就是上述情况之外的其他值。

试图拷贝或以其他方式访问无效指针的值都将引发错误，编译器并不负责检查此类错误。访问无效指针的后果无法预计，所以程序员必须清楚任意给定的指针是否有效。

第2种和第3种指针没有指向任何对象，所以试图访问此类指针（假定的）对象的行为不被允许。如果这样做了，后果也无法预计。

### 利用指针访问对象
如果指针指向了一个对象，则允许使用**解引用符（操作符*）**来访问该对象。对指针解引用会得出所指的对象，因此如果给解引用的结果赋值，实际上也就是给指针所指的对象赋值。

### 空指针
**空指针（null pointer）**不指向任何对象，在试图使用一个指针之前代码可以首先检查它是否为空。以下列出几个生成空指针的方法：
```C++
int *p1 = nullptr;
int *p2 = 0;
// 需要首先#include cstdlib
int *p3 = NULL;
```
nullptr是一种特殊类型的字面值，它可以被转化成任意其他类型的指针。

### 赋值和指针
和其他任何变量（只要不是引用）一样，给指针赋值就是令它存放一个新的地址，从而指向一个新的对象。

有时候想搞清楚一条赋值语句到底是改变了指针的值还是改变了指针所指对象的值不太容易，最好的办法就是记住赋值永远改变的是等号左侧的对象。

### 其他指针操作
只要指针拥有一个合法值，就能将它用在条件表达式中。如果指针的值是0，条件取false；任何非0指针对应的条件值都是true。

对于两个类型相同的合法指针，可以用相等操作符（==）或不相等操作符（!=）来比较它们，比较的结果是布尔类型。如果两个指针存放的地址值相同，则它们相等；反之它们不相等。

### void*指针
**void\***是一种特殊的指针，可用于存放任意对象的地址。不能直接操作void*指针所指的对象，因为我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。

利用void*指针能做的事儿比较有限：
* 拿它和别的指针做比较
* 作为函数的输入或输出
* 赋给另一个void*指针

概括来说，以void*的视角来看内存空间也就仅仅是内存空间，没办法访问内存空间中所存的对象。



## 复合类型的声明
变量的定义包括一个基本数据类型（base type）和一组声明符。在同一条定义语句中，声明符的形式可以不同，因此可以定义出不同类型的变量。

### 定义多个变量
涉及指针或引用的声明，一般有两种写法。

第一种把类型修饰符（*或&）和变量标识符写在一起，这种形式着重强调变量具有的复合类型：
```c++
int *p1, *p2; // p1和p2都是指向int的指针 
```

第二种把类型修饰符（*或&）和类型名写在一起，并且每条语句只定义一个变量，这种形式着重强调本次声明定义了一种复合类型：
```c++
int* p1; // p1是指向int的指针
int* p2; // p2是指向int的指针
```

### 指向指针的指针
声明符中修饰符的个数并没有限制，当多个修饰符连写在一起时，按照其逻辑关系详加解释即可。

以指针为例，指针是内存中的对象，像其他对象一样也有自己的地址，因此允许把指针的地址再存放到另一个指针当中。通过\*的个数可以区分指针的级别，\*\*表示指向指针的指针，***表示指向指针的指针的指针，以此类推。（假设有二级指针）解引用指向指针的指针会得到一个指针，为了访问最原始的那个对象需要对指针的指针做两次解引用。   

### 指向指针的引用
指针是对象，所以存在对指针的引用：
```c++
int i = 42;
int *p; // p是一个int型指针
int *&r = p; // r是一个对指针p的引用

r = &i; // r引用了一个指针，因此给r赋值&i就是令p指向i
*r = 0; // 解引用r得到i，也就是p指向的对象，将i的值改为0
```
要理解r的类型到底是什么，最简单的办法是从右往左阅读r的定义。离变量名最近的符号（此例中是&r的符号&）对变量的类型有最直接的影响，因此r是一个引用。声明符的其余部分用以确定r引用的类型是什么，此例中的符号*说明r引用的是一个指针。最后，声明的基本数据类型部分指出r引用的是一个int指针。

面对一条比较复杂的指针或引用的声明语句时，从右往左阅读有助于弄清楚它的真实含义。