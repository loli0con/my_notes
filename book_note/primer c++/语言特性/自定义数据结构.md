# 自定义数据结构
从最基本的层面理解，数据结构是把一组相关的数据元素组织起来然后使用它们的策略和方法。

C++语言允许用户以类的形式自定义数据类型。



## 定义Sales_data类型
Sales_data初步定义如下：
```c++
struct Sales_data{
    std::string bookNo;
    unsigned units_sold = 0;
    double revenue = 0.0;
};
```
我们的类以关键字**struct**开始，紧跟着类名和类体（其中类体部分可以为空）。类体由花括号包围形成了一个新的作用域。类内部定义的名字必须唯一，但可以与类外部定义的名字重复。

类体右侧的表示结束的花括号必须写一个分号，这是因为类体后面可以紧跟变量名以示对该类型对象的定义，所以分号必不可少：
```c++
struct Sales_data { /* ... */ } accum, trans, *salesptr;
// 与上面一条语句等价，但可能更好一些
struct Sales_data { /* ... */ };
Sales_data accum, trans, *salesptr;
```
分号表示声明符（通常为空）的结束。一般来说，最好不要把对象的定义和类的定义放在一起。

### 类数据成员
类体定义类的**成员**。类的**数据成员（data number）**定义了类的对象的具体内容，每个对象都有自己的一份数据成员拷贝。修改一个对象的数据成员，不会影响其他的对象。

定义数据成员的方法和定义普通变量一样：首先说明一个基本类型，随后紧跟一个或者多个声明符。

可以为数据成员提供一个类内初始值（in-class initializer）。创建对象时，类内初始值将用于初始化数据成员。没有初始值的成员将被默认初始化。对类内初始值的限制：或者放在花括号里，或者放在等号右边，记住不能使用圆括号。



## 使用Sales_data类



## 头文件
尽管可以在函数体内定义类，但是这样的类毕竟受到了一些限制。所以，类一般不定义在函数体内。当在函数体外部定义时类，在各个指定的源文件中可能只有一处该类的定义。而且，如果要在不同的文件中使用同一个类，类的定义就必须保持一致。

为了确保各个文件中类的定义一致，类通常被定义在头文件中，而且类所在头文件的名字应与类的名字一样。

头文件通常包含那些只能被定义一次的类体。头文件也经常用到其他头文件的功能。这样，事实上使用Sales_data.h类的程序就会先后两次包含了string.h头文件：一次是直接包含的，另一次是随着包含Sales_data.h被隐式地包含进来的。有必要在书写头文件时做适当处理，使其遇到多次包含的情况也能安全和正常地工作。

### 预处理器概述
确保头文件多次包含仍能安全工作的常用技术是**预处理器（preprocessor）**，它由C++语言从C语言继承而来。预处理器是在编译之前执行的一段程序，可以部分地改变我们所写的程序。当预处理器看到#include标记时

C++程序还会用到的一项预处理功能是**头文件保护符（header guard）**，头文件保护符依赖预处理变量。预处理变量有两种状态：已定义和未定义。`#define`指令把一个名字设定为预处理变量，另外两个指令则分别检查某个指定的预处理变量是否已定义：`#ifdef`当且仅当变量已定义时为真，`#ifndef`当且仅当变量未定义时为真。一旦检查结果为真，则执行后续操作直到`#endif`遇到令为止。

使用这些功能就能有效地防止重复包含的发生：
```c++
#ifndef SALES_DATA_H
#define SALES_DATA_H
#include <string>
struct Sales_data{
    std::string bookNo;
    unsigned units_sold = 0;
    double revenue = 0.0;
};
#endif
```

预处理变量无视C++语言中关于作用域的规则。

整个程序中的预处理变量包括头文件保护符必须唯一，通常的做法是基于头文件中类的名字来构建保护符的名字，以确保其唯一性。为了避免与程序中的其他实体名字冲突，一般把预处理变量的名字全部大写。

头文件即使（目前还）没有被包含在任何其他头文件中，也应该设置保护符。