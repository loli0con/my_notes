# vector
标准库类型**vector**表示对象的集合，其中所有对象的类型相同。集合中的每个对象都有一个与之对应的索引，索引用于访问对象。因为vector“容纳着”其他对象，所以它也常被称作**容器（container）**。

要想使用vector，必须包含适当的头文件：
```c++
#include <vector>
using std::vector;
```

C++语言既有**类模版（class template）**，也有函数模版，其中vector是一个类模版。模版本身不是类或函数，相反可以将模版看作为编译器生成类或函数编写的一份说明。编译器根据模版创建类或函数的过程称为**实例化（instantiation）**，当使用模版时，需要指出编译器应把类或函数实例化成何种类型。

对于类模版来说，我们通过提供一些额外的信息来指定模版到底实例化成什么样的类，需要提供哪些信息由模版决定。提供信息的方式总是这样：即在模版名称后面跟一对尖括号，在括号内放在信息。

vector能容纳绝大多数类型的对象作为其元素，但是因为引用不是对象，所以不存在包含引用的vector。除此之外，其他大多数（非引用）内置类型和类类型都可以构成vector对象，甚至组成vector的元素也可以是vector。



## 定义和初始化vector对象
和任何一种类类型一样，vector模版控制着定义和初始化向量的方法，下面列出了定义vector对象的常用方法：
* `vector<T> v1`：v1是一个空vector，它潜在的元素是T类型的，执行默认初始化
* `vector<T> v2(v1)`：v2中包含有v1所有元素的副本
* `vector<T> v2 = v1`：等价于v2(v1)，v2中包含有v1所有元素的副本
* `vector<T> v3(n, val)`：v3包含了n个重复的元素，每个元素的值都是val
* `vector<T> v4(n)`：v4包含了n个重复地执行了值初始化的对象
* `vector<T> v5{a,b,c...}`：v5包含了初始值个数的元素，每个元素被赋予相应的初始值
* `vector<T> v5={a,b,c...}`：等价于v5{a,b,c...}

### 列表初始化vector对象
C++语言提供了几种不同的初始化方式。在大多数情况下这些初始化方式可以相互等价地使用，不过也并非一直如此。其一，使用拷贝初始化时（即使用=时），只能提供一个初始值；其二，如果提供的是一个类内初始值，则只能使用拷贝初始化或使用花括号的形式初始化。第三种特殊的要求是，如果提供的是初始元素值的列表，则只能把初始值都放在花括号里进行列表初始化，而不能放在圆括号里。

### 值初始化
通常情况下，可以只提供vector对象容纳的元素数量而不用略去初始值。此时库会创建一个**值初始化（value-initialized）**元素初值，并把它赋给容器中的所有元素。这个初值由vector对象中元素的类型决定。

对这种初始化的方式有两个特殊的限制：
* 其一：有些类型要求必须明确地提供初始值，如果vector对象中的元素类型不支持默认初始化，我们就必须提供初始的元素值。这种类型的对象来说，只提供元素的数量而不设定初始值无法完成初始化工作。
* 其二：如果只提供了元素的数量而没有设定初始值，只能使用直接初始化。

### 列表初始值还是元素数量
在某些情况下，初始化的真实含义依赖于传递初始值时用的是花括号还是圆括号。

如果用的是圆括号，可以说提供的值是用来构造（construct）vector对象的。如果用的是花括号，可以表述成我们想列表初始化（list initialize）该vector对象。也就是说，初始化过程尽可能把花括号内的值当城市元素初始值的列表来处理，只有在无法执行列表初始化时才会考虑其他初始化方式。

另一方面，如果初始化时使用了花括号的形式但是提供的值又不能用来列表初始化，就要考虑用这样的值来构造vector对象了。要想执行列表初始化vector对象，花括号里的值必须与元素类型相同。当编译器确认无法执行列表初始化，即使使用了花括号，但转而装而尝试用默认值初始化vector对象。



## 向vector对象中添加元素
利用vector的成员函数pusb_back可以向其中添加元素，push_back负责把一个值当成vector对象的尾元素“压到（push）”vector对象的“尾端（back）”。

C++标准要求vector应该能够在运行时高效快速地添加元素。因此既然vector对象能高效地增长，那么在定义vector对象的时候设定大小也就没什么必要了，事实上如果这么做性能可能更差。只有一种例外情况，就是所有（all）元素的值都一样。一旦元素的值有所不同，更有效的办法是先定义一个空的vector对象，再在运行时向其中添加元素值。此外，vector还提供了其他方法，允许我们进一步提升动态添加元素的性能。

如果循环体内部包含有向vector对象添加元素的语句，则不能使用范围for循环。范围for语句体内不应改变其遍历序列的大小。



## 其他vector操作
|vector支持的操作|描述|
|---|---|
|v.empty()|如果v不含有任何元素，返回真；否则返回假|
|v.size()|返回v中元素的个数|
|v.push_back(t)|向v的尾端添加一个值为t的元素|
|v[n]|返回v中第n个位置上元素的引用|
|v1 = v2|用v2中的元素拷贝替换v1中的元素|
|v1 = {a,b,c...}|用列表中元素的拷贝替换v1中的元素|
|v1 == v2<br>v1 != v2|v1和v2相等当且仅当它们的元素数量相同且对应位置的元素值都相同|
|<, <=, >, >=|顾名思义，以字典顺序进行比较|

### 范围for语句
可以使用范围for语句处理vector对象中的所有元素。当把控制变量定义成引用类型，这样就能通过控制变量给vector对象中的元素赋值，其中控制变量的类型可以由auto关键字制定。

### size
size返回vector对象中元素的个数，返回值的类型是由vector定义的size_type类型。要使用size_type，需首先制定它是由哪种类型定义的。vector对象的类型总是包含着元素的类型：
```C++
vector<int>::size_type // 正确
vector::size_type      // 错误
```

### 关系运算符
关系运算符依照字典顺序进行比较：如果两个vector对象的容量不同，但在相同位置上的元素值都一样，则元素较少的vector对象小于元素较多的vector对象；若元素的值有区别，则vector对象的大小关系由第一对相异的元素值的大小关系决定。

只有当元素的值可比较时，vector对象才能被比较。



## 计算vector内对象的索引
使用下标运算符能获得指定的元素，vector对象的下标从0开始计起，下标的类型是相应的size_type类型。只要vector对象不是一个常量，就能向下标运算符返回的元素赋值。也能通过计算得到vector内对象的索引，然后直接获取索引位置上的元素。

使用下标的时候必须清楚地知道它是否在合理范围内。



## 不能用下标形式添加元素
vector对象的下标运算符可用于访问已存在的元素，而不能用于添加元素。

试图用下标的形式去访问一个不存在的元素将引发错误，不过这种错误不会被编译器发现，而是在运行时产生一个不可预知的值。这类错误指的就是缓冲区溢出（buffer overflow），这也是导致PC及其他设备上应用程序出现安全的一个重要原因。

确保下标合法的一种有效手段就是尽可能使用范围for语句。