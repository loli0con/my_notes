# 数组
数组是存放类型相同的对象的容器，这些对象本身没有名字，需要通过其所在位置访问。数组的大小确定不变，不能随意向数组中增加元素。因为数组的大小固定，因此对某些特殊的应用来说程序的运行时性能较好，但是相应地也损失了一些灵活性。



## 定义和初始化内置数组
数组是一种复合类型。数组的声明形如a[d]，其中a是数组的名字，d是数组的维度。维度说明了数组中元素的个数，因此必须大于0。数组中元素的个数也属于数组类型的一部分，编译的时候维度应该是已知的。也就是说，维度必须是一个常量表达式。

默认情况下，数组的元素被默认初始化。和内置类型的变量一样，如果在函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值。

定义数组的时候还必须指定数组的类型，不允许用auto关键字由初始值的列表推断类型。数组的元素应为对象，因此不存在引用的数组。

### 显式初始化数组元素
可以对数组的元素进行列表初始化，此时允许忽略数组的维度。如果在声明时没有指明维度，编译器会根据初始值的数量计算并推测出来；相反，如果指明了维度，那么初始值的总数量不应该超出指定的大小。如果维度比提供的初始值数量大，则用提供的初始值初始化靠前的元素，剩下的元素被初始化成默认值。

### 字符数组的特殊性
字符数组有一种额外的初始化形式，我们可以用字符串字面值对此类数组初始化。当使用这种方式时，一定要注意字符串字面值的结尾处还有一个空字符，这个空字符也会像字符串的其他字符一样被拷贝到字符数组中去。

### 不允许拷贝和赋值
不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值。

### 理解复杂的数组声明
因为数组本身是对象，所以允许定义数组的指针及数组的引用。

```C++
int *ptrs[10];            // ptrs是含有10个整型指针的数组
int &refs[10] = /* ? */;  // 错误：不存在引用的数组
int (*Parray)[10] = &arr; // Parray指向一个含有10个整数的数组
int (&arrRef)[10] = arr;  // arrRef引用一个含有10个整数的数组
```

默认情况下，类型修饰符是从右向左依次绑定。但是对于Parray来说，从从右向左理解就太不合理了。因为数组的维度是紧跟着被声明的名字的，所以就数组而言，由内向外阅读要比从右向左好多了。由内向外的顺序可帮助我们更好地Parray的含义：首先是圆括号括起来的部分，*Parray意味着Parray是个指针，接下来观察右边，可知道Parray是个指向大小为10的数组的指针，最后观察左边，知道数组中的元素是int。这样最终的含义就明白无误了，Parray是一个指针，它指向一个int数组，数组中包含10个元素。同理，(&arrRef)表示arrRef是一个引用，它引用的对象是一个大小为10的数组，数组中元素的类型是int。

当然，对修饰符的数量并没有特殊限制：
```C++
int *(&arry)[10] = ptrs; // arry是数组的引用，该数组含有10个整型指针
```

要理解数组声明的含义，最好的办法是从数组的名字开始按照由内向外的顺序阅读。

### 访问数组元素
数组的元素能使用范围for语句或下标运算符来访问。数组的索引从0开始，以一个包含10个元素的数组为例，它的索引从0到9，而非从1到10。

在使用数组下标的时候，通常将其定义为size_t类型。size_t是一种机器相关的无符号类型，它被设计得足够大以便能表示内存中任意对象的大小。在sctddef头文件中定义了size_t类型，这个文件是C标准库stddef.h头文件的C++语言版本。

访问数组的下标运算符是由C++语言直接定义的，这个运算符能用在数组类型的运算对象上。而由库模版vector定义的下标运算符，只能用于vector类型的运算对象。

当需要遍历数组的所有元素时，最好的办法是使用范围for语句。因为维度是数组类型的一部分，所以系统知道数组中有多少个元素，使用范围for语句可以减轻人为控制遍历过程的负担。

### 检查下标的值
数组的下标是否在合理范围之内由程序员负责检查，所谓合理就是说下标应该大于等于0而小于数组的大小。



## 指针和数组
在C++语言中，指针和数组有非常紧密的关系，使用数组的时候编译器一般会把它转换成指针。

通常情况下，使用取地址符来获取指向某个对象的指针，取地址符可以用于任何对象。数组的元素也是对象，对数组使用下标运算符得到该数组指定位置的元素。因此像其他对象一样，对数组的元素使用取地址符就能得到该元素的指针：
```C++
string nums[] = {"one", "two", "three"}; // 数组的元素是string对象
string *p = &nums[0];                    // p指向nums的第一个元素
```

然而，数组还有一个特性：在很多用到数组名字的地方，编译器都会自动地将其替换为一个指向数组首元素的指针：
```C++
string *p2 = nums; // 等价于p2 = &nums[0]
```
在大多数表达式中，使用数组类型的对象其实是使用一个指向该数组首元素的指针。

由上可知，在一些情况下数组的操作实际上是指针的操作，这一结论有很多隐含的意思。其中一层意思是当使用数组作为一个auto变量的初始值时，推断得到的类型是指针而非数组：
```C++
int ia[] = {0,1,2,3,4,5,6,7,8,9}; // ia是一个含有10个整数的数组
auto ia2(ia);   // ia2是一个整型指针，指向ia的第一个元素
ia2 = 42;       // 错误：ia2是一个指针，不能用int值给指针赋值
```
尽管ia是由10个整数构成的数组，但当使用ia作为初始值时，编译器实际执行的初始化过程类似于下面的形式：
```C++
auto ia2(&ia[0]); // 显然ia2的类型是int*
```
必须指出的是，当使用decltype关键字时，上述转换不会发生，decltype(ia)返回的类型是由10个整数构成的数组：
```C++
// ia3是一个含有0个整数的数组
decltype(ia) ia3 = {0,1,2,3,4,5,6,7,8,9};
ia3 = p;     // 错误：不能用整型指针给数组赋值
ia3[4] = i;  // 正确：把i的值赋给ia3的一个元素
```

### 指针也是迭代器
指向数组元素的指针拥有更多功能，vector和string的迭代器支持的运算，数组的指针全都支持。

获取尾后指针要用到数组的另外一个特殊性质，我们可以设法获取数组尾元素之后的那个并不存在的元素的地址：
```C++
int *e = &arr[10]; // 指向arr尾元素的下一位置的指针
```
这里使用下标运算符索引了一个并不存在的元素，arr有10个元素，尾元素所在位置的索引是9，接下来那个不存在的元素唯一的用处就是提供其地址用于初始化e。就像尾后迭代器一样，尾后指针也不指向具体的元素。因此，不能对尾后指针执行解引用或递增的操作。

### 标准库函数begin和end
尽管能计算得到尾后指针，但这种做法极易出错。为了让指针的使用更简单、更安全，C++提供了两个名为begin和end的函数。这两个函数与容器中的两个同名成员功能类似，不过数组毕竟不是类类型，因此这两个函数不是成员函数。正确的使用形式是将数组作为它们的参数：
```C++
int ia[] = {0,1,2,3,4,5,6,7,8,9}; // ia是一个含有10个整数的数组
int *beg = begin(ia);        // 指向ia首元素的指针
int *last = end(ia);         // 指向arr尾元素的下一位置的指针
```
begin函数返回指向ia首元素的指针，end函数返回指向ia尾元素下一位置的指针，这两个函数定义在iterator头文件中。

使用begin和end可以很容易地写出一个循环并处理数组中的元素：
```C++
// pbeg指向arr的首元素，pend指向arr尾元素的下一位置
int *pbeg = begin(arr), *pend = end(arr);
// 寻找第一个负值元素，如果已经检查完全部元素则结束循环
while (pbeg != pend && *pbeg >= 0)
    ++pbeg;
```

### 指针运算
指向元素的指针可以指向包括解引用、递增、比较、与整数相加、两个指针相减等运算。这些运算，用在指针和用在迭代器上意义完全一致。

给（从）一个指针加上（减去）某整数值，结果仍是指针。新指针指向的元素与原来的指针相比前进了（后退了）该整数值个位置。给指针加上一个整数，得到的新指针仍需指向同一数组的其他元素，或者指向同一数组的尾元素的下一位置。如果计算所得的指针超出了范围就将产生错误，而且这种错误编译器一般发现不了。

和迭代器一样，两个指针相减的结果是它们之间的距离。参与运算的两个指针必须指向同一个数组当中的元素。两个指针相减的结果的类型是一种名为ptrdiff_t的标准库类型，和size_t一样，ptrdiff_t也是一种定义在cstddef头文件的机器相关的类型。因为差值可能为负，所以ptrdiff_t是一种带符号类型。

只要两个指针指向同一数组的元素，或者指向该数组的尾元素的下一位置，就能利用关系运算符对其进行比较。如果两个指针分别指向不相关的对象，则不能比较它们。

尽管作用可能不是特别明显，但必须说明的是，上述指针运算同样适用于空指针和所指对象并非数组的指针。在后一种情况下，两个指针必须指向同一个对象或该对象的下一位置。如果p是空指针，允许给p加上或减去一个值为0的整型常量表达式。两个空指针也允许彼此相减，结果当然是0。

### 解引用和指针运算的交互
指针加上一个整数所得的结果还是一个指针，假设结果指针指向了一个元素，则允许解引用该结果指针。如果表达式含有解引用运算符和点运算符，最好在必要的地方加上圆括号。

### 下标和指针
在很多情况下使用数组的名字其实用的是一个指向数组首元素的指针。一个典型的例子是当对数组使用下标运算符时，编译器会自动执行上述转换操作。给定
```C++
int ia = {0,2,4,6,8}; // 含有5个整数的数组
```
此时，ia[0]是一个使用了数组名字的表达式，对数组执行下标运算其实是对指向数组元素的指针执行下标运算：
```C++
int i = ia[2];  // ia转换成指向数组首元素的指针
                // ia[2]得到(ia + 2)所指的元素
int *p = ia;    // p指向ia的首元素
i = *(p + 2);   // 等价于i = ia[2]
```
只要指针指向的是数组中的元素（或者数组中尾元素的下一位置），都可以执行下标运算：
```C++
int *p = &ia[2];  // p指向索引为2的元素
int j = p[1];     // p[1]等价于*(p + 1)，就是ia[3]表示的那个元素
int k = p[-2];    // p[-2]就是ia[0]表示的那个元素
```
标准库类型（string和vector）限定使用的下标必须是无符号类型，而内置的下标运算无此要求。内置的下标运算符可以处理负值，当然，结果地址必须指向原来的指针所指同一数组中的元素（或是同一数组尾元素的下一位置）。



## C风格字符串
尽管C++支持C风格字符串，但在C++程序中最好还是不要使用它们。

字符串字面值是一种通用结构的实例，这种结构即是C++由C继承而来的**C风格字符串（C-style character string）**。C风格字符串不是一种类型，而是为了表达和使用字符串而形成的一种约定俗成的写法。按此习惯书写的字符串存放在字符数组中并以**空字符结束（null terminated）**。以空字符结束的意思是在字符串最后一个字符后面跟着一个空字符（'\0'）。一般利用指针来操作这些字符串。

### C标准String函数
C语言标准库提供了一组函数，这些函数可用于操作C风格字符串，它们定义在cstring头文件中，cstring是C语言头文件string.h的C++版本。

|C风格字符串的函数|解释|
|---|---|
|strlen(p)|返回p的长度，空字符不计算在内|
|strcmp(p1, p2)|比较p1和p2的相等性。如果p1==p2，返回0；如果p1>p2，返回一个正值；如果p1<p2，返回一个负值|
|strcat(p1, p2)|将p2附加到p1之后，返回p1|
|strcpy(p1, p2)|将p2拷贝给p1，返回p1|

传入此类函数的指针必须指向以空字符作为结束的数组。如果传入的字符数组不是以空字符作为结束的，将产生未定义的结果。函数将有可能沿着字符数组在内存中的位置不断地向前寻找，直到遇到空字符才停下来。

### 目标字符串的大小由调用者制指定
连接或者拷贝C风格字符串需要使用strcat函数和strcpy函数。要想使用这两个函数，必需提供一个用于存放结果字符串的数组，该数组必须足够大以便容纳下结果字符串及末尾的空字符。



## 与旧代码的接口
现代的C++程序不得不与那些充满了数组和/或C风格字符串的代码衔接，为了使这一工作简单易行，C++专门提供了一组功能。

### 混用string对象和C风格字符串
任何出现字符串字面值的地方都可以用以空字符结束的字符数组来替代：
* 允许使用以空字符结束的字符数组来初始化string对象或为string对象赋值。
* 在string对象的加法运算中允许使用以空字符结束的字符数组作为其中一个运算对象（不能两个运算对象都是）；在string对象的复合赋值运算中允许使用以空字符结束的字符数组作为右侧的运算对象。

上述性质反过来就不成立了：如果程序的某处需要一个C风格字符串，无法直接用string对象来代替它。例如，不能用string对象直接初始化指向字符的指针。为了完成该功能，string专门提供了一个名为c_str的成员函数：
```C++
char *str = s; // 错误：不能用string对象初始化char*
const char *str = s.c_str(); // 正确
```
顾名思义，c_str函数的返回值是一个C风格的字符串。也就是说，函数的返回结果是一个指针，该指针指向一个以空字符结束的字符数组，而这个数组所存的数据恰好与那个string对象一样。结果指针的类型是const char*，从而确保了我们不会改变字符数组的内容。

我们无法保证c_str函数返回的数组一直有效，事实上，如果后续的操作改变了s的值就可能让之前返回的数组失去效用。如果执行完c_str函数后程序想一直都能使用其返回的数组，最好将该数组重新拷贝一份。

### 使用数组初始化vector对象
允许使用数组来初始化vector对象，要实现这一目的，只需指明要拷贝区域的首元素地址和尾后地址就可以了：
```C++
int int_arr[] = {0, 1, 2, 3, 4, 5};
// ivec有6个元素，分别是int_arr中对应元素的副本
vector<int> ivec(begin(int_arr), end(int_arr));
```
用于初始化vector对象的值也可能仅是数组的一部分：
```C++
// 拷贝三个元素：int_arr[1]、int_arr[2]、int_arr[3]
vector<int> subVec(int_arr + 1, int_arr + 4);
```



## 多维数组
严格来说，C++语言中没有多维数组，通常所说的多维数组其实是数组的数组。

当一个数组的元素仍是数组时，通常使用两个维度来定义它：一个维度表示数组本身大小，另一个维度表示其元素（也是数组）的大小。

实际上，定义数组时对下标运算符的数量并没有限制，因此只要愿意就可以定义这样一个数组：它的元素还是数组，下一级数组的元素还是数组，再下一级数组的元素还是数组，以此类推。

对于二维数组来说，常把第一个维度称作行，第二个维度称作列。

### 多维数组的初始化
允许使用花括号括起来的一组值初始化多维数组，这点和普通的数组一样。下面初始化形式中，多维数组的每一行分别用花括号括了起来：
```C++
int ia[3][4] = {   // 三个元素，每个元素都是大小为4的数组
    {0, 1, 2, 3},  // 第1行的初始值
    {4, 5, 6, 7},  // 第2行的初始值
    {8, 9, 10, 11} // 第3行的初始值
}
```
其中内层嵌套着的花括号并非必需的，例如下面的初始化语句，形式上更为简洁，完成的功能和上面的这段代码完全一样：
```C++
// 没有标识每行的花括号，与之前的初始化语句是等价的
int ia[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11};
```

类似于一维数组，在初始化多维数组时也并非所有元素都必须包含在初始化列表之内。如果仅仅想初始化每行的第一个元素，通过如下的语句即可：
```C++
// 显式地初始化每行的首元素，其他未列出的元素执行默认初始化
int ia[3][4] = {{ 0 }, { 4 }, { 8 }};
```

### 多维数组的下标引用
可以使用下标运算符来访问多维数组的元素，此时数组的每个维度对应一个下标运算符。

如果表达式含有的下标运算符数量和数组的维度一样多，该表达式的结果将是给定类型的元素；反之如果表达式含有的下标运算符数量比数组的维度小，则表达式的结果将是给定索引处的一个内层数组。

### 使用范围for语句处理多维数组
要使用范围for语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。如果使用了auto类型声明符来定义控制变量，要避免数组自动被转化为指针。

### 指针和多维数组
当程序使用多维数组的名字时，也会自动将其转换成指向数组首元素的指针。

因为多维数组实际上是数组的数组，所以由多维数组名转换得来的指针实际上是指向第一层数组的指针：
```C++
int ia[3][4];      // 大小为3的数组，每个元素是含有4个整数的数组
int (*p)[4] = ia;  // p指向含有4个整数的数组
p = &ia[2];        // p指向ia的尾元素
```