# 范式

## 简介
按照经典教材——王珊的《数据库系统概述》中的定义，范式是“符合某一种级别的关系模式的集合，表示一个关系内部各属性之间的联系的合理化程度”。

**在关系型数据库中，关于数据表设计的基本原则/规则就称为范式**。可以理解为，一张数据表的设计结构需满足的某种设计标准的**级别**。要想设计一个结构合理的关系型数据库，必须满足一定的范式。

范式来自英文**Normal Form**，简称**NF**。范式是关系数据库理论的基础，也是我们在设计数据库结构过程中要遵循的的**规则**和**指导方法**。

## 六种常见范式
目前关系型数据库有六种常见范式，按照范式级别，从低到高分别是：
* 第一范式（1NF）
* 第二范式（2NF）
* 第三范式（3NF）
* 巴斯-科德范式（BCNF）
* 第四范式（4NF）
* 第五范式（5NF，又称完美范式）

数据库的范式设计越高阶，冗余度就越低，同时高阶的范式一定符合低阶范式的要求，满足最低要求的范式是第一范式（1NF）。在第一范式的基础上进一步满足更多规范要求的称为第二范式（2NF），其余范式以此类推。

一般来说，在关系型数据库设计中，最高也就遵循到**BCNF**，普遍还是**3NF**。但也不绝对，有时候为了提高某些查询性能，我们还需要破坏范式规则，也就是**反规范化**。

## 键和相关属性的概念
范式的定义会使用到主键和候选键，数据库中键（Key）由一个或者多个属性组成。数据表中常用的几种键和属性的定义：
* **超键**：能够唯一标识元组的属性集叫做超键。
* **候选键**：如果超键不包括多余的属性，那么这个超键就是候选键。
* **主键**：用户可以从候选键中选择一个作为主键。
* **外键**：如果数据表R1中的某属性集不是R1的主键，而是另一个数据表R2的主键，那么这个属性集就是数据表R1的外键。
* **主属性**：包含在任一候选键中的属性称为主属性。
* **非主属性**：与主属性相对，指的是不包含在任何一个候选键中的属性。

通常，我们也将候选键称之为“**码**”，把主键也称为“**主码**”。因为键可能是由多个属性组成的，针对单个属性，我们还可以用主属性和非主属性来进行区分。

## 优点和缺点
* 范式的优点：数据的标准化有助于消除数据库中的**数据冗余**，第三范式（3NF）通常被认为在性能、拓展性和数据完整性方面达到了最好的平衡。
* 范式的缺点：范式的使用，可能**降低查询的效率**。因为范式等级越高，设计出来的数据表就越多、越精细，数据的冗余度就越低，进行数据查询的时候就可能需要**关联多张表**，这不但代价高昂，也可能使一些**索引策略无效**。

范式只是提出了设计的标准，实际设计数据表时，未必一定要符合这些标准。开发中，我们会出现为了性能和读取效率违反范式化的原则，通过**增加少量的冗余**或重复的数据来提供数据库的**读性能**，减少关联查询，join表的次数，实现**空间换取时间**的目的。因此在实际设计的过程中要理论结合实际，灵活运用。

## 第一范式：每个属性都不可再分
第一范式主要是确保数据表中每个字段的值必须具备**原子性**，也就是说数据表中每个字段的值为**不可再次拆分**的最小数据单元。实际上第一范式是所有关系型数据库的最基本要求。

## 第二范式：在1NF的基础上，消除了非主属性对于码的部分函数依赖
第二范式要求，在满足第一范式的基础上，还要满足数据表里的每一条数据记录，都是可唯一标识的。而且suo y欧非主键字段，都必须完全依赖主键，不能只依赖主键的一部分。如果知道主键的所有属性的值，就可以检索到任何元组（行）的任何属性值。（要求中的主键，其实可以拓展替换为候选键。）

### 函数依赖
**若在一张表中，在属性（或属性组）X的值确定的情况下，必定能确定属性Y的值，那么就可以说Y函数依赖于X，写作`X->Y`**。也就是说，在数据表中，不存在任意两条记录，它们在X属性（或属性组）上的值相同，而在Y属性上的值不同。这也就是“函数依赖”的名字由来，类似于函数关系y=f(x)，在x的值确定的情况下，y的值一定也是确定的。

从“函数依赖”这个概念展开，还会有三个概念：
* 完全函数依赖
* 部分函数依赖
* 传递函数依赖

#### 完全函数依赖
在一张表中，若`X->Y`，切对X的任何一个真子集（假如属性组X包含超过一个属性的话），`X'->Y`不成立，那我们称Y对于X**完全函数依赖**，记作：![范式+20240319145804](https://raw.githubusercontent.com/loli0con/picgo/master/images/范式+20240319145804.png+2024-03-19-14-58-05)

#### 部分函数依赖
加入Y函数依赖于X，但同时Y并不完全函数依赖于X，那么我们就称Y部分函数依赖于X，记作：![范式+20240319150010](https://raw.githubusercontent.com/loli0con/picgo/master/images/范式+20240319150010.png+2024-03-19-15-00-10)

#### 传递函数依赖
假如Z函数依赖于Y，且Y函数依赖于X（严格来说还有一个X不包含于Y，且Y不函数依赖于Z的前提条件），那么我们就称Z传递函数依赖于X，记作：![范式+20240319150250](https://raw.githubusercontent.com/loli0con/picgo/master/images/范式+20240319150250.png+2024-03-19-15-02-51)

### 码
设K为某表中的一个属性或属性组，若除K之外的所有属性都**完全函数依赖**于K，那么我们称K为**候选码**，简称为**码**。在实际中我们通常可以理解为：**假如当K确定的情况下，该表除K之外的所有属性的值也就随之确定，那么K就是码**。一张表中可以有超过一个码。（实际应用中为了方便，通常选择其中的一个码作为**主码**）。

## 第三范式：在2NF的基础之上，消除了非主属性对于码的传递函数依赖
第三范式是在第二范式的基础上，确保数据表中的每一个非主键字段都和主键字段直接相关，也就是说，**要求数据表中的所有非主键字段不能依赖于其他非主键字段**。即不能存在非主属性A依赖于非主属性B，非属性B依赖于主键C，也即不能存在“A->B->C”的决定关系。通俗地讲，该规则的意思是所有**非主键属性**之间不能有依赖关系，必须**相互独立**。这里的主键可以拓展为候选键。

## BCNF范式：在3NF的基础上消除主属性对于码的部分与传递函数依赖
人们在3NF的基础上进行了改进，提出了**巴斯范式（BCNF）**，也叫做**巴斯-科德范式（Boyce-Codd Normal Form）**。BCNF被认为没有新的设计规范加入，只是对第三范式中设计规范的要求更强，使得数据库冗余更小。所以，称为是**修正的第三范式**，或**扩充的第三范式**，而不被称为第四范式。

若一个关系达到了第三范式，并且它只有一个候选键，或者它的每个候选键都是单属性，则该关系自然达到了BC范式。

一般来说，一个数据库设计符合3NF或BCNF就可以了。


## 反范式

### 概述
有的时候不能简单按照规范的要求设计数据表，因为有的数据看似冗余，其实对业务来说十分重要。这个时候，我们就要遵循**业务优先**的原则，首先满足业务需求，再尽量减少冗余。

如果数据库中的数据量比较大，系统的UV和PV访问频次比较高，则完全按照MySQL的三大范式设计数据表，读数据时会产生大量的关联查询，在一定程度上会影响数据库的读性能。如果我们相对查询效率进行优化，**反范式优化**也是一种优化思路。此时，可以在数据表中**增加冗余字段**来提高数据库的读性能。

1. 为满足某种商业目标，数据库性能比规范化数据库更重要
2. 在数据规范化的同时，要综合考虑数据库的性能
3. 通过在给定的表中添加额外的字段，以大量减少需要从中搜索信息所需的时间
4. 通过在给定的表中插入计算列，以方便查询

### 新问题
反范式可以通过空间换时间，提升查询的效率，但是反范式也会带来一些新问题：
* 存 **空间变大**了
* 一个表中字段做了修改，另一个表中冗余的字段也需要做同步修改，否则**数据不一致**
* 若采用存储过程来支持数据的更新、删除等额外操作，如果更新频繁，会非常**消耗系统资源**
* 在**数据量小**的情况下，反范式不能体现性能的优势，可能还会让数据库的设计更加**复杂**

### 适用场景
当冗余信息有价值或者能**大幅度提高查询效率**的时候，我们才会采取反范式的优化。

#### 增加冗余字段的建议
增加冗余字段一定要符合如下两个条件。只有满足这两个条件，才可以考虑增加冗余字段：
1. 这个冗余字段**不需要经常进行修改**
2. 这个冗余字段**查询的时候不可或缺**

#### 历史快照、历史数据的需要
在现实生活中，我们经常需要一些冗余信息，比如订单中的收货人信息，包括姓名、电话和地址等。每次发生的**订单收货信息**都属于**历史快照**，需要进行保存，但用户可以随时修改自己的信息，这时保存这些冗余信息是非常有必要的。

反范式优化也常用在**数据仓库**的设计中，因为数据仓库通常**存储历史数据**，对增删改的实时性要求不强，对历史数据的分析需求强。这时适当允许数据的冗余度，更方便进行数据分析。