# 数据库缓冲池(Buffer Pool)
InnoDB存储引擎是以**页**为单位来管理存储空间的，我们进行的增删改查操作其实本质上都是在访问页面（包括读页面、写页面、创建新页面等操作）。

磁盘I/O需要消耗的时间很多，而在内存中进行操作，效率则会高很多，为了能让数据表或者索引中的数据随时被我们所用，DBMS会申请占用内存为数据缓冲池，在真正访问页面之前，需要把在磁盘上的页缓存到内存中的Buffer Pool之后才可以访问。

这样做的好处是可以让磁盘活动最小化，从而减少与磁盘直接进行I/O的时间。要知道，这种策略对提升SQL语句的查询性能来说至关重要。如果索引的数据在缓冲池里，那么访问的成本就会降低很多。

**引擎层的<u>缓冲池</u>**  不是  **服务层的<u>查询缓存</u>**。

## 缓冲池的内容
![数据缓冲池+20240228205858](https://raw.githubusercontent.com/loli0con/picgo/master/images/数据缓冲池+20240228205858.png+2024-02-28-20-58-59)

在InnoDB存储引擎中有一部分数据会放到内存中，缓冲池则占了这部分内存的大部分，它用来存储各种数据的缓存：数据页、索引页、插入缓存、锁信息、自适应Hash和数据字典信息等。

## 缓冲池的重要性
对于使用InnoDB作为存储引擎的表来说，不管是用于存储用户数据的索引（包括聚簇索引和二级索引），还是各种系统数据，都是以**页**的形式存放在**表空间**中，而表空间是InnoDB对文件系统上一个或几个实际文件的抽象，也就是说数据说到底还是存储在磁盘上。

缓冲池可以帮助我们消除CPU和磁盘之间的鸿沟。InnoDB存储引擎在处理客户端的请求时，当需要访问某个页的数据时，就会把完整的页的数据全部加载到内存中。在进行完读写访问后并不着急把该页对应的内存空间释放掉，而是将其缓存起来，这样将来有请求再次访问该页面时，就可以省去磁盘IO的开销了。

## 缓存原则
* 位置：位置决定效率，提供缓冲池就是为了在内存中可以直接访问数据。
* 频次：频次决定优先级顺序，因为缓冲池的大小时有限的，无法将所有数据都在加载到缓冲池里，这时就会涉及到优先级顺序，会优先对使用频次高的热数据进行加载。

## 缓冲池的预读特性
进行数据读取的时候存在一个“局部性原理”，也就是说我们是用了一些数据，大概率还会使用它周围的一些数据，因此采用“预读”的机制提前加载，可以减少未来可能的磁盘I/O操作。

## 数据读写流程
缓冲池管理器会尽量将经常使用的数据保存起来，在数据库进行页面读操作的时候，首先会判断该页面是否在缓冲池中，如果存在就直接读取，如果不存在，就会通过内存或磁盘将页面存放到缓冲池中再进行读取。

缓存在数据库中的结构和作用如下图所示：
![数据缓冲池+20240229115535](https://raw.githubusercontent.com/loli0con/picgo/master/images/数据缓冲池+20240229115535.png+2024-02-29-11-55-37)

当我们对数据库中的记录进行修改的时候，首先会修改缓冲池中页里面的记录信息，然后数据库会以一定的频率刷新到磁盘上，而并非每次发生更新操作都立刻进行磁盘回写。缓冲池会采用一种叫做**checkpoint**的机制将数据回写到磁盘上，这样做的好处就是提升了数据库的整体性能。

当缓冲池不够用时，需要释放掉一些不常用的页，此时就可以强行采用**checkpoint**的方式，将不常用的脏页回写到磁盘上，然后再从缓冲池中将这些页释放掉。这里的脏页（dirty page）指的是缓冲池中被修改过的页，与磁盘上的数据页不一致。

## 查看/设置缓冲池的大小
如果使用的是InnoDB存储引擎，可以通过查看`innodb_buffer_pool_size`变量来查看缓冲池的大小。命令如下:
```MySQL
show variables like 'innodb_buffer_pool_size';
```

![数据缓冲池+20240229120507](https://raw.githubusercontent.com/loli0con/picgo/master/images/数据缓冲池+20240229120507.png+2024-02-29-12-05-08)

此时InnoDB的缓冲池大小只有134217728/1024/1024=128MB。我们可以临时修改缓冲池大小，比如改为256MB，方法如下:
```MySQL
set global innodb_buffer_pool_size = 268435456;
```

通过配置文件修改缓冲池大小：
```conf
[server]
innodb_buffer_pool_size = 268435456
```

## 多个Buffer Pool实例
Buffer Pool本质是InnoDB向操作系统申请的一块连续的内存空间，在多线程环境下，访问Buffer Pool中的数据都需要加锁处理。在Buffer Pool特别大而且多线程并发访问特别高的情况下，单一的Buffer Pool可能会影响请求的处理速度。所以在Buffer Pool特别大的时候，我们可以把它们拆分成若干个小的Buffer Pool，每个Buffer一个实例，它们都是独立的，独立的去申请内存空间，独立的管理各种链表。所以在多线程并发访问时并不会相互影响，从而提高并发处理能力。

我们可以在服务器启动的时候通过设置`innodb_buffer_pool_instances`的值来修改Buffer Pool实例的个数：
```conf
[server]
innodb_buffer_pool_instances = 2
```
这样就表明我们要创建2个Buffer Pool实例。 

查看缓冲池的个数，使用命令：
```SQL
show variables like 'innodb_buffer_pool_instances';
```

每个Buffer Pool实例实际占的内存空间：
```
innodb_buffer_pool_size/innodb_buffer_pool_instances
```
也就是总共的大小除以实例的个数，结果就是每个Buffer Pool实例占用的大小。

Buffer Pool实例并非越多越好，分别管理各个Buffer Pool也是需要性能开销的。InnoDB规定：当`innodb_buffer_pool_size`的值小于**1G**的时候设置多个实例是无效的，InnoDB会默认把`innodb_buffer_pool_instances`的值修改为**1**。建议在Buffer Pool大于等于**1G**的时候设置多个Buffer Pool实例。