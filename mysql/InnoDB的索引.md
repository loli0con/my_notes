# InnoDB的索引

## 索引的推演

### 表
```SQL
CREATE TABLE index_demo(
    c1 INT,
    c2 INT,
    c3 CHAR(1),
    PRIMARY KEY(c1)
) ROW_FORMAT = Compact;
```

### 行
这个新建的index_demo表中有2个INT类型的列，1个CHAR(1)类型的列，而且我们规定了c1列为主键，这个表使用Compact行格式来实际存储记录的。这里我们简化了index_demo表的行格式示意图：
![B-Tree+20240306132021](https://raw.githubusercontent.com/loli0con/picgo/master/images/B-Tree+20240306132021.png+2024-03-06-13-20-22)

### 页
InnoDB存储引擎是以页为单位来管理存储空间的，我们进行的增删改查操作其实本质上都是在访问页面(包括读页面、写页面、创建新页面等操作)。把一些记录放到页里的示意图：
![B-Tree+20240306131611](https://raw.githubusercontent.com/loli0con/picgo/master/images/B-Tree+20240306131611.png+2024-03-06-13-16-12)

### B+Tree
![InnoDB的索引+20250209011929](https://raw.githubusercontent.com/loli0con/picgo/master/images/InnoDB的索引+20250209011929.png+2025-02-09-01-19-29)

不论是存放**用户记录**的数据页，还是存放**目录项记录**的数据页，我们都把它们存放到B+树这个数据结构中了，所以我们也称这些数据页为**节点**。从图中可以看出，我们的实际用户记录其实都存放在B+树的最底层的节点上，这些节点也被称为**叶子节点**，其余用来存放**目录项**的节点称为**非叶子节点**或者**内节点**，其中B+树最上边的那个节点也称为**根节点**。

一个B+树的节点其实可以分成好多层，规定最下边的那层，也就是存放我们用户记录的那层为第**0**层，之后依次往上加。一般情况下，我们用到的B+树都不会超过4层，那我们通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和1个用户记录页），又因为在每个页面内有所谓的**Page Directory**（页目录），所以在页面内也可以通过二分法实现快速定位记录。

## 常见索引概念
索引按照物理实现方式，索引可以分为2种：聚簇（聚集）和非聚簇（非聚集）索引。我们也把非聚集索引称为二级索引或者辅助索引。

### 聚簇索引
聚簇索引并不是一种单独的索引类型，而是**一种数据存储方式**（所用的用户记录都存储在了叶子节点），也就是所谓的“索引即数据，数据即索引”。

> 术语“聚簇”表示数据行和相邻的键值聚簇地存储在一起。

#### 特点
1. 使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：
   * **页内**的记录是按照主键的大小顺序排成一个**单向链表**。
   * 各个存放**用户记录的页**也是根据页中用户记录的主键大小顺序排成一个**双向链表**。
   * 存放大小**目录项记录的页**分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键顺序排成一个**双向链表**。
2. B+树的**叶子节点**存储的是完整的用户记录。所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。

我们把具有这两种特点的B+树称为**聚簇索引**，所有完整的用户记录都存放在这个**聚簇索引**的叶子节点处。这种聚簇索引并不需要我们在MySQL语句中显式地使用**INDEX**语句去创建，**InnoDB**存储引擎会**自动**为我们创建聚簇索引。

#### 优点
* **数据访问更快**，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快。
* 聚簇索引对于主键的**排序查找**和**范围查找**速度非常快。
* 按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以**避免了大量的IO操作**。

#### 缺点
* **插入速度严重依赖于插入顺序**，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个**自增的ID列为主键**。
* **更新主键的代价很高**，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义**主键为不可更新**。
* **二级索引访问需要两次索引查找**，第一次找到主键值，第二次根据主键值找到行数据。

#### 限制
* 对于MySQL数据库目前只有InnoDB数据引擎支持聚簇索引，而MyISAM并不支持聚簇索引。
* 由于数据物理存储排序方式只能有一种，所以每个MySQL的**表只能有一个聚簇索引**。一般情况下就是该表的主键。
* 如果没有定义主键，InnoDB会选择**非空的唯一索引**代替。如果没有这样的索引，InnoDB会隐式地定义一个主键来作为聚簇索引。
* 为了充分利用聚簇索引的聚簇特性，所以InnoDB表的主键列尽量**选用有序的顺序ID**，而不建议用无序的ID，比如UUID、MD5、HASH、字符串列作为主键无法保证数据的顺序增长。

### 二级索引（辅助索引、非聚簇索引）
**聚簇索引**只能在搜索条件是**主键值**时才能发挥作用。如果想以别的列作为搜索条件，可以再建一棵B+树，比方说用c2列的大小作为数据页中记录的排序规则，效果如下图所示：
![InnoDB的索引+20240306135145](https://raw.githubusercontent.com/loli0con/picgo/master/images/InnoDB的索引+20240306135145.png+2024-03-06-13-51-46)

这个B+树与上边介绍的聚簇索引有几处不同：
* 使用记录c2列的大小进行记录和页的排序，这包括三个方面的含义：
  * 页内的记录是按照c2列的大小顺序排成一个**单向链表**。
  * 各个存放**用户记录的页**也是根据页中记录的c2列大小顺序排成一个**双向链表**。
  * 存放**目录项记录的页**分为不同的层次，在同一层次中的页也是根据页中目录项记录的c2列大小顺序排成一个**双向链表**。
* B+树的叶子节点存储的并不是完整的用户记录，而只是**c2列+主键**这两个列的值。
* 目录项记录中不再是**主键+页号**的搭配，而变成了**c2列+页号**的搭配。

所以如果我们现在想通过c2列的值查找某些记录的话就可以使用我们刚刚建好的这个B+树了。

因为这种按照**非主键列**建立的B+树需要一次回表操作才可以定位到完整的用户记录，所以这种B+树也被称为**二级索引（secondary index）**，或者**辅助索引**。非聚簇索引的存在不影响数据在聚簇索引中的组织，所以一张表可以有多个非聚簇索引。

#### 回表
我们根据这个以c2列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根据c2列的值查找到完整的用户记录的话，仍然需要到**聚簇索引**中再查一遍，这个过程称为**回表**。也就是根据c2列的值查询一条完整的用户记录需要使用到**2**棵B+树！

#### 区别
1. 聚簇索引的**叶子节点**存储的就是我们的**数据记录**，非聚簇索引的叶子节点存储的是**数据位置**。非聚簇索引不会影响数据表的物理存储顺序。
2. 一个表**只能有一个聚簇索引**，因为只能有一种排序存储的方式，但可以有**多个非聚簇索引**，也就是多个索引目录提供数据索引。
3. 使用聚簇索引的时候，数据**查询效率高**，但如果对数据进行插入、删除、更新等操作，效率会比非聚簇索引低。

### 联合索引
我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让B+树按照**c2和c3列**的大小进行排序，这个包含两层含义：
1. 先把各个记录和页按照c2列进行排序。
2. 在记录的c2列相同的情况下，采用c3列进行排序。

为c2和c3列建立的索引的示意图如下：
![InnoDB的索引+20240306140432](https://raw.githubusercontent.com/loli0con/picgo/master/images/InnoDB的索引+20240306140432.png+2024-03-06-14-04-34)
如图所示，我们需要注意以下几点：
* 每条**目录项记录**都由**c2、c3、页号**这三部分组成，各条记录先按照c2列的值进行排序，如果记录的c2列相同，则按照c3列的值进行排序。
* B+树**叶子节点**处的用户记录由**c2、c3、和主键c1列**组成。

注意一点，以c2和c3列的大小为排序规则建立的B+树称为**联合索引**，本质上也是一个二级索引。它的意思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下：
* 建立**联合索引**只会建立如上图一样的1棵B+树。
* 为c2和c3列分别建立索引会分别以c2和c3列的大小为排序规则建立2棵B+树。


## InnoDB的B+树索引的注意事项

### 1. 根页面位置万年不动
B+树的实际形成过程：
* 每当为某个表创建一个B+树索引（聚簇索引不是人为创建的，默认就有）的时候，都会为这个索引创建一个**根节点**页。最开始表中没有数据的时候，每个B+树索引对应的**根节点**中既没有用户记录，也没有目录项记录。
* 随后向表中插入用户记录时，先把用户记录存储到这个**根节点**中。
* 当根节点的可用**空间用完**时，此时会将根节点中的所有记录复制到一个新分配的页，比如**页a**中，然后对这个新的页进行**页分裂**操作，得到另一个新页，比如**页b**。这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小就会被分配到**页a**或者**页b**中，而**根节点**便升级为存储目录项记录的页。

这个过程特别注意的是：一个B+树索引的根节点自诞生之日起，便不会再移动。这样只要我们对某个表建立一个索引，那么它的根节点的页号便会被记录到某个地方，然后凡是InnoDB存储引擎需要用到这个索引的时候，都会从那个固定的地方取出根节点的页号，从而来访问这个索引。

### 2. 内节点（非叶子节点）中目录项记录的唯一性
我们知道B+树索引的内节点中目录项记录的内容是**索引列+页号**的搭配，但是这个搭配对于二级索引来说有点儿不严谨。还拿index_demo表为例，假设这个表中的数据是这样的：
|c1|c2|c3|
|---|---|---|
|1|1|'u'|
|3|1|'d'|
|5|1|'y'|
|7|1|'a'|

如果二级索引中目录项记录的内容只是**索引列+页号**的搭配的话，那么c2列建立索引后的B树应该长这样：
![InnoDB的索引+20240306142621](https://raw.githubusercontent.com/loli0con/picgo/master/images/InnoDB的索引+20240306142621.png+2024-03-06-14-26-21)

如果我们想插入一行记录，其中**c1**、**c2**、**c3**的值分别是：**9**、**1**、**'c'**，那么在修改这个为c2列建立的二级索引对应的B+树时便碰到了个大问题：由于**页3**中存储的目录项记录是由**c2列+页号**的值构成的，**页3**中的两条目录项记录对应的c2列的值都是**1**，而我们**新插入的这条记录**的c2列的值也是**1**，那我们新插入的记录到底应该放到**页4**中，还是应该放到**页5**中？

为了让新插入记录能够找到自己在哪个页里，我们需要**保证在B+树的同一层内节点的目录项记录除页号这个字段以外是唯一的**。所以对于二级索引的内节点的目录项记录的实际内容上是由三个部分构成的：
* 索引列的值
* 主键值
* 页号

也就是我们把**主键值**也添加到二级索引内节点中的目录项记录了，这样就能保证B+树每一层节点中各条目录项记录除页号这个字段外是唯一的，所以我们为c2列建立二级索引后的示意图实际上应该是这样子的：
![InnoDB的索引+20240306143458](https://raw.githubusercontent.com/loli0con/picgo/master/images/InnoDB的索引+20240306143458.png+2024-03-06-14-34-58)

这样我们再插入记录`(9,1,'c')`时，由于**页3**中存储的目录项记录是由**c2列+主键+页号**的值构成的，可以先把新记录的**c2**列的值和**页3**中个目录项记录的**c2**列的值作比较，如果**c2**列的值相同的话，可以接着比较主键值，因为B+树同一层中不同目录项记录的**c2列+主键**的值肯定是不一样的，所以最后肯定能定位为一的一条目录项记录，在本例中最后确定新记录应该被插入到**页5**中。

### 3. 一个页面最少存储2条记录
InnoDB的一个数据页至少存储两条记录。


## MyISAM中的索引方案

### MyISAM索引的原理
MyISAM引擎使用B+Tree作为索引结构，叶子节点的data域存放的是**数据记录的地址**。

下图是MyISAM索引的原理图。
![InnoDB的索引+20250209210342](https://raw.githubusercontent.com/loli0con/picgo/master/images/InnoDB的索引+20250209210342.png+2025-02-09-21-03-43)

我们知**道InnoDB中索引即数据**，也就是聚簇索引的那棵B+树的叶子节点中已经把所有完整的用户记录都包含了，而MyISAM的索引方案虽然也使用树形结构，但是却**将索引和数据分开存储**：
* 将表中的记录**按照记录的插入顺序**单独存储在一个文件中，称之为**数据文件**。这个文件并不划分为若干个数据页，有多少记录就往这个文件中塞多少记录就成了。由于在插入数据的时候并**没有刻意按照主键大小排序**，所以我们并不能在这些数据上使用二分法进行查找。
* 使用MyISAM存储引擎的表会把索引信息另外存储到一个称为**索引文件**的另一个文件中。MyISAM会单独为表的主键创建一个索引，只不过在索引的叶子节点中存储的不是完整的用户记录，而是**主键值+数据记录地址**的组合。

这里设表一共有三列，假设我们以col1为主键，上图是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主键索引和二级索引（Secondarykey）在结构上没有任何区别，只是主键索引要求key是唯一的，而二级索引的key可以重复。如果我们在col2上建立一个二级索引，则此索引的结构如下图所示:
![InnoDB的索引+20250209210412](https://raw.githubusercontent.com/loli0con/picgo/master/images/InnoDB的索引+20250209210412.png+2025-02-09-21-04-12)

同样也是一棵B+Tree，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为：首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。

### MyISAM 与 InnoDB对比
MyISAM的索引方式都是“非聚簇”的，与InnoDB包含1个聚簇索引是不同的。两种引擎中索引的区别：
1. 在InnoDB存储引擎中，我们只需要根据主键值对**聚簇索引**进行一次查找就能找到对应的记录，而在MyISAM中却需要进行一次**回表**操作，意味着MyISAM中建立的索引相当于全部都是**二级索引**。
2. InnoDB的数据文件本身就是索引文件，而MyISAM索引文件和数据文件是**分离的**，索引文件仅保存数据记录的地址。
3. InnoDB的非聚簇索引data域存储相应记录**主键的值**，而MyISAM索引记录的是**地址**。换句话说，InnoDB的所有非聚簇索引都引用主键作为data域。
4. MyISAM的回表操作是十分**快速**的，因为是拿着地址偏移量直接到文件中取数据的，反观InnoDB是通过获取主键之后再去聚簇索引里找记录，虽然说也不慢，但还是比不上直接用地址去访问。
5. InnoDB要求表**必须有主键**（**MyISAM可以没有**）。如果没有显式指定，则MySQL系统会自动选择一个可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整型。

![InnoDB的索引+20240306144505](https://raw.githubusercontent.com/loli0con/picgo/master/images/InnoDB的索引+20240306144505.png+2024-03-06-14-45-06)