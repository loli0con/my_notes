# Performance Analysis Tools

## 系统性能参数
使用`SHOW STATUS`语句可以查询一些MySQL数据库服务器的性能参数：
```
SHOW [GLOBAL|SESSION] STATUS LIKE '参数'
```

常用参数：
* connections: 连接MySQL服务器的次数。
* uptime: MySQL服务器的上线时间。
* slow_queries: 慢查询的次数。
* innodb_rows_read: SELECT查询返回的行数。
* innodb_rows_inserted: 执行INSERT操作插入的行数。
* innodb_rows_updated: 执行UPDATE操作更新的行数。
* innodb_rows_deleted: 执行DELETE操作删除的行数。
* com_select: 查询操作的次数。
* com_insert: 插入操作的次数。对于批量插入的INSERT操作，只累加一次。
* com_update: 更新操作的次数。
* com_delete: 删除操作的次数。

### 查询成本
查询成本的参数为**last_query_cost**，返回的结果为**页数量**。它对于比较开销是非常有用的，特别是有好几种查询方式可选的时候。

页的数量的多少，并不会直接影响查询的效率。当采用了顺序读取的方式将页一次性加载到缓冲池中，然后再进行查找时，虽然页数量(last_query_cost)增加了不少 ，但是通过缓冲池的机制，并没有增加多少查询时间。



## 慢查询日志

### 开启slow_query_log
1. 开启慢查询日志：`set global slow_query_log='ON'`
2. 查看下慢查询日志是否开启，以及慢查询日志文件的位置：`show variables like '%slow_query_log%'`

配置文件中：
```
[mysqld]
slow_query_log=ON
#slow_query_log=OFF
```

### 修改long_query_time阈值
1. 查看慢查询的时间阈值设置：`show variables like '%long_query_time%'`
2. 设置慢查询的时间阈值：
   1. `set global long_query_time = 秒数`，对当前session的long_query_time失效，对新连接的客户端有效。
   2. `set long_query_time = 秒数`，对当前session的long_query_time有效

### 查看慢查询数目
`SHOW GLOBAL STATUS LIKE '%slow_queries%'`



## 慢查询日志分析工具
MySQL提供了慢查询日志分析工具：mysqldumpslow，命令具体参数如下：
* -a: 不将数字抽象成N，字符串抽象成S
* -s: 是表示按照何种方式排序:
  * c: 访问次数
  * l: 锁定时间
  * r: 返回记录
  * t: 查询时间
  * al: 平均锁定时间
  * ar: 平均返回记录数
  * at: 平均查询时间 (默认方式) 
  * ac: 平均查询次数
* -t: 即为返回前面多少条的数据
* -g: 后边搭配一个正则匹配模式，大小写不敏感的

### 常用参考
```
#得到返回记录集最多的10个SQL
mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log
#得到访问次数最多的10个SQL
mysqldumpslow -s c -t 10 /var/lib/mysql/atguigu-slow.log
#得到按照时间排序的前10条里面含有左连接的查询语句
mysqldumpslow -s t -t 10 -g "left join" /var/lib/mysql/atguigu-slow.log
#另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况 mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log | more
```



## SQL执行成本
1. 查看是否开启 profile：`show variables like 'profiling'`
2. 开启 show profile：`profiling='ON'`
3. 查看 profiles：`show profiles`
4. 查看最近一次 profiles：`show profile 参数`
5. 常用查询参数
   1. ALL:显示所有的开销信息。
   2. BLOCK IO:显示块IO开销。
   3. CONTEXT SWITCHES:上下文切换开销。
   4. CPU:显示CPU开销信息。
   5. IPC:显示发送和接收开销信息。
   6. MEMORY:显示内存开销信 息。
   7. PAGE FAULTS:显示页面错误开销信息。
   8. SOURCE:显示和Source_function，Source_file，Source_line相关的开销信息。
   9. SWAPS:显示交换次数开销信息。



## 分析查询语句——EXPLAIN
基本语法：
```
EXPLAIN SELECT ...
或者
DESCRIBE SELECT ...
```

语句输出的各个列的作用如下:
|列名|描述|
|---|---|
|id|在一个大的查询语句中每个SELECT关键字都对应一个**唯一的id**|
|select_type|SELECT关键字对应的那个查询的类型|
|table|表名|
|partitions|匹配的分区信息|
|type|针对单表的访问方法|
|possible_keys|可能用到的索引|
|key|实际上使用的索引|
|key_len|实际使用到的索引长度|
|ref|当使用索引列等值查询时，与索引列进行等值匹配的对象信息|
|rows|预估的需要读取的记录条数|
|filtered|某个表经过搜索条件过滤后剩余记录条数的百分比|
|Extra|一些额外的信息|


### table
不论查询语句有多复杂，包含了多少个表，到最后也是需要对每个表进行单表访问的，所 以MySQL规定**EXPLAIN语句输出的每条记录都对应着某个单表的访问方法**，该条记录的table列代表着该表的表名(有时不是真实的表名字，可能是简称)。

### id
查询语句一般都以 SELECT 关键字开头，整个语句包含一到多个 SELECT 关键字。id 与 SELECT 关键字对应，表示一次独立的查询，是查询的序列号，用于标识查询的分组和顺序：
1. id如果相同，可以认为是一组，从上往下顺序执行
2. 在所有组中，id值越大，优先级越高，越先执行

### select_type
|查询类型|说明|
|---|---|
|SIMPLE|简单查询（未使用UNION或子查询）|
|PRIMARY|最外层的查询|
|UNION|在UNION中的第二个和随后的SELECT被标记为UNION|
|UNION RESULT|UNION的结果|
|DEPENDENT UNION|UNION中的第二个或后面的查询，依赖了外层的查询|
|SUBQUERY|子查询中的第一个SELECT|
|DEPENDENT SUBQUERY|子查询中的第一个 SELECT，依赖了外层的查询|
|DERIVED|在FROM列表中包含的子查询被标记为DERIVED(衍生)，MySQL会递归执行这些子查询，把结果放在临时表里。|
|MATERIALIZED|物化子查询|
|UNCACHEABLE SUBQUERY|子查询，结果无法缓存，必须针对外部查询的每一行重新评估|
|UNCACHEABLE UNION|UNION中的属于UNCACHEABLE SUBQUERY的第二个或后面的查询|

### type
访问方式，有如下几种取值，性能从好到坏排序如下：
1. NULL
2. system
3. const
4. eq_ref
5. ref
6. fulltext
7. ref_or_null
8. index_merge
9. unique_subquery
10. index_subquery
11. range
12. index
13. ALL

#### NULL
MySQL能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引。
如：
* 从系统库mysql的系统表proxies_priv里查询数据，这里的数据在Mysql服务启动时候已经加载在内存中，不需要进行磁盘IO。
* select 1
* select max(id) from ...

#### system
该表只有一行（相当于系统表），system是const类型的特例。  

#### const
针对主键或唯一索引的等值查询扫描，通过索引一次就找到了，最多只返回一行数。如将主键置于where列表中，MySQL就能将该查询转换为一个常量。

#### eq_ref
当使用了索引的全部组成部分，并且索引是PRIMARY KEY或UNIQUE NOT NULL 才会使用该类型，性能仅次于system及const。如连表查询使用主键或唯一索引作为连接条件。

#### ref
当满足索引的最左前缀规则，或者索引不是主键也不是唯一索引时才会发生。ref每一次匹配可能有多行数据返回。

##### 最左匹配原则
最左前缀原则，指的是索引按照最左优先的方式匹配索引。比如创建了一个组合索引(column1, column2, column3)，那么，如果查询条件是：
* `WHERE column1 = 1`、`WHERE column1= 1 AND column2 = 2`、`WHERE column1= 1 AND column2 = 2 AND column3 = 3` 都可以使用该索引；
* `WHERE column2 = 2`、`WHERE column1 = 1 AND column3 = 3`就无法匹配该索引。

#### ref_or_null
该类型类似于ref，但是MySQL会额外搜索哪些行包含了NULL。这种类型常见于解析子查询
```SQL
SELECT * FROM table1 
WHERE key_column=expr OR key_column IS NULL;
```

#### index_merge
此类型表示使用了**索引合并**优化，表示一个查询里面用到了多个索引
```SQL
SELECT * FROM table1
WHERE key1 = 'xxx' OR key3 = 'yyy';
```

#### unique_subquery
该类型和eq_ref类似，但是使用了IN查询，且子查询是主键或者唯一索引。
```SQL
SELECT * FROM s1 
WHERE key2 IN (
   SELECT id FROM s2 
   WHERE s1.key1 = s2.key1) OR key3 = 'a';
```

#### index_subquery
和unique_subquery类似，只是子查询使用的是非唯一索引。
```SQL
SELECT * FROM s1 
WHERE common_field IN (
   SELECT key3 FROM s2
   WHERE s1.key1 = s2.key1) OR key3 = 'a';
```

#### range
范围扫描，表示检索了指定范围的行，主要用于有限制的索引扫描。比较常见的范围扫描是带有BETWEEN子句或WHERE子句里有>、>=、<、<=、IS NULL、<=>、BETWEEN、LIKE、IN()等操作符。

#### index
全索引扫描，和ALL类似，只不过index是全盘扫描了索引的数据。当查询仅使用索引中的一部分列时，可使用此类型。有两种场景会触发：
* 如果索引是查询的覆盖索引，并且索引查询的数据就可以满足查询中所需的所有数据，则只扫描索引树。此时，explain的Extra列的结果是Using index。index通常比ALL快，因为索引的大小通常小于表数据。
* 按索引的顺序来查找数据行，执行了全表扫描。此时，explain的Extra列的结果不会出现Uses index。

#### ALL
全表扫描，性能最差。


### possible_keys
展示当前查询可以使用哪些索引，这一列的数据是在优化过程的早期创建的，因此有些索引可能对于后续优化过程是没用的。

### key
表示MySQL实际选择的索引。

### key_len
索引使用的字节数。由于存储格式(innodb)，当字段允许为NULL时，key_len比不允许为空时大1字节。

#### 计算公式
1. varchar(10)变长字段且允许NULL = 10*(character set: utf8=3,gbk=2,latin1=1)+1(NULL)+2(变长字段)
2. varchar(10)变长字段且不允许NULL = 10*(character set:utf8=3,gbk=2,latin1=1)+2(变长字段)
3. char(10)固定字段且允许NULL = 10*(character set:utf8=3,gbk=2,latin1=1)+1(NULL)
4. char(10)固定字段且不允许NULL = 10*(character set:utf8=3,gbk=2,latin1=1)


### ref
ref表示将哪个字段或常量和key列所使用的索引字段进行比较。如果ref是一个函数，则使用的值是函数的结果。要想查看是哪个函数，可在EXPLAIN语句之后紧跟一个SHOW WARNING语句。
![性能分析工具+20220919165155](https://raw.githubusercontent.com/loli0con/picgo/master/images/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%2B20220919165155.png%2B2022-09-19-16-51-57)

### rows
MySQL估算会扫描的行数，数值越小越好。

### filtered
表示符合查询条件的数据百分比，最大100。用rows × filtered可获得和下一张表连接的行数。例如rows = 1000，filtered = 50%，则和下一张表连接的行数是500。

### Extra
展示有关本次查询的附加信息

#### No tables used
当此查询没有FROM子句或拥有FROM DUAL子句时出现。例如：explain select 1

#### Impossible HAVING
HAVING子句始终为false，不会命中任何行

#### Impossible WHERE
WHERE子句始终为false，不会命中任何行

#### No matching min/max row
当查询列表有min()或者max()聚集函数，但是没有匹配到对应的记录时会出现No matching min/max row。

#### no matching row in const table
对于关联查询，存在一个空表，或者没有行能够满足唯一索引条件

#### No matching rows after partition pruning
对于DELETE或UPDATE语句，优化器在partition pruning（分区修剪）之后，找不到要delete或update的内容

#### Not exists
当使用左（外）连接时，如果WHERE子句中包含要求被驱动表的某个列等于NULL值的搜索条件，而且那个列又是不允许存储NULL值的，那么在该表的执行计划的Extra列就会提示Not exists额外信息，比如这样：
```SQL
SELECT * FROM s1 LEFT JOIN s2 ON s1.key1 = s2.key1 WHERE s2.id IS NULL;
```

#### Using where
当使用全表访问**进行查询**时，如果查询语句包含where条件，就会出现Using where。当使用索引访问**进行查询**时（在索引树上**进行查询**），也会出现Using where。

#### Using index
仅使用索引树中的信息从表中检索列信息，而不必进行其他查找以读取实际行。即需要确保where子句筛选条件是索引的前导列，且select子句查询的列被**索引覆盖**。

覆盖索引：select的数据列只用从索引中就能够取得，不必读取数据行。MySQL可以利用索引返回select列表中的字段，而不必根据索引再次读取数据文件，即查询列要被所建的索引覆盖。

如果同时出现using where，表明索引被用来执行索引键值的查找，即在仅访问索引树而不回表的情况下，在索引树中查询select子句中所出现的列。

#### Using index condition
表示先按条件过滤索引，过滤完索引后找到所有符合索引条件的数据行，随后用 WHERE 子句中的其他条件去过滤这些数据行。

示例如下：
```SQL
SELECT * FROM s1 WHERE key1 > 'z' AND key1 LIKE '%a';
```
1. 索引扫描：先根据key1 > 'z'这个条件，定位到二级索引idx_key1中对应的二级索引记录。
2. 索引过滤：先不回表，而是检测是否满足key1 LIKE '%a'条件，最后再将满足条件的二级索引记录回表。

##### 索引下推
索引下推（INDEX CONDITION PUSHDOWN，简称 ICP）是 MySQL 5.6 发布后针对扫描二级索引的一项优化改进。总的来说是通过把索引过滤条件下推到存储引擎，来减少 MySQL 存储引擎访问基表的次数以及 MySQL 服务层访问存储引擎的次数。

MySQL 存储引擎层按照 MySQL 服务层下发的请求，通过索引或者全表扫描等方式把数据上传到 MySQL 服务层。

#### Using filesort
当Query中包含 ORDER BY 操作，而且无法利用索引完成排序操作的时候，MySQL Query Optimizer 不得不选择相应的排序算法来实现。数据较少时从内存排序，否则从磁盘排序。Explain不会显示的告诉客户端用哪种排序。

filesort主要用于查询数据结果集的排序操作，首先MySQL会使用sort_buffer_size大小的内存进行排序，如果结果集超过了sort_buffer_size大小，会把这一个排序后的chunk转移到file上，最后使用多路归并排序完成所有数据的排序操作。

#### Using join buffer 
在连接查询执行过程中，当被驱动表不能有效的利用索引加快访问速度，MySQL一般会为其分配一块名叫join buffer的内存块来加快查询速度。

#### Using sort_union(…), Using union(…), Using intersect(…)
如果使用了索引合并执行查询，则会出现Using intersect(...)或者Using union(...)或者Using sort_union(...)。，这些指示索引扫描如何合并为index_merge连接类型。

#### Zero limit
当limit子句参数为0时，就会出现Zero limit。



## EXPLAIN的四种输出格式
EXPLAIN可以输出四种格式：传统格式，JSON格式，TREE格式以及可视化输出。

### 传统格式
传统格式简单明了，输出是一个表格形式，概要说明查询计划。

### JSON格式
JSON格式：在EXPLAIN单词和真正的查询语句中间加上`FORMAT=JSON`，输出结果中包含了“查询成本”。
```SQL
EXPLAIN FORMAT=JSON SELECT ...
```

#### 查询成本
SQL语句如下：
```SQL
EXPLAIN SELECT s1.key1, s2.key1
FROM s1 LEFT JOIN s2 ON s1.key1 = s2.key1
WHERE s1.common_field = 'a'
```

驱动表的查询成本：
```JSON
"cost_info": {
    "read_cost": "1840.84",
    "eval_cost": "193.76",
    "prefix_cost": "2034.60",
    "data_read_per_join": "1M"
}
```
其中：
* read_cost 是由下边这两部分组成的：
  * IO 成本
  * 检测 rows × (1 - filter) 条记录的 CPU 成本
* eval_cost 是检测 rows × filter 条记录的成本
* prefix_cost 就是单独查询 s1 表的成本，也就是: read_cost + eval_cost
* data_read_per_join 表示在此次查询中需要读取的数据量

被驱动表的查询成本：
```JSON
"cost_info": {
    "read_cost": "968.80",
    "eval_cost": "193.76",
    "prefix_cost": "3197.16",
    "data_read_per_join": "1M"
}
```
被驱动表可能被读取多次，这里的 read_cost 和 eval_cost 是访问多次被驱动表后累加起来的值。  
prefix_cost 的值代表的是整个连接查询预计的成本，也就是单次查询 s1 表和多次查询 s2 表后的成本的和，也就是：968.80 + 193.76 + 2034.60 = 3197.16


### TREE格式
TREE格式主要根据查询的 **各个部分之间的关系** 和 **各部分的执行顺序** 来描述如何查询。
```SQL
mysql> EXPLAIN FORMAT=tree SELECT * FROM s1 INNER JOIN s2 ON s1.key1 = s2.key2 WHERE
s1.common_field = 'a'\G
*************************** 1. row ***************************
EXPLAIN: -> Nested loop inner join  (cost=1360.08 rows=990)
    -> Filter: ((s1.common_field = 'a') and (s1.key1 is not null))  (cost=1013.75 rows=990)
        -> Table scan on s1  (cost=1013.75 rows=9895)
    -> Single-row index lookup on s2 using idx_key2 (key2=s1.key1), with index condition: (cast(s1.key1 as double) = cast(s2.key2 as double))  (cost=0.25 rows=1)
1 row in set, 1 warning (0.00 sec)
```

### 可视化输出
可视化输出，可以通过MySQL Workbench可视化查看MySQL的执行计划。通过点击Workbench的放大镜图
标，即可生成可视化的查询计划。



## EXPLAIN的拓展信息
EXPLAIN可产生额外的扩展信息，可通过在EXPLAIN语句后紧跟一条SHOW WARNING语句查看扩展信息。



## 分析优化器执行计划——trace
OPTIMIZER_TRACE可以追踪优化器做出的各种决策（比如访问表的方法、各种开销计算、各种转换等），并将跟踪结果记录到INFORMATION_SCHEMA.OPTIMIZER_TRACE表中。

此功能默认关闭。开启trace，并设置格式为JSON。同时设置trace最大能够使用的内存大小，避免解析过程中因为默认内存过小而不能够完整显示。
```mysql
SET optimizer_trace="enabled=on",end_markers_in_json=on;
SET optimizer_trace_max_mem_size=1000000;
```

开启后，可分析如下语句：
* SELECT
* INSERT
* REPLACE
* UPDATE
* DELETE
* EXPLAIN
* SET
* DECLARE
* CASE
* IF
* RETURN
* CALL

### demo
执行如下SQL语句：
```sql
select * from student where id < 10;
```

查询 information_schema.optimizer_trace 就可以知道MySQL是如何执行SQL的：
```sql
select * from information_schema.optimizer_trace\G
```

显示结果为四个部分：
1. 查询语句
2. QUERY字段对应语句的跟踪信息
3. 跟踪信息过长时，被截断的跟踪信息的字节数
4. 执行跟踪语句的用户是否有查看对象的权限。当不具有权限时，该列信息为1且TRACE字段为空，一般在调用带有SQL SECURITY DEFINER的视图或者是存储过程的情况下，会出现此问题。