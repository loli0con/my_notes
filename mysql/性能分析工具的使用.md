# 性能分析工具的使用
在数据库调优中，我们的目标就是**响应时间更快**，**吞吐量更大**。利用宏观的监控工具和微观的日志分析可以帮我们快速找到调优的思路和方式。

## 数据库服务器的优化步骤
我们可以通过观察了解数据库整体的运行情况，通过性能分析工具可以让我们了解执行慢的SQL都有哪些，查看具体的SQL执行计划，甚至是SQL执行中的每一步的成本代价，这样才能定位问题所在，找到了问题，再采取相应的行动。

整个流程划分成了**观察（Show status）**和**行动（Action）** 两个部分。**字母S**的部分代表观察(会使用相应的分析工具)，**字母A**代表的部分是行动(对应分析可以采取的行动)。

![性能分析工具的使用+数据库调优步骤.drawio](https://raw.githubusercontent.com/loli0con/picgo/master/images/性能分析工具的使用+数据库调优步骤.drawio.png+2024-03-11-17-18-18)

1. 首先在S1部分，我们需要观察服务器的状态是否存在周期性的波动。如果**存在周期性波动**，有可能是周期性节点的原因，比如双十一、促销活动等。这样的话，我们可以通过A1这一步解决，也就是加缓存，或者更改缓存失效策略。
2. 如果缓存策略没有解决，或者不是周期性波动的原因，我们就需要进一步**分析查询延迟和卡顿的原因**。接下来进入S2这一步，我们需要开启慢查询。慢查询可以帮我们定位执行慢的SQL语句。我们可以通过设置`long_query_time`参数定义“慢”的阈值，如果SQL执行时间超过了long_query_time，则会被认为是慢查询。当收集上来这些慢查询之后，我们就可以通过分析工具对慢查询日志进行分析。
3. 在S3这一步骤中，我们就知道了执行慢的SQL，这样就可以针对地用**EXPLAIN**查看对应SQL语句执行计划，或者使用[**Profiling功能**](profiling.md)查看SQL中每一个步骤的时间成本。这样我们就可以了解SQL查询慢是因为执行时间长，还是等待时间长。
4. 如果是SQL等待时间长，我们进入A2步骤。在这一步骤中，我们可以**调优服务器的参数**，比如适当增加数据库缓冲池。如果是SQL执行时间长，就进入A3步骤，这一步中我们需要考虑是*索引设计的问题*，还是*查询关联的数据表过多*，还是因为*数据库的字段设计问题*导致了这一现象。然后在这些维度上进行对应的调整。
5. 如果A2和A3都不能解决问题，我们需要考虑数据库自身的SQL查询性能是否已经到达了瓶颈，如果确认没有到达性能瓶颈，就需要重新检查，重复以上的步骤。如果已经到达了**性能瓶颈**，进入A4阶段，需要考虑**增加服务器**，采用**读写分离**的架构，或者对数据库进行**分库分表**，比如垂直分库、垂直分表和水平分表等。

以上就是数据库调优的流程思路。如果我们发现执行SQL时存在不规则延迟或卡顿的时候，就可以采用分析工具帮我们定位有问题的SQL，这三种分析工具你可以理解是SQL调优的三个步骤：**慢查询**、**EXPLAIN**和**PROFILING**。

![性能分析工具的使用+20240311173854](https://raw.githubusercontent.com/loli0con/picgo/master/images/性能分析工具的使用+20240311173854.png+2024-03-11-17-38-55)


## 查看系统性能参数
在MySQL中，可以使用**SHOW STATUS**语句查询一些MySQL数据库服务器的**性能参数**、**执行频率**。SHOW STATUS语句语法如下:
```SQL
SHOW [GLOBAL|SESSION] STATUS LIKE '参数';
```

一些常用的性能参数如下：
* Connections：连接MySQL服务器的次数。
* Uptime：MySQL服务器的上线时间。
* Slow_queries：慢查询的次数。
* Innodb_rows_read：Select查询返回的行数。
* Innodb_rows_inserted：执行INSERT操作插入的行数。
* Innodb_rows_updated：执行UPDATE操作更新的行数。
* Innodb_rows_deleted：执行DELETE操作删除的行数。
* Com_select：查询操作的次数。
* Com_insert：插入操作的次数。对于批量插入的INSERT操作，只累加一次。
* Com_update：更新操作的次数。
* Com_delete：删除操作的次数。

慢查询次数参数可以结合慢查询日志找出慢查询语句，然后针对慢查询语句进行**表结构优化**或者**查询语句优化**。

## 统计SQL的查询成本：last_query_cost
一条SQL查询语句在执行前需要确定查询执行计划，如果存在多种执行计划的话，MySQL会计算每个执行计划所需要的成本，从中选择**成本最小**的一个作为最终执行的执行计划。

如果我们想要查看某条SQL语句的查询成本，可以在执行完这条SQL语句之后，通过查看当前会话中的**last_query_cost**变量值来获得当前查询的成本。它通常也是我们**评价一个查询的执行效率**的一个常用指标。这个查询成本对应的是**SQL语句所需要读取的页的数量**。

有时候存在两个SQL，即使后一个SQL需要读取的页的数量是前一个的20倍，但是查询的效率并没有明显的变化，实际上这两个SQL查询的时间基本一样，就是因为采用了顺序读取的方式将页面一次加载到缓冲池中，然后再进行查找。虽然**页数量（last_query_cost）增加了不少**，但是通过缓冲池的机制，并**没有增加多少的查询时间**。

SQL查询是一个动态的过程，从页加载的角度来看，我们可以得到以下两点结论：
1. **位置决定效率**。如果页就在数据库**缓冲池**中，那么效率时最高的，否则还需要从**内存**或者**硬盘**中进行读取，当然针对单个页的读取来说，如果页存在于内存中，会比在磁盘中读取效率高很多。
2. **批量决定效率**。如果我们从磁盘中对单一页进行随机读，那么效率时很低的（差不多10ms），而采用顺序读取的方式，批量对页进行读取，平均一页的读取效率就会提升很多，甚至要快于单个页面在内存中的随机读取。

所以说，遇到I/O并不用担心，方法找对了，效率还是很高的。我们首先要考虑数据存放的位置，如果是经常使用到的数据就要尽量放到缓冲池中，其次我们可以利用磁盘的吞吐能力，一次性批量读取数据，这样单个页的读取效率也就得到了提升。

## 定位执行慢的SQL：慢查询日志
MySQL的慢查询日志，用来记录在MySQL中**响应时间超过阈值**的语句，具体指运行时间超过**long_query_time**值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为**10**，意思是运行10秒以上（不含10秒）的语句，认为是超出了我们最大忍耐时间值。

它的主要作用是，帮助我们发现那些执行时间特别长的SQL查询，并且有针对性地进行优化，从而提高系统的整体效率。当我们的数据库服务器发生阻塞、运行变慢的时候，检查一下慢查询日志，找到那些慢查询，结合explain进行全面分析，对解决问题很有帮助。

默认情况下，MySQL数据库**没有开启慢查询日志**，需要我们手动来设置这个参数。**如果不是调优需要的话，一般不建议启动该参数**，因为开启慢查询日志会或多或少带来一定的性能影响。

慢查询日志支持将日志记录写入文件。

### 开启慢查询日志参数

#### 开启slow_query_log（命令行）
在使用前，我们需要先看下慢查询是否已经开启，使用下面这条命令即可：
```SQL
show variables like '%slow_query_log';
```
我们能看到`slow_query_log=OFF`，我们可以把慢查询日志打开，注意设置变量值的时候需要使用global，否则会报错：
```SQL
set global slow_query_log='ON';
```
然后我们再来查看下慢查询日志是否开启，以及慢查询日志文件的位置：
```SQL
mysql> show variables like '%slow_query_log%';
+---------------------+-------------------------------------------+
| Variable_name       | Value                                     |
+---------------------+-------------------------------------------+
| slow_query_log      | ON                                        |
| slow_query_log_file | /usr/local/var/mysql/默认为主机名-slow.log |
+---------------------+-------------------------------------------+
```
你能看到这时慢查询分析已经开启，同时文件保存在**xxx**文件中（文件路径参照具体的配置）。

#### 修改long_query_time阈值（命令行）
接下来我们来看下慢查询的时间阈值设置，使用如下命令：
```SQL
show variables like '%long_query_time%';
```

![性能分析工具的使用+20240311191638](https://raw.githubusercontent.com/loli0con/picgo/master/images/性能分析工具的使用+20240311191638.png+2024-03-11-19-16-39)

这里如果我们想把时间缩短，比如设置为1秒，可以这样设置：
```SQL
-- 设置global的方式对当前session的long_query_time无效，对新连接的客户端有效。所以需要一并执行下述语句：
mysql> set global long_query_time = 1;
mysql> show global variables like '%long_query_time%';

mysql> set long_query_time=1;
mysql> show variables like '%long_query_time%';
```

#### 配置文件中设置慢查询参数（永久生效）
相较于命令行设置的方式，修改**my.cnf**文件可以看作是永久设置的方式。`[mysqld]`下增加或修改参数*long_query_time*、*show_query_log*和*show_query_log_file*后，然后重启MySQL服务器。
```conf
[mysqld]
show_query_log=ON #开启慢查询日志的开关
show_query_log_file=/var/lib/mysql/myhostname-slow.log #慢查询日志的目录和文件名信息
long_query_time=3 #设置慢查询的阈值为3秒，超出此设置值的SQL被记录到慢查询日志
log_output=FILE
```
如果不指定存储路径，慢查询日志将默认存储到MySQL数据库的数据文件夹下。如果不指定文件名，默认文件名为hostname-slow.log。其中*hostname*为主机名。

除了上述变量，控制慢查询日志的还有一个系统变量：**min_examined_row_limit**。这个变量的意思是，查询**扫描过的最少记录数**。这个变量和查询执行时间，共同组成了判别一个查询是否是慢查询的条件。如果查询扫描过的记录数大于等于这个标量的值，并且查询执行时间超过**long_query_time**的值，那么这个查询就会被记录到慢查询日志中；反之，则不被记录到慢查询日志中。

这个值默认是**0**。与long_query_time=10合在一起，表示只要查询的执行时间超过10秒钟，哪怕一个记录也没有扫描过（即未找到任何符合WHERE条件的记录），都要被记录到慢查询日志中。你也可以根据需要，通过修改配置文件文件，来修改查询时长，或者通过SET指令，用SQL语句修改min_examined_row_limit的值。

### 查看慢查询数目
查询当前系统中有多少条慢查询记录：
```SQL
SHOW GLOBAL STATUS LIKE '%Slow_queries%';
```

### 慢查询日志分析工具：mysqldumpslow
在生产环境中，如果要手工分析日志，查找、分析SQL，显然是个体力活，MySQL提供了日志分析工具**mysqldumpslow**。查看mysqldumpslow的帮助信息：
```bash
mysqldumpslow --help
Usage: mysqldumpslow [ OPTS... ] [ LOGS... ]

Parse and summarize the MySQL slow query log. Options are

  --verbose    verbose
  --debug      debug
  --help       write this text to standard output

  -v           verbose
  -d           debug
  -s ORDER     what to sort by (al, at, ar, c, l, r, t), 'at' is default
                al: average lock time
                ar: average rows sent
                at: average query time
                 c: count
                 l: lock time
                 r: rows sent
                 t: query time
  -r           reverse the sort order (largest last instead of first)
  -t NUM       just show the top n queries
  -a           don't abstract all numbers to N and strings to 'S'
  -n NUM       abstract numbers with at least n digits within names
  -g PATTERN   grep: only consider stmts that include this string
  -h HOSTNAME  hostname of db server for *-slow.log filename (can be wildcard),
               default is '*', i.e. match all
  -i NAME      name of server instance (if using mysql.server startup script)
  -l           don't subtract lock time from total time
```
mysqldumpslow 命令的具体参数如下：
* `-s`: 是表示按照何种方式排序
  * `c`: 访问次数
  * `l`: 锁定时间
  * `r`: 返回记录
  * `t`: 查询时间
  * `al`: 平均锁定时间
  * `ar`: 平均返回记录数
  * `at`: 平均查询时间 (默认方式)
  * `ac`: 平均查询次数
* `-t`: 即为返回前面多少条的数据
* `-a`: 不将数字抽象成N，字符串抽象成S
* `-g`: 后边搭配一个正则匹配模式，大小写不敏感的

工作常用参考：
```bash
#得到返回记录集最多的10个SQL
mysqldumpslow -s r -t 10 /var/lib/mysql/hostname-slow.log

#得到访问次数最多的10个SQL
mysqldumpslow -s c -t 10 /var/lib/mysql/hostname-slow.log

#得到按照时间排序的前10条里面含有左连接的查询语句
mysqldumpslow -s t -t 10 -g "left join" /var/lib/mysql/hostname-slow.log

#另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况 
mysqldumpslow -s r -t 10 /var/lib/mysql/hostname-slow.log | more
```

### 关闭慢查询日志
MySQL服务器停止慢查询日志功能有两种方法。

#### 永久性方式
修改配置文件，把`[mysqld]`组下的slow_query_log值设为OFF（或者注释掉，或者删除掉），修改后保存，再重启MySQL服务，即可生效：
```conf
[mysqld]
slow_query_log=OFF
```

#### 临时性方式
使用SET语句来设置，停止MySQL慢查询日志功能，具体SQL语句：`SET GLOBAL slow_query_log=off;`。

### 删除慢查询日志
使用SHOW语句显示慢查询日志信息，具体SQL语句如下：
```SQL
SHOW VARIABLES LIKE 'slow_query_log%';
```
从执行结果可以看出，慢查询日志的目录默认为MySQL的数据目录，在该目录下**手动删除慢查询日志文件**即可。

使用命令`mysqladmin flush-logs`来重新生成日志文件，具体命令如下，执行完毕在数据目录下重新生成慢查询日志文件：
```bash
# 重建慢查询日志文件，注意要打开慢查询日志功能才会生成慢查询日志文件。
mysqladmin -root -p flush-logs slow
```
慢查询日志都是使用`mysqladmin flush-logs`命令来删除重建的。使用时一定要注意，一旦执行了这个命令，慢查询日志都只存在新的日志文件中，如果需要旧的查询日志，就必须事先备份。

## 分析查询语句:EXPLAIN

### 概述
**定位了查询慢的SQL之后，我们就可以使用EXPLAIN或DESCRIBE工具做针对性的分析查询语句**。DESCRIBE语句的使用方法与EXPLAIN语句是一样的，并且分析结果也是一样的。

MySQL中有专门负责优化SELECT语句的优化器模块，主要功能：通过计算分析系统中收集到的统计信息，为客户端请求的Query提供它认为最优的**执行计划**（它认为最优的数据检索方式，但不见得是DBA认为是最优的，这部分最耗费时间）。

这个执行计划展示了接下来具体执行查询的方式，比如多表连接的顺序是什么，对于每个表采用什么访问方法来具体执行查询等等。MySQL为我们提供了**EXPLAIN**语句来帮助我们查看某个查询语句的具体执行计划，看懂**EXPLAIN**语句的各个输出项，可以有针对性的提升查询语句的性能。

### 基本语法
EXPLAIN或DESCRIBE语句的语法形式如下：
```SQL
EXPLAIN SELECT select_options;
-- 或者
DESCRIBE SELECT select_options;
```

如果我们想看看某个查询的执行计划的话，可以在具体的查询语句前边加一个EXPLAIN，就像这样:

![性能分析工具的使用+20240312161951](https://raw.githubusercontent.com/loli0con/picgo/master/images/性能分析工具的使用+20240312161951.png+2024-03-12-16-19-52)

输出的上述信息就是所谓的**执行计划**。在这个执行计划的辅助下，我们需要知道应该怎样改进自己的查询语句以使查询执行起来更高效。其实除了以SELECT开头的查询语句，其余的DELETE、INSERT、REPLACE以及UPDATE语句等都可以加上EXPLAIN，用来查看这些语句的执行计划，只是平时我们对SELECT语句更感兴趣。

注意：执行EXPLAIN时并没有真正的执行该后面的语句，因此可以安全的查看执行计划。

EXPLAIN语句输出的各个列的作用如下：
|列名|描述|
|---|---|
|id|在一个大的查询语句中每个SELECT关键字都对应一个**唯一的id**|
|select_type|SELECT关键字对应的那个查询的类型|
|table|表名|
|partitions|匹配的分区信息|
|type|针对单表的访问方法|
|possible_keys|可能用到的索引|
|key|实际上使用的索引|
|key_len|实际使用到的索引长度|
|ref|当使用索引列等值查询时，与索引列进行等值匹配的对象信息|
|rows|预估的需要读取的记录条数|
|filtered|某个表经过搜索条件过滤后剩余记录条数的百分比|
|Extra|一些额外的信息|

### 示例表结构
两张相同的表，方便连表查询使用。
```SQL
CREATE TABLE s1 (
    id INT AUTO_INCREMENT,
    key1 VARCHAR(100),
    key2 INT,
    key3 VARCHAR(100),
    key_part1 VARCHAR(100),
    key_part2 VARCHAR(100),
    key_part3 VARCHAR(100),
    common_field VARCHAR(100),
    PRIMARY KEY (id),
    INDEX idx_key1 (key1),
    UNIQUE INDEX idx_key2 (key2),
    INDEX idx_key3 (key3),
    INDEX idx_key_part(key_part1, key_part2, key_part3)
) ENGINE=INNODB CHARSET=utf8;

CREATE TABLE s2 (
    id INT AUTO_INCREMENT,
    key1 VARCHAR(100),
    key2 INT,
    key3 VARCHAR(100),
    key_part1 VARCHAR(100),
    key_part2 VARCHAR(100),
    key_part3 VARCHAR(100),
    common_field VARCHAR(100),
    PRIMARY KEY (id),
    INDEX idx_key1 (key1),
    UNIQUE INDEX idx_key2 (key2),
    INDEX idx_key3 (key3),
    INDEX idx_key_part(key_part1, key_part2, key_part3)
) ENGINE=INNODB CHARSET=utf8;
```

### EXPLAIN各列作用

#### table
不论我们的查询语句有多复杂，里边儿包含了多少个表，到最后也是需要对每个表进行**单表访问**的，所以MySQL规定**EXPLAIN语句输出的每条记录都对应着某个单表的访问方法**，该条记录的table列代表着该表的表名（有时不是真实的表名字，可能是简称）。

#### id
我们写的查询语句一般都以SELECT关键字开头，比较简单的查询语句里只有一个SELECT关键字，比如下边这个查询语句：
```SQL
SELECT * FROM s1 WHERE key1 = 'a';
```

稍微复杂一点的连接查询中也只有一个SELECT关键字，比如：
```SQL
SELECT * FROM s1 INNER JOIN s2
ON s1.key1 = s2.key1
WHERE s1.common_field = 'a';
```

但是下面两种情况下在一条查询语句中会出现多个SELECT关键字：
* 查询中包含子查询的情况：`SELECT * FROM s1 WHERE key1 IN (SELECT key3 FROM s2);`
* 查询中包含UNION语句的情况：`SELECT * FROM s1 UNION SELECT * FROM s2;`

**查询语句中每出现一个SELECT关键字，MySQL就会为它分配一个唯一的id值**。这个**id**值就是EXPLAIN语句的第一个列，比如下面这个查询中只有一个SELECT关键字，所以EXPLAIN的结果中也就只有一条**id**列为*1*的记录：
```SQL
mysql> EXPLAIN SELECT * FROM s1 WHERE key1 = 'a';
```

![性能分析工具的使用+20240312165417](https://raw.githubusercontent.com/loli0con/picgo/master/images/性能分析工具的使用+20240312165417.png+2024-03-12-16-54-17)

对于连接查询来说，一个SELECT关键字后边的FROM子句中可以跟随多个表，所以在连接查询的执行计划中，每个表都会对应一条记录，但是这些记录的id值都是相同的，比如
```SQL
-- s1:驱动表 s2:被驱动表
mysql> EXPLAIN SELECT * FROM s1 INNER JOIN s2;
```

![性能分析工具的使用+20240312165644](https://raw.githubusercontent.com/loli0con/picgo/master/images/性能分析工具的使用+20240312165644.png+2024-03-12-16-56-45)

可以看到，上述连接查询中参与连接的*s1*和*s2*表分表对应一条记录，但是这两条记录对应的**id**值都是*1*。这里需要大家记住的是，**在连接查询的执行计划中，每个表都会对应一条记录，这些记录的id列的值都是相同的**，出现在前边的表是**驱动表**，出现在后边的表是**被驱动表**。所以从上边的EXPLAIN输出中我们可以看出，查询优化器准备让*s1*表作为驱动表，让*s2*表作为被驱动表来执行查询。

对于包含子查询的查询语句来说，就可能涉及多个SELECT关键字，所以**在包含子查询的查询语句的执行计划中，每个SELECT关键字都会对应一个唯一的id值**，比如这样：
```SQL
mysql> EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) OR key3 = 'a';
```

![性能分析工具的使用+20240312170247](https://raw.githubusercontent.com/loli0con/picgo/master/images/性能分析工具的使用+20240312170247.png+2024-03-12-17-02-48)

从输出的结果我们可以看到，*s1*表在外层查询中，外层查询有一个独立的SELECT关键字，所以第一条记录的**id**值就是*1*，*s2*表在子查询中，子查询有一个独立的SELECT关键字，所以第二条记录的**id**值就是*2*。

但是这里大家需要特别注意，**查询优化器可能对涉及子查询的查询语句进行重写，从而转化为连接查询**。所以如果我们想知道查询优化器对某个包含子查询的语句是否进行了重写，直接查看查询计划就好了，比如说：
```SQL
mysql> EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key2 FROM s2 WHERE common_field = 'a');
```

![性能分析工具的使用+20240312170719](https://raw.githubusercontent.com/loli0con/picgo/master/images/性能分析工具的使用+20240312170719.png+2024-03-12-17-07-20)

可以看到，虽然我们的查询语句是一个子查询，但是执行计划*s1*表和*s2*表对应的记录的**id**值全都是*1*，这就表明了查询优化器将子查询转换为了连接查询。

对于包含UNION子句的查询语句来说，每个SELECT关键字对应一个**id**值也是没错的，不过还是有点儿特别的东西，比如说下边这个查询：
```SQL
mysql> EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2;
```
![性能分析工具的使用+20240312170959](https://raw.githubusercontent.com/loli0con/picgo/master/images/性能分析工具的使用+20240312170959.png+2024-03-12-17-10-00)

**UNION**会把多个查询的结果合并起来并对结果集中的记录**进行去重**，MySQL使用的是内部的**临时表**。正如上边的查询计划中所示，UNION子句是为了把**id**为*1*的查询和**id**为*2*的查询的结果集合并起来并去重，所以在内部创建了一个名为`<union1, 2>`的临时表（就是执行计划第三条记录的table列的名称），**id**为*NULL*表明这个临时表是为了合并两个查询结果集而创建的。

跟UNION对比起来，**UNION ALL**就不需要为最终的结果集进行去重，它只是单纯的把多个查询结果集中的记录合并成一个并返回给用户，所以也就不需要使用临时表。所以在包含UNION ALL子句的查询的执行计划中，就没有那个**id**为*NULL*的记录，如下所示：
```SQL
mysql> EXPLAIN SELECT * FROM s1  UNION ALL SELECT * FROM s2;
```
![性能分析工具的使用+20240312171646](https://raw.githubusercontent.com/loli0con/picgo/master/images/性能分析工具的使用+20240312171646.png+2024-03-12-17-16-47)

**小结**：
1. id如果相同，可以认为是一组，从上往下顺序执行。
2. 在所有组中，id值越大，优先级越高，越先执行。
3. 关注点：id号每个号码，表示一趟独立的查询，一个sql的查询趟数越少越好。

#### select_type
一条大的查询语句里边可以包含若干个SELECT关键字，**每个SELECT关键字代表着一个小的查询语句**，而每个SELECT关键字的FROM子句中都可以包含若干张表（这些表用来做查询连接），**每一张表都对应着执行计划输出中的一条记录**，对于在同一个SELECT关键字中的表来说，它们的**id**值是相同的。

MySQL为每一个SELECT关键字代表的小查询都定义了一个称之为**select_type**的属性，意思是我们只要知道了某个小查询的**select_type**属性，就知道了这个**小查询在整个大查询中扮演了一个什么角色**，**select_type**的取值如下：
|名称|描述|翻译|
|---|---|---|
|SIMPLE|Simple SELECT (not using UNION or subqueries)|简单查询（未使用UNION或子查询）|
|PRIMARY|Outermost SELECT|最外层的查询|
|UNION|Second or later SELECT statement in a UNION|在UNION查询中的第二个和随后的SELECT语句被标记为*UNION*|
|UNION RESULT|Result of a UNION|UNION的结果|
|SUBQUERY|First SELECT in subquery|子查询中的第一个SELECT|
|DEPENDENT SUBQUERY|First SELECT in subquery, dependent on outer query|子查询中的第一个SELECT，依赖了外层的查询|
|DEPENDENT UNION|Second or later SELECT statement in a UNION, dependent on outer query|UNION中的第二个或后面的查询，依赖了外层的查询|
|DERIVED|Derived table|在FROM列表中包含的子查询被标记为DERIVED(衍生)，MySQL会递归执行这些子查询，把结果放在临时表里|
|MATERIALIZED|Materialized subquery|物化子查询|
|UNCACHEABLE SUBQUERY|A subquery for which the result cannot be cached and must be re-evaluated for each row of the outer query|子查询，结果无法缓存，必须针对外部查询的每一行重新评估|
|UNCACHEABLE UNION|The second or later select in a UNION that belongs to an uncacheable subquery (see UNCACHEABLE SUBQUERY)|UNION中的第二个或后面的查询，无法被缓存|

##### SIMPLE
查询语句中不包含**UNION**或者子查询的查询都算作是**SIMPLE**类型，比如说下边这个单表查询的**select_type**的值就是**SIMPLE**：
```SQL
EXPLAIN SELECT * FROM s1;
```
![性能分析工具的使用+20240313114952](https://raw.githubusercontent.com/loli0con/picgo/master/images/性能分析工具的使用+20240313114952.png+2024-03-13-11-49-53)

当然，连接查询也算是**SIMPLE**类型，比如：
```SQL
EXPLAIN SELECT * FROM s1 INNER JOIN s2;
```
![性能分析工具的使用+20240313115040](https://raw.githubusercontent.com/loli0con/picgo/master/images/性能分析工具的使用+20240313115040.png+2024-03-13-11-50-40)

##### PRIMARY
对于包含**UNION**、**UNION ALL**或者子查询的大查询来说，它是由几个小查询组成的，其中最左边的那个查询的**select_type**就是**PRIMARY**，比方说：
```SQL
EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2;
```
![性能分析工具的使用+20240313115308](https://raw.githubusercontent.com/loli0con/picgo/master/images/性能分析工具的使用+20240313115308.png+2024-03-13-11-53-09)

从结果可以看到，最左边的小查询`SELECT * FROM s1`对应的是执行计划中的第一条，它的**select_type**值就是**PRIMARY**。

##### UNION
对于包含UNION或者UNION ALL的大查询来说，它是由几个小查询组成的，其中除了最左边的那个小查询以外，其余的小查询的select_type值就是UNION，具体可参考上面的[例子](#primary)。

##### UNION RESULT
MySQL选择使用临时表来完成UNION查询的去重工作，针对该临时表的查询的**select_type**就是**UNION RESULT**，具体可参考上面的[例子](#primary)。

##### SUBQUERY
如果包含子查询的查询语句不能够转为对应的**semi-join**的形式（即多表连接），并且该子查询不是相关子查询，并且查询优化器决定采用将该子查询物化的方案来执行该子查询时，该子查询的第一个**SELECT**关键字代表的那个查询的**select_tpye**就是**SUBQUERY**，比如下边这个查询：
```SQL
EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) OR key3 = 'a';
```
![性能分析工具的使用+20240313120031](https://raw.githubusercontent.com/loli0con/picgo/master/images/性能分析工具的使用+20240313120031.png+2024-03-13-12-00-32)

可以看到，外层查询的**select_type**就是**PRIMARY**，子查询的**select_type**就是**SUBQUERY**。需要注意的是，由于**select_type**为**SUBQUERY**的子查询会被物化，所以只需要执行一遍。

##### DEPENDENT SUBQUERY
如果包含子查询的查询语句不能够转为对应的**simi-join**的形式（即多表连接），并且该子查询时相关子查询，则该子查询的第一个**SELECT**关键字代表的那个查询的**select_type**就是**DEPENDENT SUBQUERY**，比如下边这个查询：
```SQL
EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2 WHERE s1.key2 = s2.key2) OR key3 = 'a';
```
![性能分析工具的使用+20240313120748](https://raw.githubusercontent.com/loli0con/picgo/master/images/性能分析工具的使用+20240313120748.png+2024-03-13-12-07-48)

需要注意的是，select_type为**DEPENDENT SUBQUERY**的查询可能会被执行多次。

##### DEPENDENT UNION
在包含**UNION**或者**UNION ALL**的大查询中，如果各个小查询都依赖于外层查询的话，除了最左边的那个小查询之外，其余的小查询的**select_type**的值就是**DEPENDENT UNION**。比如说下边这个查询：
```SQL
EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2 WHERE key1 = 'a' UNION SELECT key1 FROM s1 WHERE key1 = 'b');
```
![性能分析工具的使用+20240313121224](https://raw.githubusercontent.com/loli0con/picgo/master/images/性能分析工具的使用+20240313121224.png+2024-03-13-12-12-24)

这个查询比较复杂，大查询里包含了一个子查询，子查询里又是由**UNION**连起来的两个小查询。从执行计划中可以看出来，`SELECT key1 FROM s2 WEHRE key1 = 'a'`这个小查询由于是子查询中的第一个查询，所以它的**select_type**是**DEPENDENT SUBQUERY**，而`SELECT key1 FROM s1 WHERE key1 = 'b'`这个查询的**select_type**就是**DEPENDENT UNION**。

##### DERIVED
对于采用物化的方式执行包含派生表的查询，该派生表对应的子查询的**select_type**就是**DERIVED**，比方说下边这个查询：
```SQL
-- id为2的查询只会执行一遍，随后查询结果被物化为派生表derived_s1。
EXPLAIN SELECT * FROM (SELECT key1, count(*) as c FROM s1 GROUP BY key1) AS derived_s1 where c > 1;
```
![性能分析工具的使用+20240313121639](https://raw.githubusercontent.com/loli0con/picgo/master/images/性能分析工具的使用+20240313121639.png+2024-03-13-12-16-39)

从查询计划中可以看出，**id**为*2*的记录就代表子查询的执行方式，它的**select_type**是**DERIVED**，说明该子查询是以物化的方式执行的。**id**为*1*的记录代表外层查询，注意看的**table**列显示的是`<derived2>`，表示该查询是针对将派生表物化之后的表进行查询的。

##### MATERIALIZED
当查询优化器在执行包含子查询的语句时，选择将子查询物化之后与外层查询进行连接查询时，该子查询对应的**select_type**属性就是**MATERIALIZED**，比如下边这个查询：
```SQL
EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2);
```
![性能分析工具的使用+20240313122117](https://raw.githubusercontent.com/loli0con/picgo/master/images/性能分析工具的使用+20240313122117.png+2024-03-13-12-21-17)

执行计划的第三条记录的**id**值为*2*，说明该记录对应的是一个单表查询，从它的**select_type**为**MATERIALIZED**可以看出，查询优化器是要把子查询先转换成物化表。然后看执行计划的前两条记录的**id**值都为*1*，说明这两个记录对应的表进行连接查询，需注意的是第二条记录的**table**列的值是`<subquery2>`，说明该表其实就是**id**为*2*对应的子查询执行之后产生的物化表，然后将*s1*表和该物化表进行连接查询。

##### UNCACHEABLE SUBQUERY
不常用。

##### UNCACHEABLE UNION
不常用。

#### partitions
代表分区表的命中情况，非分区表，该项为**NULL**。一般情况下我们的查询语句的执行计划的**partitions**列的值都是**NULL**。

#### type
执行计划的一条记录就代表着MySQL对某个表的**执行查询时的访问方法**，又称“访问类型”，其中**type**列就表明了这个访问方法是啥，是较为重要的一个指标。比如看到**type**列的值是**ref**，表明MySQL即将使用**ref**访问方法来执行对*s1*表的查询。

完整的访问方法如下：
|从好到坏排序|枚举值|
|---|---|
|1|null|
|2|system|
|3|const|
|4|eq_ref|
|5|ref|
|6|fulltext|
|7|ref_or_null|
|8|index_merge|
|9|unique_subquery|
|10|index_subquery|
|11|range|
|12|index|
|13|ALL|

SQL性能优化的目标：至少要达到**range**级别，要求是**ref**级别，最好是**consts**级别。

##### null
MySQL能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引。如：
* 从系统库*mysql*的系统表*proxies_priv*里查询数据，这里的数据在MySQL服务启动时候已经加载在内存中，不需要进行磁盘IO。
* `select 1`。

##### system
当表中**只有一条记录**并且该表使用的存储引擎的统计数据是精确的，比如MyISAM、Memory，那么对该表的访问方法就是**system**。比如说我们新建一个MyISAM表，并为其插入一条记录。
```SQL
mysql> CREATE TABLE t(i int) Engine=MyISAM;
Query OK, 0 rows affected (0.05 sec)

mysql> INSERT INTO t VALUES(1);
Query OK, 1 row affected (0.01 sec)
```
然后我们看一下查询这个表的执行计划：
```SQL
mysql> EXPLAIN SELECT * FROM t;
```
![性能分析工具的使用+20240313133830](https://raw.githubusercontent.com/loli0con/picgo/master/images/性能分析工具的使用+20240313133830.png+2024-03-13-13-38-31)

可以看到**type**列的值就是**system**了。

##### const
当我们根据主键或者唯一二级索引列与常数进行等值匹配时，对单表的访问方法就是**const**，比如：
```SQL
EXPLAIN SELECT * FROM s1 WHERE id = 10005;
```
![性能分析工具的使用+20240313141238](https://raw.githubusercontent.com/loli0con/picgo/master/images/性能分析工具的使用+20240313141238.png+2024-03-13-14-12-39)

##### eq_ref
在连接查询时，如果被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问的（如果主键或唯一二级索引是联合索引的话，所有的索引列都必须进行等值比较），则对该被驱动表的访问方法就是**eq_ref**，比如说：
```SQL
EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.id = s2.id;
```
![性能分析工具的使用+20240313141642](https://raw.githubusercontent.com/loli0con/picgo/master/images/性能分析工具的使用+20240313141642.png+2024-03-13-14-16-42)

从执行计划的结果可以看出，MySQL打算将*s2*表作为驱动表，*s1*表作为被驱动表，重点关注*s1*表的访问方法是**eq_ref**，表明在访问s1表的时候可以**通过主键的等值匹配**来进行访问。

##### ref
当通过普通的二级索引列与某个常量进行等值匹配来查询某个表时，那么对该表的访问方法就可能是**ref**，比方说下边这个查询：
```SQL
EXPLAIN SELECT * FROM s1 WHERE key1 = 'a';
```
![性能分析工具的使用+20240313142127](https://raw.githubusercontent.com/loli0con/picgo/master/images/性能分析工具的使用+20240313142127.png+2024-03-13-14-21-27)

##### fulltext
全文索引

##### ref_or_null
当对普通二级索引进行等值匹配查询，该索引列的值也可能是*NULL*值时，那么对该表的访问方法就可能是**ref_or_null**，比如说：
```SQL
EXPLAIN SELECT * FROM s1 WHERE key1 = 'a' OR key1 IS NULL;
```
![性能分析工具的使用+20240313142333](https://raw.githubusercontent.com/loli0con/picgo/master/images/性能分析工具的使用+20240313142333.png+2024-03-13-14-23-33)

##### index_merge
一般情况下对于某个表的查询只能使用到一个索引，但单表访问方法时在某些场景下可以使用**Intersection**、**Union**、**Sort-Union**这三种索引合并的方式来执行查询。我们看一下执行计划中是怎么体现MySQL使用索引合并的方式来对某个表执行查询的：
```SQL
EXPLAIN SELECT * FROM s1 WHERE key1 = 'a' OR key3 = 'a';
```
![性能分析工具的使用+20240313142639](https://raw.githubusercontent.com/loli0con/picgo/master/images/性能分析工具的使用+20240313142639.png+2024-03-13-14-26-39)

从执行计划的**type**列的值是**index_merge**就可以看出，MySQL打算使用索引合并的方式来执行对*s1*表的查询。

##### unique_subquery
类似于两表连接中被驱动表的**eq_ref**访问方法，**unique_subquery**是针对在一些包含**IN**子查询的查询语句中，如果查询优化器决定将**IN**查询转化为**EXISTS**子查询，而且子查询可以使用到主键进行等值匹配的话，那么该子查询执行计划的**type**列的值就是**unique_subquery**，比如下边的这个查询语句：
```SQL
EXPLAIN SELECT * FROM s1 WHERE key2 IN (SELECT id FROM s2 where s1.key1 = s2.key1) OR key3 = 'a';
```
![性能分析工具的使用+20240313143030](https://raw.githubusercontent.com/loli0con/picgo/master/images/性能分析工具的使用+20240313143030.png+2024-03-13-14-30-31)

可以看到执行计划的第二条记录的**type**值就是**unique_subquery**，说明在执行子查询时会使用到**id**列的索引。

##### index_subquery
**index_subquery**与**unique_subquery**类似，只不过访问子查询中的表时使用的是普通的索引，比如这样：
```SQL
EXPLAIN SELECT * FROM s1 WHERE key2 IN (SELECT id FROM s2 where s1.key1 = s2.key1) OR key3 = 'a';
```
![性能分析工具的使用+20240313143356](https://raw.githubusercontent.com/loli0con/picgo/master/images/性能分析工具的使用+20240313143356.png+2024-03-13-14-33-57)

##### range
如果使用索引获取某些**范围区间**的记录，那么就可能使用到**range**访问方法，比如下边这个查询：
```SQL
EXPLAIN SELECT * FROM s1 WHERE key1 IN ('a', 'b', 'c');
```
![性能分析工具的使用+20240313143609](https://raw.githubusercontent.com/loli0con/picgo/master/images/性能分析工具的使用+20240313143609.png+2024-03-13-14-36-10)

或者：
```SQL
EXPLAIN SELECT * FROM s1 WHERE key1 > 'a' AND key1 < 'b';
```
![性能分析工具的使用+20240313143638](https://raw.githubusercontent.com/loli0con/picgo/master/images/性能分析工具的使用+20240313143638.png+2024-03-13-14-36-38)

##### index
当我们可以使用索引覆盖，但需要扫描全部的索引记录时，该表的访问方法就是**index**，比如这样：
```SQL
EXPLAIN SELECT key_part2 FROM s1 WHERE key_part3 = 'a';
```
![性能分析工具的使用+20240313144306](https://raw.githubusercontent.com/loli0con/picgo/master/images/性能分析工具的使用+20240313144306.png+2024-03-13-14-43-07)

上述查询中的搜索列表中只有*key_part2*一个列，而且搜索条件中也只有*key_part3*一个列，这两个列又恰好包含在*idx_key_part*这个索引中，可是搜索条件*key_part3*不能直接使用该索引进行**ref**或者**range**的方式访问，只能扫描整个*idx_key_part*索引的记录，所以查询计划的**type**列的值就是**index**。

对于使用InnoDB存储引擎的表来说，二级索引的记录只包含索引列和主键列的值，而聚簇索引中包含用户定义的全部列以及一些隐藏列，所以扫描二级索引的代价比直接全表扫描，也就是扫描聚簇索引的代价更低一些。

##### ALL
最熟悉的全表扫描，例子：
```SQL
EXPLAIN SELECT * FROM s1;
```
![性能分析工具的使用+20240313145009](https://raw.githubusercontent.com/loli0con/picgo/master/images/性能分析工具的使用+20240313145009.png+2024-03-13-14-50-09)

一般来说，这些访问方法中除了**ALL**这个访问方法外，其余的访问方法都用到索引，除了**index_merge**访问方法外，其余的访问方法都最多只能用到一个索引。

#### possible_keys和key
在EXPLAIN语句输出的执行计划中，**possible_keys**列表示在某个查询语句中，对某个表执行**单表查询时可能用到的索引**有哪些。一般查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用。**key**列表示**实际用到的索引**有哪些，如果为NULL，则没有使用索引。比方说下边这个查询：
```SQL
EXPLAIN SELECT * FROM s1 WHERE key1 > 'z' AND key3 = 'a';
```
![性能分析工具的使用+20240313145958](https://raw.githubusercontent.com/loli0con/picgo/master/images/性能分析工具的使用+20240313145958.png+2024-03-13-14-59-59)

上述执行计划的**possible_keys**列的值是`idx_key1,idx_key3`，表示该查询可能使用到*idx_key1*、*idx_key3*两个索引，然后**key**列的值是*idx_key3*，表示经过查询优化器计算使用不同索引的成本后，最后决定使用*idx_key3*来执行查询比较划算。

#### key_len
**key_len**表示实际使用到的索引长度（字节数），用于检查是否充分的利用上了索引，该值越大越好（与自身相比）。主要针对于联合索引，有一定的参考意义。

##### demo1
```SQL
EXPLAIN SELECT * FROM s1 WHERE id = 10005;
```
![性能分析工具的使用+20240313153313](https://raw.githubusercontent.com/loli0con/picgo/master/images/性能分析工具的使用+20240313153313.png+2024-03-13-15-33-14)

*id*是INT类型的主键（非空），存储INT类型需要使用4个字节，因此**key_len**为*4*。

##### demo2
```SQL
EXPLAIN SELECT * FROM s1 WHERE key2 = 10126;
```
![性能分析工具的使用+20240313153528](https://raw.githubusercontent.com/loli0con/picgo/master/images/性能分析工具的使用+20240313153528.png+2024-03-13-15-35-30)

*key2*为INT类型，有唯一性约束且可以为NULL（需要一个字节记录是否为空），因此**key_len**为*5*。

##### demo3
```SQL
EXPLAIN SELECT * FROM s1 WHERE key1 = 'a';
```
![性能分析工具的使用+20240313153828](https://raw.githubusercontent.com/loli0con/picgo/master/images/性能分析工具的使用+20240313153828.png+2024-03-13-15-38-29)

*key1*为VARCHAR(100)类型，该类型为UTF8（每个字符占用3个字节），该类型为变长类型（需要两个字节记录实际占用空间长度），该字段可以为空，所以**key_len**=*100*3+2+1*=*303*。

##### demo4
```SQL
EXPLAIN SELECT * FROM s1 WHERE key_part1 = 'a';
```
![性能分析工具的使用+20240313154241](https://raw.githubusercontent.com/loli0con/picgo/master/images/性能分析工具的使用+20240313154241.png+2024-03-13-15-42-41)
```SQL
EXPLAIN SELECT * FROM s1 WHERE key_part1 = 'a' AND key_part2 = 'b';
```
![性能分析工具的使用+20250211121252](https://raw.githubusercontent.com/loli0con/picgo/master/images/性能分析工具的使用+20250211121252.png+2025-02-11-12-12-53)

同样使用联合索引，前一个**key_len**是*303*，后一个**key_len**是*606*，此时即是“**key_len**值越大越好”的情况。**key_len**值大，意味着被检索出来的数据量小。


##### key_len的长度计算公式
1. `varchar(10)`变长字段且允许NULL，**key_len** = *10* * (字符集：utf8=*3*, gbk=*2*, latin1=*1*) + *2*(变长字段) + *1*(NULL)
2. `varchar(10)`变长字段且不允许NULL，**key_len** = *10* * (字符集：utf8=*3*, gbk=*2*, latin1=1*) + *2*(变长字段)
3. `char(10)`固定字段且允许NULL，**key_len** = *10* * (字符集：utf8=*3*, gbk=*2*, latin1=*1*) + *1*(NULL)
4. `char(10)`固定字段且不允许NULL，**key_len** = *10* * (字符集：utf8=*3*, gbk=*2*, latin1=*1*)

#### ref
当使用索引列等值匹配的条件区执行查询时，也就是在访问方法时**const**、**eq_ref**、**ref**、**ref_or_null**、**unique_subquery**、**index_subquery**其中之一时，**ref**列展示的就是与索引列作等值匹配的结构是什么，比如是一个常数或者是某个列。

该对象是一个常量：
```SQL
EXPLAIN SELECT * FROM s1 WHERE key1 = 'a';
```
![性能分析工具的使用+20240313155213](https://raw.githubusercontent.com/loli0con/picgo/master/images/性能分析工具的使用+20240313155213.png+2024-03-13-15-52-14)

该对象是某个列：
```SQL
EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.id = s2.id;
```
![性能分析工具的使用+20240313155239](https://raw.githubusercontent.com/loli0con/picgo/master/images/性能分析工具的使用+20240313155239.png+2024-03-13-15-52-40)

该对象是某个函数：
```SQL
EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s2.key1 = UPPER(s1.key1);
```
![性能分析工具的使用+20240313155258](https://raw.githubusercontent.com/loli0con/picgo/master/images/性能分析工具的使用+20240313155258.png+2024-03-13-15-52-59)

#### rows
**rows**表示预估需要读取的记录条数，该值越小越好。

#### filtered
**filtered**表示某个表经过搜索条件过滤后剩余记录条数的百分比。

如果使用的是索引执行的单表扫描，那么计算时需要估计出满足除**使用到对应索引的搜索条件**外**其他搜索条件**的记录有多少条：
```SQL
EXPLAIN SELECT * FROM s1 WHERE key1 > 'z' AND common_field = 'a';
-- 该查询使用到的索引为idx_key1，其他搜索条件为common_field，分析可知：
-- 大概有266条记录满足key1 > 'z'这个条件，这266条记录其中还有10%的记录同时满足common_field = 'a'这个条件
```
![性能分析工具的使用+20240313155852](https://raw.githubusercontent.com/loli0con/picgo/master/images/性能分析工具的使用+20240313155852.png+2024-03-13-15-58-53)

对于单表查询来说，这个**filtered**列的值没什么意义，我们更关注在连接查询中驱动表对应的执行计划记录的**filtered**值，它决定了被驱动表要执行的次数（即：**rows** * **filtered**）：
```SQL
EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.key1 = s2.key1 WHERE s1.common_field = 'a';
-- 驱动表rows为9688，即在9688记录其中还有10%的记录同时满足s1.common_field = 'a'这个条件
-- 因此，s1.key1 = s2.key1这个连表查询过程大概会执行9688*10%次
```
![性能分析工具的使用+20240313160457](https://raw.githubusercontent.com/loli0con/picgo/master/images/性能分析工具的使用+20240313160457.png+2024-03-13-16-04-58)


#### extra
顾名思义，**Extra**列是用来说明一些额外信息的，包含不适合在其他列中显示但十分重要的额外信息。我们可以通过这些额外信息来**更准确的理解MySQL到底将如何执行给定的查询语句**。

##### No tables used
当查询语句没有FROM子句时将会提示该额外信息，比如：
```SQL
EXPLAIN SELECT 1;
```
![性能分析工具的使用+20240313195058](https://raw.githubusercontent.com/loli0con/picgo/master/images/性能分析工具的使用+20240313195058.png+2024-03-13-19-50-59)

##### Impossible WHERE
查询语句的WHERE子句永远为*FALSE*时将会提示额外信息，比方说：
```SQL
EXPLAIN SELECT * FROM s1 WHERE 1 != 1;
```
![性能分析工具的使用+20240313195336](https://raw.githubusercontent.com/loli0con/picgo/master/images/性能分析工具的使用+20240313195336.png+2024-03-13-19-53-36)

##### Using where
当我们使用全表扫描来执行对某个表的查询，并且该语句的WHERE子句中有针对该表的搜索条件时，在**Extra**列中会提示上述额外信息。比如下边这个查询：
```SQL
EXPLAIN SELECT * FROM s1 WHERE common_field = 'a';
```
![性能分析工具的使用+20240313195800](https://raw.githubusercontent.com/loli0con/picgo/master/images/性能分析工具的使用+20240313195800.png+2024-03-13-19-58-01)

当使用索引访问来执行对某个表的查询，并且该语句的WHERE子句中有除了该索引包含的列之外的其他搜索条件时，在**Extra**列中也会提示上述额外信息。比如下边这个查询虽然使用*idx_key1*索引执行查询，但是搜索条件中除了包含*key1*的搜索条件`key = 'a'`，还包含*common_field*的搜索条件，所以**Extra**列会显示**Using where**的提示：
```SQL
EXPLAIN SELECT * FROM s1 WHERE key1 = 'a' AND common_field = 'a';
```
![性能分析工具的使用+20240313200649](https://raw.githubusercontent.com/loli0con/picgo/master/images/性能分析工具的使用+20240313200649.png+2024-03-13-20-06-49)

##### No matching min/max row
当查询列表处有MIN聚集函数或者MAX聚集函数，但是并没有符合WHERE子句中的搜索条件的记录时，将会提示该额外信息，比方说：
```SQL
EXPLAIN SELECT MIN(key1) FROM s1 WHERE key1 = 'abcdefg';
```
![性能分析工具的使用+20240313200812](https://raw.githubusercontent.com/loli0con/picgo/master/images/性能分析工具的使用+20240313200812.png+2024-03-13-20-08-13)

##### Using index
当我们的查询列表以及搜索条件中只包含属于某个索引的列，也就是在可以使用索引覆盖的情况下，在**Extra**列将会提示该额外信息。比方说下边这个查询中只需要用到*idx_key1*而不需要回表操作：
```SQL
EXPLAIN SELECT key1 FROM s1 WHERE key1 = 'a';
```
![性能分析工具的使用+20240313201144](https://raw.githubusercontent.com/loli0con/picgo/master/images/性能分析工具的使用+20240313201144.png+2024-03-13-20-11-44)

##### Using index condition
有些搜索条件中虽然出现了索引列，但却不能使用到索引，比如下边这个查询：
```SQL
SELECT * FROM s1 WHERE key1 > 'z' AND key1 LIKE '%a';
```
其中`key > 'z'`可以使用到索引，但是`key1 LIKE '%a'`却无法使用到索引，在以前版本的MySQL中，是按照下边步骤来执行这个查询的：
1. 先根据`key > 'z'`这个条件，从二级索引*idx_key1*中获取对应的二级索引记录。
2. 根据上一步骤得到的二级索引记录中的主键值进行**回表**，找到完整的用户记录再检测该记录是否符合`key1 LIKE '%a'`这个条件，将符合条件的记录加入到最后的结果集。

虽然`key1 LIKE '%a'`不能组成范围区间参与**range**访问方法的执行，但这个条件毕竟只涉及到了*key1*列，所以MySQL把上边的步骤改进了一下：
1. 先根据`key > 'z'`这个条件，定位到二级索引*idx_key1*中对应的二级索引记录。
2. 对于指定的二级索引记录，先不着急回表，而是先检测一下该记录是否满足`key1 LIKE '%a'`这个条件，如果这个条件不满足，则该二级索引记录压根儿就没必要回表。
3. 对于满足`key1 LIKE '%a'`这个条件的二级索引记录执行回表操作。

我们说回表操作其实是一个**随机IO**，比较耗时，所以上述修改虽然只改进了一点点，但是可以省去好多回表操作的成本。MySQL把他们的这个改进称之为**索引条件下推（Index Condition Pushdown）**。

如果在查询语句的执行过程中将要使用**索引条件下推**这个特性，在Extra列中将会显示**Using index condition**，比如这样：
```SQL
EXPLAIN SELECT * FROM s1 WHERE key1 > 'z' AND key1 LIKE '%b';
```
![性能分析工具的使用+20240313202226](https://raw.githubusercontent.com/loli0con/picgo/master/images/性能分析工具的使用+20240313202226.png+2024-03-13-20-22-26)


##### Using join buffer (Block Nested Loop)
在连接查询执行过程中，当被驱动表不能有效的利用索引加快访问速度，MySQL一般会为其分配一块名叫**join buffer**的内存快来加快查询速度，也就是我们所讲的**基于块的嵌套循环算法**，比如下边这个查询语句：
```SQL
EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.common_field = s2.common_field;
```
![性能分析工具的使用+20240313202539](https://raw.githubusercontent.com/loli0con/picgo/master/images/性能分析工具的使用+20240313202539.png+2024-03-13-20-25-39)

在对*s2*表的执行计划的Extra列显示了两个提示：
* **Using join buffer (Block Nested Loop)**：这是因为对*s2*表的访问不能有效利用索引，只好退而求其次，使用**join buffer**来减少对*s2*表的访问次数，从而提高性能。
* **Using where**：可以看到查询语句中有一个`s1.common_field = s2.common_field`条件，因为*s1*表是驱动表，*s2*表是被驱动表，所以在访问*s2*表时，`s1.common_field`的值就已经确定下来了，所以实际上查询*s2*表的条件就是`s2.common_field = 一个常数`，所以提示了**Using where**额外信息。


##### Not exists
当我们使用左（外）连接时，如果WHERE子句中包含要求被驱动表的某个列等于*NULL*值的搜索条件，而且那个列又是不允许存储*NULL*值的，那么在该表的执行计划的Extra列就会提示**Not exists**额外信息，比如这样：
```SQL
EXPLAIN SELECT * FROM s1 LEFT JOIN s2 ON s1.key1 = s2.key1 WHERE s2.id IS NULL;
```
![性能分析工具的使用+20240313203347](https://raw.githubusercontent.com/loli0con/picgo/master/images/性能分析工具的使用+20240313203347.png+2024-03-13-20-33-47)

上述查询中*s1*表是驱动表，*s2*表是被驱动表，`s2.id`列是不允许存储*NULL*值的，而WHERE子句中又包含`s2.id IS NULL`的搜索条件，这意味着必定是驱动表的记录在被驱动表中找不到匹配ON子句条件的记录才会把该驱动表的记录加入到最终的结果集，所以对于某条驱动表中的记录来说，如果能在被驱动表中找到1条符合ON子句条件的记录，那么该驱动表的记录就不会被加入到最终的结果集，也就是说我们没有必要到被驱动表中找到全部符合ON子句条件的记录，这样可以稍微节省一点性能。

右（外）连接可以被转换为左（外）连接，所以就不提右（外）连接的情况了。

##### Using intersect(...) 、 Using union(...) 和 Using sort_union(...)
如果执行计划的**Extra**列出现了`Using intersect(...)`的提示，说明准备使用**Intersect索引合并**的方式执行查询，括号中的`...`表示需要进行索引合并的索引名称；如果出现了`Using union(...)`提示，说明准备使用**union索引合并**的方式执行查询；出现了`Using sort_union(...)`提示，说明准备使用**Sort-Union索引合并**的方式执行查询。比如这个查询的执行计划：
```SQL
EXPLAIN SELECT * FROM s1 WHERE key1 = 'a' OR key3 = 'a';
```
![性能分析工具的使用+20240313204145](https://raw.githubusercontent.com/loli0con/picgo/master/images/性能分析工具的使用+20240313204145.png+2024-03-13-20-41-46)

其中**Extra**列就显示了`Using union(idx_key3,idx_key1)`，表明MySQL即将使用*idx_key3*和*idx_key1*这两个索引进行**union索引合并**的方式执行查询。


##### Zero limit
当我们的LIMIT子句的参数为*0*时，表示压根儿不打算从表中读出任何记录，将会提示该额外信息，比如这样：
```SQL
EXPLAIN SELECT * FROM s1 LIMIT 0;
```
![性能分析工具的使用+20240313204523](https://raw.githubusercontent.com/loli0con/picgo/master/images/性能分析工具的使用+20240313204523.png+2024-03-13-20-45-23)


##### Using filesort
有一些情况下对结果集中的记录进行排序是可以使用到索引的，比如下边这个查询：
```SQL
EXPLAIN SELECT * FROM s1 ORDER BY key1 LIMIT 10;
```
![性能分析工具的使用+20240313204631](https://raw.githubusercontent.com/loli0con/picgo/master/images/性能分析工具的使用+20240313204631.png+2024-03-13-20-46-32)

这个查询语句可以利用*idx_key1*索引直接取出*key1*列的*10*条记录，然后再进行回表操作就好了。但是很多情况下排序操作无法使用到索引，只能在内存中（记录较少的时候）或者磁盘中（记录较多的时候）进行排序，MySQL把这种在内存中或者磁盘上进行排序的方式统称为**文件排序（filesort）**。如果某个查询需要使用文件排序的方式执行查询，就会在执行计划的**Extra**列中显示**Using filesort**提示，比如这样：
```SQL
EXPLAIN SELECT * FROM s1 ORDER BY common_field LIMIT 10;
```
![性能分析工具的使用+20240313205007](https://raw.githubusercontent.com/loli0con/picgo/master/images/性能分析工具的使用+20240313205007.png+2024-03-13-20-50-08)

需要注意的是，如果查询中需要使用**filesort**的方式进行排序的记录非常多，那么这个过程是很耗费性能的，我们最好想办法**将使用文件排序的执行方式改为使用索引进行排序**。

##### Using temporary
在许多查询的执行过程中，MySQL可能会借助临时表来完成一些功能，比如去重、排序之类的，比如我们在执行许多包含DISTINCT、GROUP BY、UNION等子句的查询过程中，如果不能有效利用索引来完成查询，MySQL很有可能寻求通过建立内部的临时表来执行查询。比如查询中使用到了内部的临时表，在执行计划的**Extra**列将会显示**Using temporary**提示，比方说这样：
```SQL
EXPLAIN SELECT DISTINCT common_field FROM s1;
```
![性能分析工具的使用+20240313205650](https://raw.githubusercontent.com/loli0con/picgo/master/images/性能分析工具的使用+20240313205650.png+2024-03-13-20-56-50)

再比如：
```SQL
EXPLAIN SELECT common_field, COUNT(*) AS amount FROM s1 GROUP BY common_field;
```
![性能分析工具的使用+20240313205752](https://raw.githubusercontent.com/loli0con/picgo/master/images/性能分析工具的使用+20240313205752.png+2024-03-13-20-57-52)

执行计划中出现**Using temporary**并不是一个好的征兆，因为建立与维护临时表要付出很大的成本，所以我们**最好能使用索引来替代掉使用临时表**，比如说下边这个包*GROUP BY子句的查询就不需要使用临时表：
```SQL
EXPLAIN SELECT key1, COUNT(*) AS amount FROM s1 GROUP BY key1;
```
![性能分析工具的使用+20240313205945](https://raw.githubusercontent.com/loli0con/picgo/master/images/性能分析工具的使用+20240313205945.png+2024-03-13-20-59-46)

从**Extra**的**Using index**的提示里我们可以看出，上述查询只需要扫描*idx_key1*索引就可以搞定了，不再需要临时表了。

##### 总结
* EXPLAIN不考虑各种Cache
* EXPLAIN不能显示MySQL在执行查询时所作的优化工作
* EXPLAIN不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况
* 部分统计信息是估算的，并非精确值


### EXPLAIN四种输出格式
EXPLAIN可以输出四种格式：**传统格式**，**JSON格式**，**TREE格式**以及**可视化输出**。用户可以根据需要选择适用于自己的格式。

#### 传统格式
传统格式简单明了，输出是一个表格形式，概要说明查询计划。
```SQL
EXPLAIN SELECT s1.key1, s2.key1 FROM s1 LEFT JOIN s2 ON s1.key1 = s2.key1 WHERE s2.common_field IS NOT NULL;
```
![性能分析工具的使用+20240314121848](https://raw.githubusercontent.com/loli0con/picgo/master/images/性能分析工具的使用+20240314121848.png+2024-03-14-12-18-48)

#### JSON格式
传统格式中介绍的**EXPLAIN**语句输出中缺少了一个衡量执行计划好坏的重要属性——**成本**。而JSON格式是四种格式里面输出**信息最详尽**的格式，里面包含了执行的成本信息。在EXPLAIN单词和真正的查询语句中间加上`FORMAT=JSON`：
```SQL
EXPLAIN FORMAT=JSON SELECT ...
```

EXPLAIN的Column与JSON对应关系：
|Column|JSON Name|Meaning|
|---|---|---|
|**id**|select_id|The SELECT identifier|
|select_type|None|The SELECT type|
|table|table_name|The table for tht output row|
|partitions|partitions|The matching partitions|
|**type**|access_type|The join type|
|possible_keys|possible_keys|The possible indexes to choose|
|key|key|The index actually chosen|
|**key_len**|key_length|The length of the chosen key|
|**ref**|ref|The comlumns compared to the index|
|rows|rows|Estimate of rows to be examined|
|filtered|filtered|Percentage of rows filtered by table condition|
|**Extra**|None|Additional information|

这样我们就可以得到一个json格式的执行计划，里面包含该计划花费的成本，比如这样：
```SQL
EXPLAIN FORMAT=JSON SELECT * FROM s1 INNER JOIN s2 ON s1.key1 = s2.key2 WHERE s1.common_field = 'a'\G;

EXPLAIN: {
  "query_block": {
    "select_id": 1,  -- 整个查询语句只有1个SELECT关键字，该关键字对应的id号为1
    "cost_info":{
      "query_cost": "1360.08"  -- 整个查询的执行成本预计为1360.08
    },
    "nested_loop": [  -- 几个表之间采用嵌套循环连接算法执行
    -- 以下是参与嵌套循环连接算法的各个表的信息
      {
        "table": {
          "table_name": "s1",  -- s1表是驱动表
          "access_type": "ALL",  -- 访问方法为ALL，意味着使用全表扫描访问
          "possible_keys": [  -- 可能使用的索引
            "idx_key1"
          ],
          "row_examined_per_scan": 9895,  -- 查询一次s1表大致需要扫描9895条记录
          "row_produced_per_join": 989,  -- 驱动表s1的扇出是989
          "filtered": "10.00",  -- condition filtering代表的百分比
          "cost_info":{
            "read_cost": "914.80",  -- 稍后解释
            "eval_cost": "98.95",  -- 稍后解释
            "prefix_cost": "1013.75",  -- 单次查询s1表总共的成本
            "data_read_per_join": "1M"  -- 读取的数据量
          },
          "used_columns": [  -- 执行查询中涉及到的列
            "id",
            "key1",
            "key2",
            "key3",
            "key_part1",
            "key_part2",
            "key_part3",
            "common_field"
          ],
          -- 对s1表访问时针对单表查询的条件
          "attached_condition": "((`atguigudb1`.`s1`.`common_field` = 'a') and (`atguigudb1`.`s1`.'k1' is not null))"
        }
      },
      {
        "table": {
          "table_name": "s2",  -- s2表是被驱动表
          "access_type": "eq_ref", -- 访问方法为eq_ref，意味着使用唯一索引等值匹配的方式访问
          "possible_keys": [  -- 可能使用的索引
            "idx_key2"
          ],
          "key": "idx_key2",  -- 实际使用的索引
          "used_key_parts":[  -- 使用到的索引列
            "key2"
          ],
          "key_length": "5",  -- key_len
          "ref": [  -- 与key2列进行等值匹配的对象
            "atguigudb1.s1.key1"
          ],
          "row_examined_per_scan": 1,  -- 查询一次s2表大致需要扫描1条记录
          "row_produced_per_join": 968,  -- 被驱动表s2的扇出是968（由于后边没有多余的表进行连接，所以这个值也没啥用）
          "filtered": "100.00",  -- condition filtering代表的百分比
          -- s2表使用索引进行查询的搜索条件
          "index_condition": "(cast(`atguigudb1`.`s1`.`key1` as double) = cast(`atguigudb1`.`s2`.`key2` as double))",
          "cost_info":{
            "read_cost": "247.38",  -- 稍后解释
            "eval_cost": "98.95",  -- 稍后解释
            "prefix_cost": "1360.08",  -- 单次查询s1、多次查询s2表总共的成本 
            "data_read_per_join": "1M"  -- 读取的数据量
          },
          "used_columns": [  -- 执行查询中涉及到的列
            "id",
            "key1",
            "key2",
            "key3",
            "key_part1",
            "key_part2",
            "key_part3",
            "common_field"
          ]
        }
      }
    ]
  }
}
```

我们使用`--`后边跟随注释的形式为大家解释了`EXPLAIN FORMAT=JSON`语句的输出内容，但是大家可能有疑问`"cost_info"`里边的成本看着怪怪的，它们是怎么计算出来的？先看*s1*表的`"cost_info"`部分：
```JSON
"cost_info": {
    "read_cost": "914.80",
    "eval_cost": "98.95",
    "prefix_cost": "1013.75",
    "data_read_per_join": "1M"
}
```
* **read_cost**是由下边这两部分组成的: 
  * IO成本
  * 检测`rows × (1 - filter)`条记录的CPU成本（不是被定位到的数据，但是依然会被查询出来并进行检测是否满足查询条件）
* **eval_cost**是这样计算的:
  * 检测`rows × filter`条记录的成本
* **prefix_cost**就是单独查询*s1*表的成本，也就是:
  * `read_cost + eval_cost`
* **data_read_per_join**表示在此次查询中需要读取的数据量

对于*s2*表的`"cost_info"`部分是这样的:
```JSON
"cost_info": {
    "read_cost": "247.38",
    "eval_cost": "98.95",
    "prefix_cost": "1360.08",
    "data_read_per_join": "1M"
}
```
由于*s2*表是被驱动表，所以可能被读取多次，这里的**read_cost**和 **eval_cost**是访问多次*s2*表后累加起来的值，大家主要关注里边儿的**prefix_cost**的值代表的是整个连接查询预计的成本，也就是单次查询*s1*表和多次查询*s2*表后的成本的和，也就是：`247.38 + 98.95 + 1013.75 = 1360.08`。

#### TREE格式
TREE格式是8.0.16版本之后引入的新格式，主要根据查询的**各个部分之间的关系**和**各部分的执行顺序**来描述如何查询。
```SQL
mysql> EXPLAIN FORMAT=tree SELECT * FROM s1 INNER JOIN s2 ON s1.key1 = s2.key2 WHERE s1.common_field = 'a'\G

*************************** 1. row ***************************
EXPLAIN: -> Nested loop inner join  (cost=1360.08 rows=990)
    -> Filter: ((s1.common_field = 'a') and (s1.key1 is not null))  (cost=1013.75 rows=990)
        -> Table scan on s1  (cost=1013.75 rows=9895)
    -> Single-row index lookup on s2 using idx_key2 (key2=s1.key1), with index condition: (cast(s1.key1 as double) = cast(s2.key2 as double))  (cost=0.25 rows=1)

1 row in set, 1 warning (0.00 sec)
```

#### 可视化输出
可视化输出，可以通过MySQL Workbench可视化查看MySQL的执行计划。通过点击Workbench的放大镜图标，即可生成可视化的查询计划。

![性能分析工具的使用+20240314134900](https://raw.githubusercontent.com/loli0con/picgo/master/images/性能分析工具的使用+20240314134900.png+2024-03-14-13-49-02)

上图按从左到右的连接顺序显示表。红色框表示**全表扫描**，而绿色框表示使用**索引查找**。对于每个表，显示使用的索引。还要注意的是，每个表格的框上方是每个表访问所发现的行数的估计值以及访问该表的成本。

### SHOW WARNINGS的使用
在我们使用EXPLAIN语句查看某个查询的执行计划后，紧接着还可以使用**SHOW WARNINGS**语句查看与这个查询的执行计划有关一些拓展信息，比如这样：
```SQL
EXPLAIN SELECT s1.key1, s2.key1 FROM s1 LEFT JOIN s2 ON s1.key1 = s2.key1 WHERE s2.common_field IS NOT NULL;
```
![性能分析工具的使用+20240314135232](https://raw.githubusercontent.com/loli0con/picgo/master/images/性能分析工具的使用+20240314135232.png+2024-03-14-13-52-33)
```SQL
SHOW WARNINGS\G
*************************** 1. row ***************************
  Level: Note
   Code: 1003
Message: /* select#1 */ select `atguigu`.`s1`.`key1` AS `key1`,`atguigu`.`s2`.`key1`
AS `key1` from `atguigu`.`s1` join `atguigu`.`s2` where ((`atguigu`.`s1`.`key1` =
`atguigu`.`s2`.`key1`) and (`atguigu`.`s2`.`common_field` is not null))
1 row in set (0.00 sec)
```
大家可以看到**SHOW WARNINGS**展示出来的信息有三个字段，分别是**Level**、**Code**、**Message**。我们最常见的就是**Code**为*1003*的信息，当**Code**值为*1003*时，**Message**字段展示的信息类似于查询优化器将我们的查询语句重写后的语句。比如我们上边的查询本来是一个左（外）连接查询，但是有一个`s2.common_field IS NOT NULL`的条件，这就会导致查询优化器把左（外）连接查询优化为内连接查询，从**SHOW WARNINGS**的**Message**字段也可以看出来，原本的LEFT JOIN已经变成了JOIN。


## 分析优化器执行计划:trace
**OPTIMIZER_TRACE**是MySQL5.6引入的一项跟踪功能，它可以跟踪优化器做出的各种决策（比如访问表的方法、各种开销计算、各种转换等），并将跟踪结果记录到**INFORMATION_SCHEMA.OPTIMIZER_TRACE**表中。

此功能默认关闭。开启trace，并设置格式为JSON，同时设置trace最大能够使用的内存大小，避免解析过程中因为默认内存过小而不能够完整展示：
```SQL
SET optimizer_trace="enabled=on",end_markers_in_json=on;
set optimizer_trace_max_mem_size=1000000;
```

开启后，可分析如下语句：
* SELECT
* INSERT
* REPLACE
* UPDATE
* DELETE
* EXPLAIN
* SET
* DECLARE
* CASE
* IF
* RETURN
* CALL

执行如下SQL语句：
```SQL
select * from student where id < 10;
```
查询**information_schema.optimizer_trace**就可以知道MySQL是如何执行SQL的：
```SQL
select * from information_schema.optimizer_trace\G;

*************************** 1. row ***************************
  //第1部分:查询语句
  QUERY: select * from student where id < 10
  //第2部分:QUERY字段对应语句的跟踪信息
  TRACE: {
  "steps": [
    {
      "join_preparation": { //预备工作
        "select#": 1,
        "steps": [
          {
            "expanded_query": "/* select#1 */ select `student`.`id` AS `id`,`student`.`stuno` AS `stuno`,`student`.`name` AS `name`,`student`.`age` AS `age`,`student`.`classId` AS `classId` from `student` where (`student`.`id` < 10)"
          }
        ] /* steps */
      } /* join_preparation */
    },
    {
      "join_optimization": { //进行优化
        "select#": 1,
        "steps": [
          {
            "condition_processing": { //条件处理
              "condition": "WHERE",
              "original_condition": "(`student`.`id` < 10)",
              "steps": [
                {
                  "transformation": "equality_propagation",
                  "resulting_condition": "(`student`.`id` < 10)"
                },
                {
                  "transformation": "constant_propagation",
                  "resulting_condition": "(`student`.`id` < 10)"
                },
                {
                  "transformation": "trivial_condition_removal",
                  "resulting_condition": "(`student`.`id` < 10)"
                }
              ] /* steps */
            } /* condition_processing */
          },
          {
            "substitute_generated_columns": { //替换生成的列
            } /* substitute_generated_columns */
          },
          {
            "table_dependencies": [ //表的依赖关系
              {
                "table": "`student`",
                "row_may_be_null": false,
                "map_bit": 0,
                "depends_on_map_bits": [] /* depends_on_map_bits */
              }
            ] /* table_dependencies */
          },
          {
            "ref_optimizer_key_uses": [ //使用键
            ] /* ref_optimizer_key_uses */
          },
          {
            "rows_estimation": [ //行判断
              {
                "table": "`student`",
                "range_analysis": {
                  "table_scan": {
                    "rows": 3973767,
                    "cost": 408558
                  } /* table_scan */, //扫描表
                  "potential_range_indexes": [ //潜在的范围索引
                    {
                      "index": "PRIMARY",
                      "usable": true,
                      "key_parts": [
                        "id"
                      ] /* key_parts */
                    }
                  ] /* potential_range_indexes */,
                  "setup_range_conditions": [ //设置范围条件 
                  ] /* setup_range_conditions */,
                  "group_index_range": {
                    "chosen": false,
                    "cause": "not_group_by_or_distinct"
                  } /* group_index_range */,
                  "skip_scan_range": {
                    "potential_skip_scan_indexes": [
                      {
                        "index": "PRIMARY",
                        "usable": false,
                        "cause": "query_references_nonkey_column"
                      }
                    ] /* potential_skip_scan_indexes */
                  } /* skip_scan_range */,
                  "analyzing_range_alternatives": { //分析范围选项
                    "range_scan_alternatives": [
                      {
                        "index": "PRIMARY",
                        "ranges": [
                          "id < 10"
                        ] /* ranges */,
                        "index_dives_for_eq_ranges": true,
                        "rowid_ordered": true,
                        "using_mrr": false,
                        "index_only": false,
                        "rows": 9,
                        "cost": 1.91986,
                        "chosen": true
                      }
                    ] /* range_scan_alternatives */,
                    "analyzing_roworder_intersect": {
                      "usable": false,
                      "cause": "too_few_roworder_scans"
                    } /* analyzing_roworder_intersect */
                  } /* analyzing_range_alternatives */,
                  "chosen_range_access_summary": {
                    "range_access_plan": {
                      "type": "range_scan",
                      "index": "PRIMARY",
                      "rows": 9,
                      "ranges": [
                        "id < 10"
                      ] /* ranges */
                    } /* range_access_plan */,
                    "rows_for_plan": 9,
                    "cost_for_plan": 1.91986,
                    "chosen": true
                  } /* chosen_range_access_summary */
                } /* range_analysis */
              }
            ] /* rows_estimation */
          },
          {
            "considered_execution_plans": [ //考虑执行计划
              {
                "plan_prefix": [
                ] /* plan_prefix */,
                "table": "`student`",
                "best_access_path": { //最佳访问路径
                  "considered_access_paths": [
                    {
                      "rows_to_scan": 9,
                      "access_type": "range",
                      "range_details": {
                        "used_index": "PRIMARY"
                      } /* range_details */,
                      "resulting_rows": 9,
                      "cost": 2.81986,
                      "chosen": true
                    }
                  ] /* considered_access_paths */
                } /* best_access_path */,
                "condition_filtering_pct": 100, //行过滤百分比
                "rows_for_plan": 9,
                "cost_for_plan": 2.81986,
                //行过滤百分比
                "chosen": true
              }
            ] /* considered_execution_plans */
          },
          {
            "attaching_conditions_to_tables": { //将条件附加到表上
              "original_condition": "(`student`.`id` < 10)",
              "attached_conditions_computation": [
              ] /* attached_conditions_computation */,
              "attached_conditions_summary": [ //附加条件概要
                {
                  "table": "`student`",
                  "attached": "(`student`.`id` < 10)"
                }
              ] /* attached_conditions_summary */
            } /* attaching_conditions_to_tables */
          },
          {
            "finalizing_table_conditions": [
              {
                "table": "`student`",
                "original_table_condition": "(`student`.`id` < 10)",
                "final_table_condition   ": "(`student`.`id` < 10)"
              }
            ] /* finalizing_table_conditions */
          },
          {
            "refine_plan": [ //精简计划 
              {
                "table": "`student`"
              }
            ] /* refine_plan */
          }
        ] /* steps */
      } /* join_optimization */
    },
    {
      "join_execution": { //执行
        "select#": 1,
        "steps": [
        ] /* steps */
      } /* join_execution */
    }
  ] /* steps */
}
//第3部分:跟踪信息过长时，被截断的跟踪信息的字节数。
MISSING_BYTES_BEYOND_MAX_MEM_SIZE: 0 //丢失的超出最大容量的字节
//第4部分:执行跟踪语句的用户是否有查看对象的权限。当不具有权限时，该列信息为1且TRACE字段为空，一般在调用带有SQL SECURITY DEFINER的视图或者是存储过程的情况下，会出现此问题。
INSUFFICIENT_PRIVILEGES: 0 //缺失权限
1 row in set (0.00 sec)
```

## MySQL监控分析视图-sys schema
关于MySQL的性能监控和问题诊断，我们一般都从*performance_schema*中获取想要的数据，在MySQL5.7.7版本中新增*sys schema*，它将*performance_schema*和*information_schema*中的数据以更容易理解的方式总结归纳为“试图”，其目的就是为了**降低查询performance_schema的复杂度**，让DBA能快速的定位问题。

### Sys schema视图摘要
1. 主机相关: 以host_summary开头，主要汇总了IO延迟的信息。
2. Innodb相关: 以innodb开头，汇总了innodb buffer信息和事务等待innodb锁的信息。
3. I/O相关: 以io开头，汇总了等待I/O、I/O使用量情况。
4. 内存使用情况: 以memory开头，从主机、线程、事件等角度展示内存的使用情况
5. 连接与会话信息: processlist和session相关视图，总结了会话相关信息。
6. 表相关: 以schema_table开头的视图，展示了表的统计信息。
7. 索引信息: 统计了索引的使用情况，包含冗余索引和未使用的索引情况。
8. 语句相关: 以statement开头，包含执行全表扫描、使用临时表、排序等的语句信息。
9. 用户相关: 以user开头的视图，统计了用户使用的文件I/O、执行语句统计信息。
10. 等待事件相关信息: 以wait开头，展示等待事件的延迟情况。

### Sys schema视图使用场景

#### 索引情况
```SQL
-- 1. 查询冗余索引
select * from sys.schema_redundant_indexes;

-- 2. 查询未使用过的索引
select * from sys.schema_unused_indexes;

-- 3. 查询索引的使用情况
select index_name,rows_selected,rows_inserted,rows_updated,rows_deleted from sys.schema_index_statistics where table_schema='dbname' ;
```

#### 表相关
```SQL
-- 1. 查询表的访问量
select table_schema,table_name,sum(io_read_requests+io_write_requests) as io from sys.schema_table_statistics group by table_schema,table_name order by io desc;

-- 2. 查询占用bufferpool较多的表
select object_schema,object_name,allocated,data from sys.innodb_buffer_stats_by_table order by allocated limit 10;

-- 3. 查看表的全表扫描情况
select * from sys.statements_with_full_table_scans where db='dbname';
```

#### 语句相关
```SQL
-- 1. 监控SQL执行的频率
select db,exec_count,query from sys.statement_analysis order by exec_count desc;

-- 2. 监控使用了排序的SQL
select db,exec_count,first_seen,last_seen,query from sys.statements_with_sorting limit 1;

-- 3. 监控使用了临时表或者磁盘临时表的SQL
select db,exec_count,tmp_tables,tmp_disk_tables,query from sys.statement_analysis where tmp_tables>0 or tmp_disk_tables >0 order by (tmp_tables+tmp_disk_tables) desc;
```

#### IO相关
```SQL
-- 1. 查看消耗磁盘IO的文件
select file,avg_read,avg_write,avg_read+avg_write as avg_io from sys.io_global_by_file_by_bytes order by avg_read limit 10;
```

#### Innodb 相关
```SQL
-- 1. 行锁阻塞情况
select * from sys.innodb_lock_waits;
```

### 风险提示
通过sys库去查询时，MySQL会消耗大量资源去收集相关信息，严重的可能会导致业务请求被阻塞，从而引起故障。建议生产上不要频繁的去查询sys或者performance_schema、information_schema来完成监控、巡检等工作。