# UNIX 内存API

UNIX操作系统的内存分配接口非常简洁。在UNIX/C程序中，分配和管理内存是构建健壮和可靠软件的重要基础。

## 内存类型

在运行一个C程序的时候，会分配两种类型的内存。

第一种称为栈内存，它的申请和释放操作是编译器来隐式管理的，所以有时也称为自动（automatic）内存。C中申请栈内存很容易。比如，假设需要在func()函数中为一个整形变量x申请空间。为了声明这样的一块内存，只需要这样做：

```c
void func() {
    int x; // declares an integer on the stack
    ...
}
```

编译器完成剩下的事情，确保在你进入func()函数的时候，在栈上开辟空间。当你从该函数退出时，编译器释放内存。因此，如果你希望某些信息存在于函数调用之外，建议不要将它们放在栈上。

第二种称为堆（heap）内存，它所有的申请和释放操作都由程序员显式地完成。下面的例子展示了如何在堆上分配一个整数，得到指向它的指针：

```c
void func() {
    int *x = (int *) malloc(sizeof(int));
    ...
}
```

栈和堆的分配都发生在这一行。首先编译器看到指针的声明（int * x）时，知道为一个整型指针分配空间，随后，当程序调用malloc()时，它会在堆上请求整数的空间，函数返回这样一个整数的地址（成功时，失败时则返回NULL），然后将其存储在栈中以供程序使用。

## malloc()调用

malloc函数非常简单：传入要申请的堆空间的大小，它成功就返回一个指向新申请空间的指针，失败就返回NULL。

malloc只需要一个size_t类型参数，该参数表示你需要多少个字节。然而，大多数程序员并不会直接传入数字，替代方案是使用各种函数和宏。

malloc()返回一个指向void类型的指针。这样做只是C中传回地址的方式，让程序员决定如何处理它。

## free()调用

要释放不再使用的堆内存，程序员只需调用free()。该函数接受一个参数，即一个由malloc()返回的指针。分配区域的大小不会被用户传入，必须由内存分配库本身记录追踪。

## 常见错误

### 忘记分配内存

许多例程在调用之前，都希望你为它们分配内存。例如，例程strcpy(dst, src)将源字符串中的字符串复制到目标指针。但是，如果不小心，你可能会这样做：

```c
char *src = "hello";
char *dst;        // oops! unallocated
strcpy(dst, src); // segfault and die
```

运行这段代码时，可能会导致段错误（segmentation fault）。

### 没有分配足够的内存

另一个相关的错误是没有分配足够的内存，有时称为缓冲区溢出（buffer overflow）。在上面的例子中，一个常见的错误是为目标缓冲区留出“几乎”足够的空间。

```c
char *src = "hello";
char *dst = (char *) malloc(strlen(src)); // too small!
strcpy(dst, src); // work properly
```

奇怪的是，这个程序通常看起来会正确运行，这取决于如何实现malloc和许多其他细节。在某些情况下，当字符串拷贝执行时，它会在超过分配空间的末尾处写入一个字节，但在某些情况下，这是无害的，可能会覆盖不再使用的变量。在某些情况下，这些溢出可能具有令人难以置信的危害，实实上是系统中许多安全漏洞的来源。在其他情况下，malloc库总是分配一些额外的空间，因此你的程序实实上不会在其他某个变量的值上涂写，并且工作得很好。还有一些情况下，该程序确实会发生故障和崩溃。

### 忘记初始化分配的内存

在这个错误中，你正确地调用malloc()，但忘记在新分配的数据类型中填写一些值。如果你忘记了，你的程序最终会遇到未初始化的读取（uninitialized read），它从堆中读取了一些未知值的数据。如果走运，读到的值使程序仍然有效（例如，零）。如果不走运，会读到一些随机和有害的东西。

### 忘记释放内存

另一个常见错误称为内存泄露（memory leak），如果忘记释放内存，就会发生。在长时间运行的应用程序或系统（如操作系统本身）中，这是一个巨大的问题，因为缓慢泄露的内存会导致内存不足，此时需要重新启动。因此，一般来说，当你用完一段内存时，应该确保释放它。

在某些情况下，不调用free()似乎是合理的。例如，你的程序运行时间很短，很但就会退出。在这种情况下，当进程死亡时，操作系统将清理其分配的所有页面，因此不会发生内存泄露。

#### 两级内存管理

系统中实际存在两级内存管理：

* 第一级是由操作系统执行的内存管理，操作系统在进程运行时将内存交给进程，并在进程退出（或以其他方式结束）时将其回收。
* 第二级管理在每个进程中，例如在调用malloc()和free()时，在堆内管理。即使你没有调用free()（并因此泄露了堆中的内存），操作系统也会在程序结束运行时，收回进程的所有内存（包括用于代码、栈，以及相关堆的内存页）。无论地址空间中堆的状态如何，操作系统都会在进程终止时收回所有这些页面，从而确保即使没有释放内存，也不会丢失内存。

因此，对于短时间运行的程序，泄露内存通常不会导致任何操作问题（尽管它可能被认为是不好的形式）。如果你编写一个长期运行的服务器（例如 Web 服务器或数据库管理系统，它永远不会退出），泄露内存就是很大的问题，最终会导致应用程序在内存不足时崩溃。

### 在用完之前释放内存

有时候程序会在用完之前释放内存，这种错误称为悬挂指针（dangling pointer）。随后的使用可能会导致程序崩溃或覆盖有效的内存（例如，你调用了free()，但随后再次调用malloc()来分配其他内容，这重新利用了错误释放的内存）。

### 反复释放内存

程序有时还会不止一次地释放内存，这被称为重复释放（double free）。这样做的结果是未定义的。正如你所能想象的那样，内存分配库可能会感到困惑，并且会做各种奇怪的事情，崩溃是常见的结果。

### 错误地调用free()

我们讨论的最后一个问题是free()的调用错误。毕竟，free()期望你只传入之前从malloc()得到的一个指针。如果传入一些其他的值，坏事就可能发生（并且会发生）。

## 底层操作系统支持

malloc()和free()不是系统调用，而是库调用。因此，malloc库管理虚拟地址空间内的空间，但是它本身是建立在一些系统调用之上的，这些系统调用会进入操作系统，来请求本多内存或者将一些内容释放回系统。

一个这样的系统调用叫作brk，它被用来改变程序分断（break）的位置：堆结束的位置。它需要一个参数（新分断的地址），从而根据新分断是大于还是小于当前分断，来增加或减小堆的大小。另一个调用sbrk要求传入一个增量，但目的是类似的。你不应该直接调用brk或sbrk。它们被内存分配库使用。如果你尝试使用它们，很可能会犯一些错误。建议坚持使用malloc()和free()。

你还可以通过mmap()调用从操作系统获取内存。通过传入正确的参数，mmap()可以在程序中创建一个匿名（anonymous）内存区域——这个区域不与任何特定文件相关联，而是与交换空间（swap space）相关联。这种内存也可以像堆一样对待并管理。

## 其他调用

内存分配库还支持一些其他调用。

* calloc()分配内存，并在返回之前将其置零。
* 当你为某些东西（比如一个数组）分配空间，然后需要添加一些东西时，realloc()也会很有用：realloc()创建一个新的本大的内存区域，将旧区域复制到其中，并返回新区域的指针。