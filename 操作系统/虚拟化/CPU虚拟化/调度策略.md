# 调度策略

## 调度指标

指标是我们用来衡量某些东西的东西，在进程调度中，有一些不同的指标是有意义的。

|指标|定义|性质|公式|
|---|---|---|---|
|周转时间（turnaround time）|任务完成时间减去到达系统的时间|性能（performance）指标|T<sub>周转时间</sub>=T<sub>完成时间</sub>-T<sub>到达时间</sub>|
|响应时间（response time）|从任务到达系统到首次运行的时间|公平（fairness）指标|T<sub>响应时间</sub>=T<sub>首次运行</sub>-T<sub>到达时间</sub>|

## 调度算法

### 先进先出（First In First Out，FIFO）

* 优点：简单，易于实现。
* 缺点：存在护航效应（convoy effect），一些耗时较少的潜在资源消费者被排在重量级的资源消费者之后。

![调度策略+20250128224848](https://raw.githubusercontent.com/loli0con/picgo/master/images/调度策略+20250128224848.png+2025-01-28-22-48-48)

### 最短任务优先（Shortest Job First，SJF）

* 定义：先运行最短的任务，然后是次短的任务，如此下去。
* 优点：在所有工作同时到达的情况下，这是一个最优（optimal）调度算法。
* 缺点：非抢占式（non-preemptive）调度算法，无法保证所有工作同时到达。当重量级工作先到达时，存在护航问题。

![调度策略+20250128230620](https://raw.githubusercontent.com/loli0con/picgo/master/images/调度策略+20250128230620.png+2025-01-28-23-06-21)

### 最短完成时间优先（Preemptive Shortest Job First，STCF）

* 定义：向SJF添加抢占。每当新工作进入系统时，它就会确定剩余工作和新工作中，谁的剩余时间最少，然后调度该工作。
* 优点：非抢占式（non-preemptive）调度算法，平均周转时间大大提高。

![调度策略+20250128234740](https://raw.githubusercontent.com/loli0con/picgo/master/images/调度策略+20250128234740.png+2025-01-28-23-47-40)

### 轮转（Round-Robin，RR）

* 定义：RR在一个时间片（time slice，有时称为调度量子，scheduling quantum）内运行一个工作，然后切换到运行队列中的下一个任务，而不是运行一个任务直到结束。它反复执行，直到所有任务完成。
* 优点：响应时间短，适用于分时系统，满足系统的交互性要求，能及时响应终端用户。

![调度策略+20250128234912](https://raw.githubusercontent.com/loli0con/picgo/master/images/调度策略+20250128234912.png+2025-01-28-23-49-12)

#### 时间片设计

时间片长度对于RR是至关重要的。越短，RR在响应时间上表现越好。然而，时间片太短是有问题的：突然上下文切换的成本将影响整体性能。因此，系统设计者需要权衡时间片的长度，使其足够长，以便摊销（amortize）上下文切换成本，而又不会使系统不及时响应。

#### 成本分析

当系统某些操作有固定成本时，通常会使用摊销技术（amortization）。通过减少成本的频度（即执行较少次的操作），系统的总成本就会降低。例如，如果时间片设置为10ms，并且上下文切换时间为1ms，那么浪费大约10%的时间用于上下文切换。如果要摊销这个成本，可以把时间片增加到100ms。在这种情况下，不到1%的时间用于上下文切换，因此时间片带来的成本就被摊销了。

上下文切换的成本不仅仅来自保存和恢复少量寄存器的操作系统操作。程序运行时，它们在CPU高要缓存、TLB、分支预测器和其他片上硬件中建立了大量的状态。切换到另一个工作会导致此状态被刷新，且与当前运行的作业相关的新状态被引入，这可能导致显著的性能成本。

## 性能和公平

如果响应时间是我们的唯一指标，那么带有合理时间片的RR，就会是非常好的调度程序。

如果周转时间是我们的唯一指标，那么RR确实是最糟糕的策略之一。直观地说，这应该是有意义的：RR所做的正是延伸每个工作，只运行每个工作一小段时间，就转向下一个工作。因为周转时间只关心作业何时完成，RR几乎是最差的，在很多情况下甚至比简单的FIFO更差。

任何公平（fair）的政策（如RR），即在小规模的时间内将CPU均匀分配到活动进程之间，在周转时间这类指标上表现不佳。如果你愿意不公平，你可以运行较短的工作直到完成，但是要以响应时间为代价。如果你重视公平性，则响应时间会较短，但会以周转时间为代价。这种权衡在系统中很常见。

## 多级反馈队列（Multi-level Feedback Queue，MLFQ）

多级反馈队列需要解决两方面的问题：
* 首先，它要优化周转时间，这可以通过先执行短工作来实现。然而，操作系统通常不知道工作要运行多久，而这又是SJF（或STCF）等算法所必需的。
* 其次，给交互用户（如用户坐在屏幕前，等着进程结束）很好的交互体验，因此需要降低响应时间。然而，像轮转这样的算法虽然降低了响应时间，周转时间却很差。

所以这里的问题是：通常我们对进程一无所知，应该如何构建调度程序来实现这些目标？调度程序如何在运行过程中学习进程的特征，从而做出更好的调度决策？

多级反馈队列是用历史经验预测未来的一个典型的例子，操作系统中有很多地方采用了这种技术（同样存在于计算机科学领域的很多其他地方，比如硬件的分支预测及缓存算法）。如果工作有明显的阶段性行为，因此可以预测，那么这种方式会很有效。

### 基本规则 

MLFQ中有许多独立的队列（queue），每个队列有不同的优先级（priority level）。任何时刻，一个工作只能存在于一个队列中。MLFQ总是优先执行较高优先级的工作（即在较高级队列中的工作）。每个队列中可能会有多个工作，因此具有同样的优先级。在这种情况下，我们就对这些工作采用轮转调度。

MLFQ调度策略的关键在于如何设置优先级。MLFQ没有为每个工作指定不变的优先顺序，而是根据观察到的行为调整它的优先级。例如，如果一个工作不断放弃CPU去等待键盘输入，这是交互型进程的可能行为，MLFQ因此会让它保持高优先级。相反，如果一个工作长时间地占用CPU，MLFQ会降低其优先级。通过这种方式，MLFQ在进程运行过程中学习其行为，从而利用工作的历史来预测它未来的行为。

MLFQ的规则：
* 规则1：如果A的优先级 > B的优先级，运行A（不运行B）。
* 规则2：如果A的优先级 = B的优先级，轮转运行A和B。
* 规则3：工作进入系统时，放在最高优先级（最上层队列）。
* 规则4：一旦工作用完了其在某一层中的时间配额（无论中间主动放弃了多少次CPU），就降低其优先级（移入低一级队列）。
* 规则5：经过一段时间S，就将系统中所有工作重新加入最高优先级队列。如果S设置得太高，长工作会饥饿；如果设置得太低，交互型工作又得不到合适的CPU时间比例。

大多数的MLFQ变体都支持不同队列可变的时间片长度。高优先级队列通常只有较短的时间片（比如10ms或者更少），因而这一层的交互工作可以更快地切换。相反，低优先级队列中更多的是CPU密集型工作，配置更长的时间片会取得更好的效果。

## 比例份额（proportional-share）

比例份额（proportional-share）调度程序，有时也称为公平份额（fair-share）调度程序。比例份额算法基于一个简单的想法：调度程序的最终目标，是确保每个工作获得一定比例的CPU时间，而不是优化周转时间和响应时间。

比例份额调度程序有一个非常优秀的现代例子，名为彩票调度（lottery scheduling）。基本思想很简单：每隔一段时间，都会举行一次彩票抽奖，以确定接下来应该运行哪个进程。越是应该频繁运行的进程，越是应该拥有更多地赢得彩票的机会。

### 基本概念

彩票调度背后是一个非常基本的概念：彩票数（ticket）代表了进程（或用户或其他）占有某个资源的份额。一个进程拥有的彩票数占总彩票数的百分比，就是它占有资源的份额。

通过不断定时地（比如，每个时间片）抽取彩票，彩票调度从概率上（但不是确定的）获得这种份额比例。抽取彩票的过程很简单：调度程序知道总共的彩票数（在我们的例子中，有100张）。调度程序抽取中奖彩票，这是从0和99之间的一个数，拥有这个数对应的彩票的进程中奖。调度程序然后加载中奖进程的状态，并运行它。

### 优点特性

彩票调度最精彩的地方在于利用了随机性（randomness）。当你需要做出决定时，采用随机的方式常常是既可靠又简单的选择。

随机方法相对于传统的决策方式，至少有3点优势：

* 第一，随机方法常常可以避免奇怪的边角情况，较传统的算法可能在处理这些情况时遇到麻烦。例如LRU替换策略。虽然LRU通常是很好的替换算法，但在有重复序列的负载时表现非常差。但随机方法就没有这种最差情况。
* 第二，随机方法很轻量，几乎不需要记录任何状态。在传统的公平份额调度算法中，记录每个进程已经获得了多少的CPU时间，需要对每个进程计时，这必须在每次运行结束后更新。而采用随机方式后每个进程只需要非常少的状态（即每个进程拥有的彩票号码）。
* 第三，随机方法很快。只要能很快地产生随机数，做出决策就很快。因此，随机方式在对运行速度要求高的场景非常适用。当然，越是需要快的计算速度，随机就会越倾向于伪随机。

### 彩票机制

彩票（步长）调度的设计中，最强大（且最基本）的机制是彩票。彩票可用于表示一个进程占有CPU的份额，但也可以用在更多的地方。比如在虚拟机管理程序的虚存管理工作中，可以用彩票来表示用户占用操作系统内存份额的方法。因此，如果你需要通过什么机制来表示所有权比例，这个概念可能就是彩票。

彩票调度还提供了一些机制，以不同且有效的方式来调度彩票。一种方式是利用彩票货币（ticket currency）的概念。这种方式允许拥有一组彩票的用户以他们喜欢的某种货币，将彩票分给自己的不同工作。之后操作系统再自动将这种货币兑换为正确的全局彩票。

另一个有用的机制是彩票转让（ticket transfer）。通过转让，一个进程可以临时将自己的彩票交给另一个进程。

最后，彩票通胀（ticket inflation）有时也很有用。利用通胀，一个进程可以临时提升或降低自己拥有的彩票数量。当然在竞争环境中，进程之间互相不信任，这种机制就没什么意义。一个贪婪的进程可能给自己非常多的彩票，从而接管机器。但是，通胀可以用于进程之间相互信任的环境。在这种情况下，如果一个进程知道它需要更多CPU时间，就可以增加自己的彩票，从而将自己的需求告知操作系统，这一切不需要与任何其他进程通信。

### 算法实现

只需要一个不错的随机数生成器来选择中奖彩票和一个记录系统中所有进程的数据结构（一个列表），以及所有彩票的总数。

假定我们用列表记录进程。每个进程有一定数量的彩票。在做出调度决策之前，首先要从彩票总数中选择一个随机数（中奖号码）。然后，遍历链表，用一个简单的计数器帮助我们找到中奖者。

要让这个过程更有效率，建议将列表项按照彩票数递减排序。这个顺序并不会影响算法的正确性，但能保证用最小的迭代次数找到需要的节点，尤其当大多数彩票被少数进程掌握时。

### 步长调度

虽然随机方式可以使得调度程序的实现简单（且大致正确），但偶尔并不能产生正确的比例，尤其在工作运行时间很短的情况下。由于这个原因，可以使用一个确定性的公平分配算法——步长调度（stride scheduling）。

系统中的每个工作都有自己的步长，这个值与票数值成反比。通过用一个大数分别除以他们的票数来获得每个进程的步长（stride）。每次进程运行后，我们会让它的计数器（行程值）增加它的步长，记录它的总体进展。

之后，调度程序使用进程的步长及行程值来确定调度哪个进程。基本思路很简单：当需要进行调度时，选择目前拥有最小行程值的进程，并且在运行之后将该进程的行程值增加一个步长。

### 对比和总结

彩票调度有一个步长调度没有的优势——不需要全局状态。假如一个新的进程在上面的步长调度执行过程中加入系统，应该怎么设置它的行程值呢？设置成0吗？这样的话，它就独占CPU了。而彩票调度算法不需要对每个进程记录全局状态，只需要用新进程的票数更新全局的总票数就可以了。因此彩票调度算法能够更合理地处理新加入的进程。

虽然两者都很有趣，但由于一些原因，并没有作为CPU调度程序被广泛使用。一个原因是这两种方式都不能很好地适合I/O；另一个原因是其中最难的票数分配问题并没有确定的解决方式，例如，如何知道浏览器进程应该拥有多少票数？通用调度程序（像前面讨论的MLFQ及其他类似的Linux调度程序）做得更好，因此得到了广泛的应用。

结果，比例份额调度程序只有在这些问题可以相对容易解决的领域更有用（例如容易确定份额比例）。例如在虚拟（virtualized）数据中心中，你可能会希望分配1/4的CPU周期给Windows虚拟机，剩余的给Linux系统，比例分配的方式可以更简单高效。