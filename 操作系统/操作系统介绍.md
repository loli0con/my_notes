# 操作系统介绍

## 三大部分

- **①虚拟化（virtualization）**
- **②并发（concurrency）**
- **③持久性（persistence）**

## 冯·诺依曼计算模型的基本概念

一个正在运行的程序会做一件非常简单的事情：**执行指令**。处理器从内存中获取（**fetch**）一条指令，对其进行解码（**decode**）（弄清楚这是哪条指令），然后执行（**execute**）它（做它应该做的事情，如两个数相加、访问内存、检查条件、跳转到函数等）。完成这条指令后，处理器**继续执行下一条**指令，依此类推，直到程序最终完成。

## 操作系统的作用

操作系统负责让程序运行变得容易（甚至允许你同时运行多个程序），允许程序共享内存，让程序能够与设备交互，以及其他类似的有趣的工作。它们负责确保系统既**易于使用**又**正确高效**地运行。

## ①资源虚拟化

操作系统（Operating System，OS）利用虚拟化（virtualization）技术将物理（physical）资源（如处理器、内存或磁盘）转换为更通用、更强大且更易于使用的虚拟形式。因此，我们有时将操作系统称为虚拟机（virtual machine）。

典型的操作系统会提供几百个系统调用（system call）让应用程序调用。由于操作系统提供这些调用来运行程序、访问内存和设备，并进行其他相关操作，我们有时也会说操作系统为应用程序提供了一个标准库（standard library）。

最后，因为虚拟化让许多程序运行（从而共享CPU），让许多程序可以同时访问自己的指令和数据（从而共享内存），让许多程序访问设备（从而共享磁盘等），所以操作系统有时被称为资源管理器（resource manager）。每个CPU、内存和磁盘都是系统的资源（resource），因此操作系统扮演的主要角色就是管理（manage）这些资源，以做到高效或公平，或者实际上考虑其他许多可能的目标。

### 虚拟化CPU

在硬件的一些帮助下，操作系统负责提供系统拥有非常多的虚拟CPU的假象（illusion）。将单个CPU（或其中一小部分）转换为看似无限数量的CPU，从而让许多程序看似同时运行，这就是所谓的虚拟化CPU（virtualizing the CPU）。

### 虚拟化内存

现代机器提供的物理内存（physical memory）模型非常简单。内存就是一个字节数组。要读取（read）内存，必须指定一个地址（address），才能访问存储在那里的数据。要写入（write）或更新（update）内存，还必须指定要写入给定地址的数据。

程序运行时，一直要访问内存。程序将所有数据结构保存在内存中，并通过各种指令来访问它们，例如加载和保存，或利用其他明确的指令，在工作时访问内存。程序的每个指令都在内存中，因此每一读取指令都会访问内存。

每个进程访问自己的私有虚拟地址空间（virtual address space）（有时称为地址空间，address space），操作系统以某种方式映射到机器的物理内存上。一个正在运行的程序中的内存引用不会影响其他进程（或操作系统本身）的地址空间。对于正在运行的程序，它完全拥有自己的物理内存。就好像每个正在运行的程序都有自己的私有内存，而不是与其他正在运行的程序共享相同的物理内存，这正是操作系统虚拟化内存（virtualizing memory）时发生的情况。但实际情况是，物理内存是由操作系统管理的共享资源。

## ②并发

并发（concurrency），这个术语来指代**一系列问题**，这些问题在**同时**（并发地）处理很多事情时**出现**且必须解决。并发问题首先出现在操作系统本身中。操作系统同时处理很多事情，首先运行一个进程，然后再运行一个进程，等等。这样做会导致一些深刻而有趣的问题。多线程（multi-threaded）程序也存在相同的问题。

## ③持久化

在系统内存中，数据容易丢失，因为像DRAM这样的设备以易失（volatile）的方式存储数值。如果断电或系统崩溃，那么内存中的所有数据都会丢失。因此，我们需要硬件和软件来持久地（persistently）存储数据。

硬件以某种输入/输出（Input/Output，I/O）设备的形式出现。在现代系统中，硬盘驱动器（hard drive）是存储长期保存的信息的通用存储库。固态硬盘（Solid-State Drive， SSD）也逐渐被广泛使用。

不像操作系统为CPU和内存提供的抽象，操作系统不会为每个应用程序创建专用的虚拟磁盘。相反，它假设用户经常需要共享（share）文件中的信息。

操作系统中管理磁盘的软件通常称为文件系统（file system），它负责以可靠和高效的方式，将用户创建的任何文件（file）存储在系统的磁盘上。文件系统必须做很多工作：首先确定新数据将驻留在磁盘上的哪个位置，然后在文件系统所维护的各种结构中对其进行记录。这样做需要向底层存储设备发出I/O请求，以读取现有结构或更新（写入）它们。所有写过设备驱动程序（device driver）的人都知道，让设备现表你执行某项操作是一个复杂而详细的过程。它需要深入了解低级别设备接口及其确切的语义。幸运的是，操作系统提供了一种通过系统调用来访问设备的标准和简单的方法。因此，OS有时被视为标准库（standard library）。出于性能方面的原因，大多数文件系统首先会延迟这些写操作一段时间，希望将其批量分组为较大的组。为了处理写入期间系统崩溃的问题，大多数文件系统都包含某种复杂的写入协议，如日志（journaling）或写时复制（copy-on-write），仔细排序写入磁盘的操作，以确保如果在写入序列期间发生故障，系统可以在之后恢复到合理的状态。为了使不同的通用操作更高效，文件系统采用了许多不同的数据结构和访问方法，从简单的列表到复杂的B树。

## 设计目标

操作系统做了如下的事情：

* 它取得CPU、内存或磁盘等物理资源（resources），并对它们进行虚拟化（virtualize）。
* 它处理与并发（concurrency）有关的麻烦且棘手的问题。
* 它持久地（persistently）存储文件，从而使它们长期随全。

鉴于我们希望建立这样一个系统，所以要有一些目标，以帮助我们集中设计和实现，并在必要时进行折中，找到合适的折中是建立系统的关键。操作系统的设计目标如下：

* 一个最基本的目标，是建立一些**抽象（abstraction）**，让系统方便和易于使用。
* 提供**高性能（performance）**，最小化操作系统的开销（minimize the overhead）。这些开销会以多种形式出现：额外时间（更多指令）和额外空间（内存或磁盘上）。如果有可能，我们会寻求解决方案，尽量减少一种或两种。
* 在应用程序之间以及在OS和应用程序之间提供**保护（protection）**。因为我们希望让许多程序同时运行，所以要确保一个程序的恶意或偶然的不良行为不会损害其他程序。我们当然不希望应用程序能够损害操作系统本身（因为这会影响系统上运行的所有程序）。让进程彼此隔离是保护的关键，因此决定了OS必须执行的大部分任务。
* 操作系统也必须不间断运行。当它失效时，系统上运行的所有应用程序也会失效。由于这种依赖性，操作系统往往力求提供高度的**可靠性（reliability）**。
* 其他目标
  * 能源效率（energy-efficiency）
  * 安全性（security）
  * 移动性（mobility）