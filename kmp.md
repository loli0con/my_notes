# KMP

## 参考
1. https://www.bilibili.com/video/BV1PD4y1o7nd
2. https://www.bilibili.com/video/BV1Ys411d7yh
3. https://www.bilibili.com/video/BV1M5411j7Xx
4. https://www.zhihu.com/question/21923021/answer/1032665486

## 暴力
算法复杂度：O(mn)

## kmp
传说中的kmp！
### 目标
利用**已知的信息**，减少回溯的长度，优化暴力算法，使算法复杂度达到O(m+n)。

剧透一下：
有句俗语，“没有金刚钻别揽瓷器活”，暴力算法干不了瓷器活，因为它没有金刚钻；而kmp能干瓷器活，那么必有它的金刚钻——“已知的信息”。  
没错，正是kmp比暴力算法多一个金刚钻，那么金刚钻到底是什么呢？

### 示例
文本串：a a b a a b a a f
模式串：a a b a a f

![kmp+20210805131911](https://i.loli.net/2021/08/05/9XtS5hYvfbV6ijn.png)

![kmp+20210805130518](https://i.loli.net/2021/08/05/KV6f85JC2TGMZb9.png)

### 疑问
* 为什么kmp可以“偷懒”？
* 为什么kmp可以省掉那些“不必要”的比较次数？
* 那些比较，真的是不必要的吗？

### 优化
kmp实现了文本串不回溯，模式串部分回溯。
模式串回溯的规则——**前缀表**。（也就是“金刚钻”）

为什么参照前缀表？这要从前缀表的定义/性质说起。

### 前缀表
前缀表描述了模式串的**最长相等前后缀**。  
关键词：**最长** + **相等** + **前缀** + **后缀**。

#### 前缀
包含首字母、不包含尾字母的子串

示例中模式串的前缀有：
* a
* aa
* aab
* aaba
* aabaa

#### 后缀
不包含首字母、包含尾字母的子串。

示例中模式串的后缀有：
* f
* af
* aaf
* baaf
* abaaf

#### 求最长相等前后缀的长度——前缀表
根据上述定义求得：
|子串|最长相等前后缀的长度|说明|
|---|---|---|
|a|0|没有前缀、没有后缀|
|aa|1|前缀“a” == 后缀“a”|
|aab|0||
|aaba|1|前缀“a” == 后缀“a”|
|aabaa|2|前缀“aa” == 后缀“aa”|
|aabaaf|0||

即：
|定义|内容||||||
|---|---:|---|---|---|---|---|
|下标号|0|1|2|3|4|5|
|模式串|a|a|b|a|a|f|
|前缀表|0|1|0|1|2|0|

### 答疑
让我们倒带一下，拉回上文，看“暴力算法发现不匹配时的回溯情况”：
![kmp+20210805135416](https://i.loli.net/2021/08/05/DuS2PVbQlyGo6it.png)

我们的任务是“字符串**匹配**”，根据上面求得的前缀表，
需要满足**匹配**的要求，可以跳过不匹配的内容，直接到“可以匹配”的部分，
即如下所示：

![kmp+20210805140738](https://i.loli.net/2021/08/05/dLy7UX82jCNigGF.png)

这就是kmp算法：根据计算出来的前缀表，跳过不必要的比较，减少了回溯的次数。

### 前缀表变体
有不同的前缀表：
|定义|内容||||||
|---|---:|---|---|---|---|---|
|下标号|0|1|2|3|4|5|
|模式串|a|a|b|a|a|f|
|前缀表（本体）|0|1|0|1|2|0|
|前缀表（右移）|-1|0|1|0|1|2|
|前缀表（减一）|-1|0|-1|0|1|-1|

它们的原理都是相同的，不同的是回溯的步骤。


## next
next数组——前缀表。next数组确定了回退的位置。
### 求next数组
求next数组也是个麻烦事，特别对我这种脑子不好使的的人来说。[参考4](#参考)中，“快速求next数组”里面讲的比较简单，我看这个能接受。

伪代码
```
/* next表示next数组，s表示模式串 */
void getNext(next, s){
    /* 步骤1：初始化 */
    i;  // 指向前缀末尾位置，i在循环遍历（构造next数组）的过程中初始化
    j=0;  // 指向后缀末尾位置，它还代表了最长相等前后缀的长度
    next[0]=0; // 0的位置回退到0本身
    

    /* 步骤2：构造next数组 */
    for(i = 1 ; i < s.size() ; i++){
        /* 处理前后缀相同的情况 */
        if(s[i] == s[j]){
            j++;
        }

        /* 处理前后缀不相同的情况 */
        if(s[i] != s[j] && j>0){

        }

        next[i] = j;
        // 更新next数组的值
    }
}
```

### 抄
#### 来源
作者：阮行止  
链接：https://www.zhihu.com/question/21923021/answer/1032665486  
来源：知乎  
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。  

#### 快速求next数组
终于来到了我们最后一个问题——如何快速构建next数组。

首先说一句：快速构建next数组，是KMP算法的精髓所在，核心思想是“**P自己与自己做匹配**”。

为什么这样说呢？回顾next数组的完整定义：
* 定义 “k-前缀” 为一个字符串的前 k 个字符； “k-后缀” 为一个字符串的后 k 个字符。k 必须小于字符串长度。
* next\[x] 定义为： P\[0]~P\[x] 这一段字符串，使得**k-前缀恰等于k-后缀**的最大的k.
 
这个定义中，不知不觉地就包含了一个匹配——前缀和后缀相等。接下来，我们考虑采用递推的方式求出next数组。如果next\[0], next\[1], ... next\[x-1]均已知，那么如何求出 next\[x] 呢?

来分情况讨论。首先，已经知道了 next\[x-1]（以下记为now），如果 P\[x] 与 P\[now] 一样，那最长相等前后缀的长度就可以扩展一位，很明显 next\[x] = now + 1. 图示如下。

![kmp+20210805192212](https://i.loli.net/2021/08/05/Kiag6FfU8dwuIGr.png)

刚刚解决了 P\[x] = P\[now] 的情况。那如果 P\[x] 与 P\[now] 不一样，又该怎么办？

![kmp+20210805192242](https://i.loli.net/2021/08/05/kF3hAolJsuCWYdP.png)

如图。长度为 now 的子串 A 和子串 B 是 P\[0]~P\[x-1] 中最长的公共前后缀。可惜 A 右边的字符和 B 右边的那个字符不相等，next\[x]不能改成 now+1 了。因此，我们应该**缩短这个now**，把它改成小一点的值，再来试试 P\[x] 是否等于 P\[now].

now该缩小到多少呢？显然，我们不想让now缩小太多。因此我们决定，在保持“P\[0]~P\[x-1]的now-前缀仍然等于now-后缀”的前提下，让这个新的now尽可能大一点。 P\[0]~P\[x-1] 的公共前后缀，前缀一定落在串A里面、后缀一定落在串B里面。换句话讲：接下来now应该改成：使得 **A的k-前缀**等于**B的k-后缀** 的最大的k.

您应该已经注意到了一个非常强的性质——**串A和串B是相同的**！B的后缀等于A的后缀！因此，使得A的k-前缀等于B的k-后缀的最大的k，其实就是串A的最长公共前后缀的长度 —— next\[now-1]！

![kmp+20210805192302](https://i.loli.net/2021/08/05/DPKbsVqxiBOIrlW.png)

来看上面的例子。当P\[now]与P\[x]不相等的时候，我们需要缩小now——把now变成next\[now-1]，直到P\[now]=P\[x]为止。P\[now]=P\[x]时，就可以直接向右扩展了。