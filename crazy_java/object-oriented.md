# 面向对象

## 🧩零散知识点
### 三大特征
面向对象的三大特征：封装、继承、多态
***

### 类型
Java里面有两种类型，基本类型和引用类型，变量可以指向这两种类型。
***

### 类中的成员
成员变量、初始化块、构造器、方法、内部类

属性：指的是一组setter方法和getter方法
***

### JavaBean
如果一个Java类的每个实例变量都被使用private修饰，并为每个实例变量都提供了public修饰的setter方法和getter方法，那么这个类就是一个符合JavaBean规范的类。
***

### this
this关键字总是指向调用该方法的对象。
***

### final
final关键字可用于修饰类、变量和方法，用于表示它修饰的类、变量和方法不可改变。
#### 成员变量
final成员变量必须由程序员显式初始化，系统不会对final成员进行隐式初始化。
***

### 运行流程
**纯个人理解，不一定正确！**
#### 类
1. 加载类
   1. 加载父类 *（注意此处会递归）*
   2. 给**类变量**和**方法**分配内存空间
2. 按照**类初始化块**和**显式初始化值**的顺序，先后执行初始化流程

#### 对象
1. 实例化对象
   1. 实例化父类的对象 *（注意此处会递归）*
   2. 给**实例变量**分配内存空间
2. 初始化
   1. 初始化父类的对象 *（注意此处会递归）*
   2. 按照**初始化块**和**显式初始化值**的顺序，先后执行初始化流程
   3. 执行构造器


***
## 修饰符
### 访问控制修饰符
|作用范围|类中|包中|子类|全局|
|-----|-----|-----|-----|-----|
|从小到大|private|~~default~~|protected|public|

### 静态 static
static用于区分成员变量、初始化块、方法、内部类这四种成员到底属于类本身还是属于实例。static修饰的成员表明它属于这个类本身，而不属于该类的单个实例，因此通常把static修饰的成员变量和方法称为类变量、类方法，把不使用static修饰的成员变量和方法称为实例变量、实例方法。

### 抽象 abstract
抽象类和抽象方法必须使用abstract修饰符来定义。

#### 注意事项
* abstract和final不能同时使用
* abstract和static不能同时修饰某个方法
* abstract和private不能同时修饰某个方法



***
## 方法
### 参数传递机制
Java里方法的参数传递方式只有一种：值传递。
所谓值传递，就是将实际参数值的副本（复制品）传入方法内，而参数本身不会受到影响。
### 方法重载 overload
如果同一个类中包含了两个或者两个以上方法的方法名相同，但形参列表不同，则被称为方法重载。
### 方法重写 override
方法的重写要遵循“两同两小一大”规则，“两同”即方法名相同、形参列表相同；“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类型比父类方法声明抛出的异常类型更小或相等；“一大”指的是子类方法的访问权限应该比父类方法的访问权限更大或相等。



***
## 包
### package
Java包机制需要两个方面的保证
1. 源文件里使用package语句指定包名
2. class文件必须放在对应的路径下

同一个包中的类不必位于相同的目录下，只要让CLASSPATH环境变量里包含这两个路径即可。jvm会自动搜索CLASSPATH下的子路径，把它们当成用一个包下的类来处理。

### import
import可以向某个Java文件中导入指定包层次下某个类或者全部类：
* import package.subpackage...Classname
* import package.subpackage...*

### import static 静态导入
import static用于导入指定类的某个静态成员变量、方法或全部的静态成员变量、方法：
* import static package.subpackage...ClassName.fieldName|methodName
* import static package.subpackage...ClassName.*


***
## 接口
接口是从多个相似类中抽象出来的规范，使用interface关键字定义接口。  
接口定义的是多个类共同的行为规范，这些行为是与外部交流的通道，这意味着接口里通常是一组公用方法。

### 基本语法
```
[修饰符] interface 接口名 extends 父接口1, 父接口2...
{
    零到多个常量定义...
    零到多个抽象方法定义...
    零到多个内部类、接口、枚举定义...
    零到多个默认方法或类方法定义...
}
```
#### 详细说明
* 接口本身的修饰符可以是public或~~default~~
* 接口成员只能使用public访问控制修饰符
* 接口里的成员变量总是使用public static final这三个修饰符来修饰
* 使用default修饰默认方法

### 接口和抽象类的区别
接口作为系统与外界交互的窗口，接口体现的是一种规范。对于接口的实现者而言，接口规定了实现者必须向外提供哪些服务（以方法的形式来提供）；对于接口的调用者而言，接口规定了调用者可以调用哪些服务，以及如何调用这些服务（就是如何来调用方法）。当在一个程序中使用接口时，接口是多个模块间的耦合标准；当在多个应用程序之间使用接口时，接口是多个程序之间的通信标准。

从某种程度上来看，接口类似于整个系统的“总纲”，它制定了系统各模块应该遵循的标准，因此一个系统中的接口不应该经常改变。一旦接口被改变，对整个系统甚至其他系统的影响将是辐射式的，导致系统中大部分类都需要改写。

抽象类则不一样，抽象类作为系统中多个子类的共同父类，它所体现的是一种模板式设计。抽象类作为多个子类的抽象父类，可以被当成系统实现过程中的中间产品，这个中间产品已经实现了系统的部分功能（那些已经提供实现的方法），但这个产品依然不能当成最终产品，必须有更进一步的完善，这种完善可能有几种不同方式。