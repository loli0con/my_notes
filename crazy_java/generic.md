# 泛型

## 参考链接
https://blog.csdn.net/s10461/article/details/53941091  
https://blog.csdn.net/qq_27093465/article/details/73229016  
https://www.cnblogs.com/jingmoxukong/p/12049160.html  
https://juejin.cn/post/6844903650788114439

## 定义
泛型，即“参数化类型”，就是允许在定义类、接口、方法时使用类型形参，这个类型形参（或叫泛型）将在声明变量、创建对象、调用方法时动态地指定（即传入实际的类型参数，也可称为类型实参）。

如果没有为泛型指定实际的类型，此时该泛型被称为raw type（原始类型），默认是声明该泛型形参时指定的第一个上限类型。

## 价值
在Java世界中：
* 泛型的出现是为了避免繁琐的强制转换以及随之而来的`ClassCastException`
* 泛型的实现是依靠Java编译器在编译时对泛型代码做的强类型检查

## 类型擦除
Java 语言引入泛型是为了在**编译时**提供更严格的类型检查，并支持泛型编程。不同于 C++ 的模板机制，Java 泛型是使用类型擦除来实现的，使用泛型时，任何具体的类型信息都被擦除了。
Java 泛型的实现方式不太优雅，但这是因为泛型是在 JDK5 时引入的，为了兼容老代码，必须在设计上做一定的折中。

编译器虽然会在编译过程中移除参数的类型信息，但是会保证类或方法内部参数类型的一致性。

当把一个具有泛型信息的对象赋予给另一个没有泛型信息的变量时，所有在尖括号之间的类型信息都将被扔掉。

**泛型参数将会被擦除到它的第一个边界**（边界可以有多个，重用 extends 关键字，通过它能给与参数类型添加一个边界，extend关键字后后面的类型信息决定了泛型参数能保留的信息）。编译器事实上会把类型参数替换为它的第一个边界的类型。如果没有指明边界，那么类型参数将被擦除到Object。

这种情况下，由于JVM泛型的擦除机制，在运行时JVM是不知道泛型信息的。简而言之，**JVM里没有泛型**。

### 推论
不管为泛型形参传入哪一种类型实参，对于Java来说，它们依然被当成同一个类处理，在内存中也只占用一块内存空间，因此在静态方法、静态初始化快或者静态变量的声明和初始化中不允许使用泛型形参。

泛型不能用于显式地引用运行时类型的操作之中，例如：转型、`instanceof`操作和 `new`表达式，因为所有关于参数的类型信息都丢失了。

## 通配符
同一种泛型可以对应多个版本（因为参数类型是不确定的），不同版本的泛型类实例是不兼容的。

举个例子：定义`List<Object>`，传入`List<Number>`，将会编译报错。

为了表示各种泛型List的父类，可以使用类型通配符，类型通配符是一个问号（?），它可以匹配任何元素类型。`List<?>`在**逻辑上**是`List<String>`、`List<Integer>`等所有`List<具体类型实参>`的父类。

## 上下届
可以使用上/下界通配符来缩小类型参数的类型范围，例如：
`<? extends Number>` 或 `<T super Integer>`。

注意：
* 上界通配符和下界通配符不能同时使用。
* 上届可设置多个，`<T extends B1 & B2 & B3>`，第一个类型参数（B1）可以是类或接口，其他类型参数（B2、B3···）只能是接口。

### 进&出
指定通配符的上下届，就是为了支持类型型变。  
比如Foo是Bar的子类，这样的`A<Bar>`就相当于`A<? extends Foo>`的子类，可以将`A<Bar>`赋值给`A<? extends Foo>`类型的变量，这种型变方式被称为协变。  
比如Foo是Bar的子类，当程序需要一个`A<? super Bar>`的变量时，程序可以将`A<Foo>`、`A<Object>`赋值给`A<? super Bar>`类型的变量，这种方式称为逆变。

[协变只出不进，逆变只进不出！](https://juejin.cn/post/6844903650788114439#heading-11)

## 泛型方法和类型通配符
大多数时候都可以使用泛型方法来代替类型通配符。

泛型方法允许形参用来表示方法的一个或多个参数之间的类型依赖关系，或者方法返回值与参数之间的类型依赖关系。如果没有这样的**类型依赖关系**，就不应该使用泛型方法。

类型通配符被设计出来的目的就是为了**支持灵活的子类化**。如果一个泛型形参仅使用一次，其他参数的类型、方法返回值的类型都不依赖它，那么这个泛型形参就没有存在的必要，这时应该用通配符来代替它。

综上所述，默认使用通配符。

## 类型推断
使用泛型方法的时候，通常不必指明类型参数，因为编译器会为我们找出具体的类型。这称为类型参数推断（type argument inference）。类型推断主要有两个方面：
* 可通过调用方法的上下文来推断泛型的目标类型。
* 可在方法调用链中，将推断得到的泛型传递到最后一个方法。

泛型推断也不是万能的，因此也可以显式指定泛型的实际类型。