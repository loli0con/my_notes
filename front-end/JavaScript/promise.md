# 期约与异步函数


## 同步与异步
同步行为和异步行为的对立统一是计算机科学的一个基本概念。

**同步行为**对应内存中顺序执行的处理器指令。每条指令都会严格按照它们出现的顺序来执行，而每条指令执行后也能立即获得存储在系统本地(如寄存器或系统内存)的信息。

```js
// 同步操作的例子
let x = 3;
x = x + 4;
```

在程序执行的每一步，都可以推断出程序的状态。这是因为后面的指令总是在前面的指令完成后才会执行。等到最后一条指定执行完毕，存储在 x 的值就立即可以使用。

相对地，**异步行为**类似于系统中断，即当前进程外部的实体可以触发代码执行。异步操作经常是必要的，因为强制进程等待一个长时间的操作通常是不可行的(同步操作则必须要等)。如果代码要访问 一些高延迟的资源，比如向远程服务器发送请求并等待响应，那么就会出现长时间的等待。

```js
// 异步操作的例子
let x = 3;
setTimeout(() => x = x + 4, 1000);
```

这段程序最终与同步代码执行的任务一样，都是把两个数加在一起，但这一次执行线程不知道 x 值何时会改变，因为这取决于回调何时从消息队列出列并执行。

为了让后续代码能够使用 x，异步执行的函数需要在更新 x 的值以后通知其他代码。如果程序不需要这个值，那么就只管继续执行，不必等待这个结果了。

## 回调函数
异步行为是 JavaScript 的基础，但以前的实现不理想。在早期的 JavaScript 中，只支持定义回调函数 来表明异步操作完成。串联多个异步操作是一个常见的问题，通常需要深度嵌套的回调函数(俗称“回调地狱”)来解决。

## 期约

### 期约的基本概念
期约是对尚不存在结果的一个替身。同一时期的计算机科学家还使用了“终局”(eventual)、“期许”(future)、“延迟”(delay)和“迟付”(deferred)等术语指代同样的概念。所有这些概念描述的都是一种异步程序执行的机制。

#### 创建期约
ECMAScript 6 新增的引用类型 Promise，可以通过 new 操作符来实例化，创建新期约时需要传入执行器(executor)函数作为参数。
```js
let p = new Promise(() => {});
setTimeout(console.log, 0, p);  // Promise <pending>
```

#### 期约状态机
期约是一个有状态的对象，期约的状态代表期约是否完成，期约可能处于如下 3 种状态之一:
* 待定(pending)：表示期约尚未开始或者正在执行中
* 兑现(fulfilled，有时候也称为“解决”，resolved)：表示期约已经成功完成
* 拒绝(rejected)：表示期约没有成功完成

待定(pending)是期约的最初始状态。在待定状态下，期约可以落定(settled)为代表成功的兑现(fulfilled)状态，或者代表失败的拒绝(rejected)状态。无论落定为哪种状态都是不可逆的。只要从待定转换为兑现或拒绝，期约的状态就不再改变。而且，也不能保证期约必然会脱离待定状态。

期约的状态是私有的，不能直接通过 JavaScript 检测，也不能被外部 JavaScript 代码修改。为了避免根据读取到的期约状态，以同步方式处理期约对象，期约故意将异步行为封装起来，从而隔离外部的同步代码。

#### 解决值/拒绝理由

期约封装的异步操作会实际生成某个值，而程序期待期约状态改变时可以访问这个值。相应地，如果期约被拒绝，程序就会期待期约状态改变时可以拿到拒绝的理由。

每个期约只要状态切换为兑现，就会有一个私有的内部值(value)。每个期约只要状态切换为拒绝，就会有一个私有的内部理由(reason)。无论是值还是理由，都是包含原始值或对象的不可修改的引用。二者都是可选的，而且默认值为 undefined。在期约到达某个落定状态时执行的异步代码始终会收到这个值或理由。

#### 执行器函数
由于期约的状态是私有的，所以只能在内部进行操作。内部操作在期约的执行器函数中完成。执行器函数主要有两项职责：初始化期约的异步行为和控制状态的最终转换。

控制期约状态的转换是通过调用它的两个函数参数实现的，这两个函数参数通常都命名为 resolve() 和 reject()。调用 resolve() 会把状态切换为兑现，调用 reject() 会把状态切换为拒绝。另外，调用 reject() 也会抛出错误。

```js
let p1 = new Promise((resolve, reject) => resolve());
setTimeout(console.log, 0, p1); // Promise <resolved>
let p2 = new Promise((resolve, reject) => reject());
setTimeout(console.log, 0, p2); // Promise <rejected> 
// Uncaught error (in promise)    控制台上打印出未被捕获的错误
```

因为执行器函数是期约的初始化程序，所以执行器函数是同步执行的，即在初始化时立刻运行执行器函数。

无论 resolve()和 reject()中的哪个被调用，状态转换都不可撤销了。继续修改状态会静默失败，没有效果。

为避免期约卡在待定状态，可以添加一个定时退出功能。

#### Promise.resolve()
期约并非一开始就必须处于待定状态，然后通过执行器函数才能转换为落定状态。通过调用Promise.resolve()静态方法，可以实例化一个解决的期约。下面两个期约实例实际上是一样的：

```js
let p1 = new Promise((resolve, reject) => resolve());
let p2 = Promise.resolve();
```

解决的期约的值会传给Promise.resolve()的第一个参数，多余的参数会忽略。使用这个静态方法，实际上可以把任何值都转换为一个期约：
```js
setTimeout(console.log, 0, Promise.resolve());
// Promise <resolved>: undefined

setTimeout(console.log, 0, Promise.resolve(3));
// Promise <resolved>: 3

setTimeout(console.log, 0, Promise.resolve(4, 5, 6));
// Promise <resolved>: 4
```

对这个静态方法而言，如果传入的参数本身是一个期约，那它的行为就类似于一个空包装。因此，Promise.resolve()可以说是一个幂等方法，这个幂等性会保留传入期约的状态，如下所示：
```js
let p = new Promise(() => {});
setTimeout(console.log, 0, p); // Promise <pending>
setTimeout(console.log, 0, Promise.resolve(p)); // Promise <pending>
setTimeout(console.log, 0, p === Promise.resolve(p)); // true
```

这个静态方法能够包装任何非期约值，包括错误对象，并将其转换为解决的期约。

#### Promise.reject()
Promise.reject()会实例化一个拒绝的期约并抛出一个异步错误 (这个错误不能通过 try/catch 捕获，而只能通过拒绝处理程序捕获)。下面的两个期约实例实际上是一样的:
```js
let p1 = new Promise((resolve, reject) => reject());
let p2 = Promise.reject();
```

这个拒绝的期约的理由就是传给 Promise.reject() 的第一个参数。这个参数也会传给后续的拒绝处理程序:
```js
let p = Promise.reject(3);
setTimeout(console.log, 0, p); // Promise <rejected>: 3
p.then(null, (e) => setTimeout(console.log, 0, e)); // 3
```

Promise.reject()并没有幂等逻辑。如果给它传一个期约对象，则这个期约会成为它返回的拒绝期约的理由。

#### 同步/异步执行的二元性
Promise 的设计很大程度上会导致一种完全不同于 JavaScript 的计算模式。

期约真正的异步特性:它们是同步对象(在同步执行模式中使用)，但也是异步执行模式的媒介。

拒绝期约的错误并没有抛到执行同步代码的线程里，而是通过浏览器异步消息队列来处理的。因此，同步代码的 try/catch 块并不能捕获该错误，需要通过异步模式捕获错误。代码一旦开始以异步模式执行，则唯一与之交互的方式就是使用异步结构——更具体地说，就是期约的方法。

### 期约的实例方法
期约实例的方法是连接外部同步代码与内部异步代码之间的桥梁。这些方法可以访问异步操作返回的数据，处理期约成功和失败的结果，连续对期约求值，或者添加只有期约进入终止状态时才会执行的代码。