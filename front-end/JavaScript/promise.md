# 期约与异步函数


## 同步与异步
同步行为和异步行为的对立统一是计算机科学的一个基本概念。

**同步行为**对应内存中顺序执行的处理器指令。每条指令都会严格按照它们出现的顺序来执行，而每条指令执行后也能立即获得存储在系统本地(如寄存器或系统内存)的信息。

```js
// 同步操作的例子
let x = 3;
x = x + 4;
```

在程序执行的每一步，都可以推断出程序的状态。这是因为后面的指令总是在前面的指令完成后才会执行。等到最后一条指定执行完毕，存储在 x 的值就立即可以使用。

相对地，**异步行为**类似于系统中断，即当前进程外部的实体可以触发代码执行。异步操作经常是必要的，因为强制进程等待一个长时间的操作通常是不可行的(同步操作则必须要等)。如果代码要访问 一些高延迟的资源，比如向远程服务器发送请求并等待响应，那么就会出现长时间的等待。

```js
// 异步操作的例子
let x = 3;
setTimeout(() => x = x + 4, 1000);
```

这段程序最终与同步代码执行的任务一样，都是把两个数加在一起，但这一次执行线程不知道 x 值何时会改变，因为这取决于回调何时从消息队列出列并执行。

为了让后续代码能够使用 x，异步执行的函数需要在更新 x 的值以后通知其他代码。如果程序不需要这个值，那么就只管继续执行，不必等待这个结果了。

## 回调函数
异步行为是 JavaScript 的基础，但以前的实现不理想。在早期的 JavaScript 中，只支持定义回调函数 来表明异步操作完成。串联多个异步操作是一个常见的问题，通常需要深度嵌套的回调函数(俗称“回调地狱”)来解决。

## 期约

### 期约的基本概念
期约是对尚不存在结果的一个替身。同一时期的计算机科学家还使用了“终局”(eventual)、“期许”(future)、“延迟”(delay)和“迟付”(deferred)等术语指代同样的概念。所有这些概念描述的都是一种异步程序执行的机制。

#### 创建期约
ECMAScript 6 新增的引用类型 Promise，可以通过 new 操作符来实例化，创建新期约时需要传入执行器(executor)函数作为参数。
```js
let p = new Promise(() => {});
setTimeout(console.log, 0, p);  // Promise <pending>
```

#### 期约状态机
期约是一个有状态的对象，期约的状态代表期约是否完成，期约可能处于如下 3 种状态之一:
* 待定(pending)：表示期约尚未开始或者正在执行中
* 兑现(fulfilled，有时候也称为“解决”，resolved)：表示期约已经成功完成
* 拒绝(rejected)：表示期约没有成功完成

待定(pending)是期约的最初始状态。在待定状态下，期约可以落定(settled)为代表成功的兑现(fulfilled)状态，或者代表失败的拒绝(rejected)状态。无论落定为哪种状态都是不可逆的。只要从待定转换为兑现或拒绝，期约的状态就不再改变。而且，也不能保证期约必然会脱离待定状态。

期约的状态是私有的，不能直接通过 JavaScript 检测，也不能被外部 JavaScript 代码修改。为了避免根据读取到的期约状态，以同步方式处理期约对象，期约故意将异步行为封装起来，从而隔离外部的同步代码。

#### 解决值/拒绝理由

期约封装的异步操作会实际生成某个值，而程序期待期约状态改变时可以访问这个值。相应地，如果期约被拒绝，程序就会期待期约状态改变时可以拿到拒绝的理由。

每个期约只要状态切换为兑现，就会有一个私有的内部值(value)。每个期约只要状态切换为拒绝，就会有一个私有的内部理由(reason)。无论是值还是理由，都是包含原始值或对象的不可修改的引用。二者都是可选的，而且默认值为 undefined。在期约到达某个落定状态时执行的异步代码始终会收到这个值或理由。

#### 执行器函数
由于期约的状态是私有的，所以只能在内部进行操作。内部操作在期约的执行器函数中完成。执行器函数主要有两项职责：初始化期约的异步行为和控制状态的最终转换。

控制期约状态的转换是通过调用它的两个函数参数实现的，这两个函数参数通常都命名为 resolve() 和 reject()。调用 resolve() 会把状态切换为兑现，调用 reject() 会把状态切换为拒绝。另外，调用 reject() 也会抛出错误。

```js
let p1 = new Promise((resolve, reject) => resolve());
setTimeout(console.log, 0, p1); // Promise <resolved>
let p2 = new Promise((resolve, reject) => reject());
setTimeout(console.log, 0, p2); // Promise <rejected> 
// Uncaught error (in promise)    控制台上打印出未被捕获的错误
```

因为执行器函数是期约的初始化程序，所以执行器函数是同步执行的，即在初始化时立刻运行执行器函数。

无论 resolve()和 reject()中的哪个被调用，状态转换都不可撤销了。继续修改状态会静默失败，没有效果。

为避免期约卡在待定状态，可以添加一个定时退出功能。

#### Promise.resolve()
期约并非一开始就必须处于待定状态，然后通过执行器函数才能转换为落定状态。通过调用Promise.resolve()静态方法，可以实例化一个解决的期约。下面两个期约实例实际上是一样的：

```js
let p1 = new Promise((resolve, reject) => resolve());
let p2 = Promise.resolve();
```

解决的期约的值会传给Promise.resolve()的第一个参数，多余的参数会忽略。使用这个静态方法，实际上可以把任何值都转换为一个期约：
```js
setTimeout(console.log, 0, Promise.resolve());
// Promise <resolved>: undefined

setTimeout(console.log, 0, Promise.resolve(3));
// Promise <resolved>: 3

setTimeout(console.log, 0, Promise.resolve(4, 5, 6));
// Promise <resolved>: 4
```

对这个静态方法而言，如果传入的参数本身是一个期约，那它的行为就类似于一个空包装。因此，Promise.resolve()可以说是一个幂等方法，这个幂等性会保留传入期约的状态，如下所示：
```js
let p = new Promise(() => {});
setTimeout(console.log, 0, p); // Promise <pending>
setTimeout(console.log, 0, Promise.resolve(p)); // Promise <pending>
setTimeout(console.log, 0, p === Promise.resolve(p)); // true
```

这个静态方法能够包装任何非期约值，包括错误对象，并将其转换为解决的期约。

#### Promise.reject()
Promise.reject()会实例化一个拒绝的期约并抛出一个异步错误 (这个错误不能通过 try/catch 捕获，而只能通过拒绝处理程序捕获)。下面的两个期约实例实际上是一样的:
```js
let p1 = new Promise((resolve, reject) => reject());
let p2 = Promise.reject();
```

这个拒绝的期约的理由就是传给 Promise.reject() 的第一个参数。这个参数也会传给后续的拒绝处理程序:
```js
let p = Promise.reject(3);
setTimeout(console.log, 0, p); // Promise <rejected>: 3
p.then(null, (e) => setTimeout(console.log, 0, e)); // 3
```

Promise.reject()并没有幂等逻辑。如果给它传一个期约对象，则这个期约会成为它返回的拒绝期约的理由。

#### 同步/异步执行的二元性
Promise 的设计很大程度上会导致一种完全不同于 JavaScript 的计算模式。

期约真正的异步特性:它们是同步对象(在同步执行模式中使用)，但也是异步执行模式的媒介。

拒绝期约的错误并没有抛到执行同步代码的线程里，而是通过浏览器异步消息队列来处理的。因此，同步代码的 try/catch 块并不能捕获该错误，需要通过异步模式捕获错误。代码一旦开始以异步模式执行，则唯一与之交互的方式就是使用异步结构——更具体地说，就是期约的方法。



### 期约的实例方法
期约实例的方法是连接外部同步代码与内部异步代码之间的桥梁。这些方法可以访问异步操作返回的数据，处理期约成功和失败的结果，连续对期约求值，或者添加只有期约进入终止状态时才会执行的代码。

#### 实现 Thenable 接口
在 ECMAScript 暴露的异步结构中，任何对象都有一个 then()方法。这个方法被认为实现了 Thenable 接口。

ECMAScript 的 Promise 类型实现了 Thenable 接口。

#### Promise.prototype.then()

##### 参数
Promise.prototype.then()是为期约实例添加处理程序的主要方法。这个 then() 方法接收最多两个参数:onResolved 处理程序和 onRejected 处理程序。这两个参数都是可选的，如果提供的话，则会在期约分别进入“兑现”和“拒绝”状态时执行。传给 then() 的任何非函数类型的参数都会被静默忽略。因为期约只能转换为最终状态一次，所以这两个操作一定是互斥的。

##### 返回值
Promise.prototype.then()方法返回一个新的期约实例，这个新期约实例基于 onResovled 处理程序的返回值构建。换句话说，该处理程序的返回值会通过 Promise.resolve()包装来生成新期约。

如果没有提供这个处理程序，则 Promise.resolve()就会包装上一个期约解决之后的值。

如果没有显式的返回语句，则 Promise.resolve()会包装默认的返回值 undefined。如果有显式的返回值，则 Promise.resolve()会包装这个值。

在then()中抛出异常会返回拒绝的期约，但返回错误值不会触发拒绝行为，而会把错误对象包装在一个解决的期约中。

onRejected 处理程序返回的值也会被 Promise.resolve() 包装。拒绝处理程序在捕获异步错误后返回一个解决期约。

#### Promise.prototype.catch()
Promise.prototype.catch()方法用于给期约添加拒绝处理程序。这个方法只接收一个参数:onRejected 处理程序。事实上，这个方法就是一个语法糖，调用它就相当于调用 Promise.prototype.then(null, onRejected)。

#### Promise.prototype.finally()
Promise.prototype.finally()方法用于给期约添加onFinally处理程序，这个处理程序在期约转换为解决或拒绝状态时都会执行。这个方法可以避免 onResolved 和 onRejected 处理程序中出现冗余代码。但 onFinally 处理程序没有办法知道期约的状态是解决还是拒绝，所以这个方法主要用于添加清理代码。

Promise.prototype.finally()方法返回一个新的期约实例，在大多数情况下它将表现为父期约的传递。

如果返回的是一个待定的期约，或者 onFinally 处理程序抛出了错误(显式抛出或返回了一个拒绝期约)，则会返回相应的期约(待定或拒绝)。

#### 非重入期约方法
当期约进入落定状态时，与该状态相关的处理程序仅仅会被排期，而非立即执行。跟在添加这个处理程序的代码之后的同步代码一定会在处理程序之前先执行。即使期约一开始就是与附加处理程序关联的状态，执行顺序也是这样的。这个特性由 JavaScript 运行时保证，被称为“非重入”(non-reentrancy)特性。

#### 邻近处理程序的执行顺序
如果给期约添加了多个处理程序，当期约状态变化时，相关处理程序会按照添加它们的顺序依次执行。

#### 传递解决值和拒绝理由
到了落定状态后，期约会提供其解决值(如果兑现)或其拒绝理由(如果拒绝)给相关状态的处理程序。

在执行函数中，解决的值和拒绝的理由是分别作为 resolve()和 reject()的第一个参数往后传的。然后，这些值又会传给它们各自的处理程序，作为 onResolved 或 onRejected 处理程序的唯一参数。

#### 拒绝期约与拒绝错误处理
拒绝期约类似于 throw()表达式，因为它们都代表一种程序状态，即需要中断或者特殊处理。在期约的执行函数或处理程序中抛出错误会导致拒绝，对应的错误对象会成为拒绝的理由。



### 期约连锁与期约合成
多个期约组合在一起可以构成强大的代码逻辑。这种组合可以通过两种方式实现:期约连锁与期约合成。前者就是一个期约接一个期约地拼接，后者则是将多个期约组合为一个期约。

#### 期约连锁
把期约逐个地串联起来是一种非常有用的编程模式。之所以可以这样做，是因为每个期约实例的方法(then()、catch()和finally())都会返回一个新的期约对象，而这个新期约又有自己的实例方法。这样连缀方法调用就可以构成所谓的“期约连锁”。

#### 期约图
一个期约可以有任意多个处理程序，所以期约连锁可以构建**有向非循环图的**结构。这样，每个期约都是图中的一个节点，而使用实例方法添加的处理程序则是有向顶点。因为图中的每个节点都会等待前一个节点落定，所以图的方向就是期约的解决或拒绝顺序。

下面的例子展示了一种期约有向图，也就是二叉树:
```js
//      A
//    / \
//    B  C
//   /\ /\
//  D E F G
let A = new Promise((resolve, reject) => {
  console.log('A');
  resolve();
});
let B = A.then(() => console.log('B'));
let C = A.then(() => console.log('C'));
B.then(() => console.log('D'));
B.then(() => console.log('E'));
C.then(() => console.log('F'));
C.then(() => console.log('G'));

// A
// B
// C
// D
// E
// F
// G
```

期约的处理程序是按照它们添加的顺序执行的，由于期约的处理程序是先添加到消息队列，然后才逐个执行，因此构成了层序遍历。

#### 期约合成
Promise 类提供两个将多个期约实例组合成一个期约的静态方法:Promise.all()和 Promise.race() 而合成后期约的行为取决于内部期约的行为。

##### Promise.all()
Promise.all()静态方法创建的期约会在一组期约全部解决之后再解决。这个静态方法接收一个可迭代对象，返回一个新期约。

合成的期约只会在每个包含的期约都解决之后才解决。如果至少有一个包含的期约待定，则合成的期约也会待定。如果有一个包含的期约拒绝，则合成的期约也会拒绝。

如果所有期约都成功解决，则合成期约的解决值就是所有包含期约解决值的数组，按照迭代器顺序。如果有期约拒绝，则第一个拒绝的期约会将自己的理由作为合成期约的拒绝理由。之后再拒绝的期约不会影响最终期约的拒绝理由。不过，这并不影响所有包含期约正常的拒绝操作，合成的期约会静默处理所有包含期约的拒绝操作。

##### Promise.race()
Promise.race()静态方法返回一个包装期约，是一组集合中最先解决或拒绝的期约的镜像。这个方法接收一个可迭代对象，返回一个新期约。

Promise.race()不会对解决或拒绝的期约区别对待。无论是解决还是拒绝，只要是第一个落定的期约，Promise.race()就会包装其解决值或拒绝理由并返回新期约。

如果有一个期约拒绝，只要它是第一个落定的，就会成为拒绝合成期约的理由。之后再拒绝的期约不会影响最终期约的拒绝理由。不过，这并不影响所有包含期约正常的拒绝操作，合成的期约会静默处理所有包含期约的拒绝操作。

#### 串行期约合成
异步产生值并将其传给处理程序，基于后续期约使用之前期约的返回值来串联期约是期约的基本功能，可以把任意多个函数作为处理程序合成一个连续传值的期约连 锁：
```js
function compose(...fns) {
return (x) => fns.reduce((promise, fn) => promise.then(fn), Promise.resolve(x))
}
```

### 期约扩展
ES6 期约实现是很可靠的，但它也有不足之处。比如，很多第三方期约库实现中具备而 ECMAScript 规范却未涉及的两个特性:期约取消和进度追踪。

#### 期约取消
ES6 期约被认为是“激进的”：只要期约的逻辑开始执行，就没有办法阻止它执行到完成。

实际上，可以在现有实现基础上提供一种临时性的封装，以实现取消期约的功能——“取消令牌”(cancel token)。生成的令牌实例提供了一个接口，利用这个接口可以取消期约；同时也提供了一个期约的实例，可以用来触发取消后的操作并求值取消状态。

下面是 CancelToken 类的一个基本实例:
```js
class CancelToken {
    constructor(cancelFn) {
        this.promise = new Promise((resolve, reject) => {
            cancelFn(resolve);
        });
    }
}
```

这个类包装了一个期约，把解决方法暴露给了 cancelFn 参数。这样，外部代码就可以向构造函数中传入一个函数，从而控制什么情况下可以取消期约。这里期约是令牌类的公共成员，因此可以给它添加处理程序以取消期约。


#### 期约进度通知
执行中的期约可能会有不少离散的“阶段”，在最终解决之前必须依次经过。某些情况下，监控期约的执行进度会很有用。ECMAScript 6 期约并不支持进度追踪，但是可以通过扩展来实现。

一种实现方式是扩展 Promise 类，为它添加 notify()方法，如下所示:
```js
class TrackablePromise extends Promise {
    constructor(executor) {
        const notifyHandlers = [];
        super((resolve, reject) => {
            return executor(resolve, reject, (status) => {
                notifyHandlers.map((handler) => handler(status));
            });
        });

        this.notifyHandlers = notifyHandlers;
      }

      notify(notifyHandler) {
        this.notifyHandlers.push(notifyHandler);
        return this;
    }
}
```

## 异步函数
异步函数，也称为“async/await”(语法关键字)，这个特性从行为和语法上都增强了 JavaScript，让以同步方式写的代码能够异步执行。

### async
async 关键字用于声明异步函数。这个关键字可以用在函数声明、函数表达式、箭头函数和方法上:
```js
async function foo() {}

let bar = async function() {};

let baz = async () => {};

class Qux {
    async qux() {}
}
```

使用 async 关键字可以让函数具有异步特征，但总体上其代码仍然是同步求值的。而在参数或闭包方面，异步函数仍然具有普通 JavaScript 函数的正常行为。

不过，异步函数如果使用 return 关键字返回了值(如果没有 return 则会返回 undefined)，这个值会被 Promise.resolve() 包装成一个期约对象。异步函数始终返回期约对象，在函数外部调用这个函数可以得到它返回的期约。当然，直接返回一个期约对象也是一样的。

异步函数的返回值期待(但实际上并不要求)一个实现 thenable 接口的对象，但常规的值也可以。如果返回的是实现 thenable 接口的对象，则这个对象可以由提供给 then() 的处理程序“解包”。如果不是，则返回值就被当作已经解决的期约。

与在期约处理程序中一样，在异步函数中抛出错误会返回拒绝的期约。不过，拒绝期约的错误不会被异步函数捕获。

### await
使用 await 关键字可以暂停异步函数代码的执行，等待期约解决。await 关键字会暂停执行异步函数后面的代码，让出 JavaScript 运行时的执行线程。await 关键字同样是尝试“解包”对象的值，然后将这个值传给表达式，再异步恢复异步函数的执行。

await 关键字的用法与 JavaScript 的一元操作一样。它可以单独使用，也可以在表达式中使用。

await 关键字期待(但实际上并不要求)一个实现 thenable 接口的对象，但常规的值也可以。如 果是实现 thenable 接口的对象，则这个对象可以由 await 来“解包”。如果不是，则这个值就被当作 已经解决的期约。