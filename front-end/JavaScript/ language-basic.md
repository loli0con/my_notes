# 语言基础

## 结合方式
JavaScript是通过`<script>`元素插入到HTML页面中的。这个元素可用于把JavaScript代码嵌入到HTML页面中，跟其他标记混合在一起，也可用于引入保存在外部文件中的JavaScript。

### 嵌入
在html页面中使用script标签来书写JavaScript代码（简单）
```html
<script type="text/javascript">
/* JavaScript代码 */
</script>
```

### 引入
使用script标签引入单独的JavaScript代码文件（正规）
```html
<script type="text/javascript" src="code.js"></script>
```

### 运行流程
在不使用 defer 和 async 属性的情况下，包含在`<script>`元素中的代码必须严格按次序解释。对不推迟执行的脚本，浏览器必须解释完位于`<script>`元素中的代码，然后才能继续渲染页面的剩余部分。

#### defer
可以使用 defer 属性把脚本推迟到文档渲染完毕后再执行。  
推迟的脚本原则上按照它们被列出的次序执行。

#### asyn
可以使用 async 属性表示脚本不需要等待其他脚本，同时也不阻塞文档渲染，即异步加载。  
异步脚本不能保证按照它们在页面中出现的次序执行。

### 不支持
通过使用`<noscript>`元素，可以指定在浏览器不支持脚本时显示的内容。如果浏览器支持并启用脚本，则`<noscript>`元素中的任何内容都不会被渲染。

## Hello World
```js
window.alert('hello world!'); // 弹框提示
console.log('hello world'); // 浏览器的控制台输出
```


## 变量

### 声明变量
有 3 个关键字可以声明变量：var、const 和 let。

#### var
1. 使用 var 操作符定义的变量会成为包含它的函数的局部变量。
2. 定义变量时省略 var 操作符，可以创建一个全局变量。
3. var声明的变量会自动提升到函数作用域顶部。

#### let
1. let 声明的范围是块作用域。
2. let 声明的变量不会在作用域中被提升。
3. 使用 let 在全局作用域中声明的变量不会成为 window 对象的属性(var 声明的变量则会)。
4. 在使用 let 声明迭代变量时，JavaScript 引擎在后台会为每个迭代循环声明一个新的迭代变量。

#### const
1. const 的行为与 let 基本相同。
2. 使用 const 声明变量时必须同时初始化变量。
3. 修改 const 声明的变量会导致运行时错误。



## 数据类型
ECMAScript 有 6 种简单数据类型(也称为原始类型):Undefined、Null、Boolean、Number、 String 和 Symbol。
还有一种复杂数据类型叫 Object(对象)，Object 是一种无序名值对的集合。

### typeof操作符
typeof 操作符（不是函数，不需要参数）用来确定任意变量的数据类型，对一个值使用 typeof 操作符会返回下列字符串之一:
* "undefined"表示值未定义;
* "boolean"表示值为布尔值;
* "string"表示值为字符串;
* "number"表示值为数值;
* "object"表示值为对象(而不是函数)或null;
* "function"表示值为函数;
* "symbol"表示值为符号。

### Undefined类型
Undefined 类型只有一个值，就是特殊值 undefined。当使用 var 或 let 声明了变量但没有初始化时，就相当于给变量赋予了 undefined 值。

增加这个特殊值的目的就是为了正式明确空对象指针(null)和未初始化变量的区别。

undefined 是一个假值（false）。

#### 未声明的变量
在对(已声明但)未初始化的变量调用 typeof 时，返回的结果是"undefined"；但对未声明的变量调用它时，返回的结果还是"undefined"。

对未声明的变量，只能执行一个有用的操作，就是对它调用 typeof。对未声明的变量调用 delete 也不会报错，但这个操作没什么用。

### Null类型
Null 类型同样只有一个值，即特殊值 null。逻辑上讲，null 值表示一个空对象指针，这也是给 typeof 传一个 null 会返回"object"的原因。

用等于操作符(==)比较 null 和 undefined 始终返回 true。

任何时候，只要变量要保存对象，而当时又没有那个对象可保存，就要用 null 来填充该变量。这样就可以保持 null 是空对象指针的语义，并进一步将其与 undefined 区分开来。

null 是一个假值（false）。

### Boolean类型
Boolean(布尔值)类型有两个字面值:true 和 false。

虽然布尔值只有两个，但所有其他 ECMAScript 类型的值都有相应布尔值的等价形式。要将一个其他类型的值转换为布尔值，可以调用特定的Boolean()转型函数。流控制语句会自动执行其他类型值到布尔值的转换。

|数据类型|转换为 true 的值|转换为 false 的值|
|Boolean|true|false|
|String|非空字符串|""(空字符串)|
|Number|非零数值(包括无穷值)|0、NaN|
|Object|任意对象|null|
|Undefined|N/A(不存在)|undefined|
||||


### Number类型
Number 类型使用 IEEE 754 格式表示整数和浮点值(在某些语言中也叫双精度值)。字面量支持十进制(9)、八进制(0o7)、十六进制(0xf)。

要定义浮点值，数值中必须包含小数点，而且小数点后面必须至少有一个数字。在小数点后面没有数字(或只有0)的情况下，数值就会变成整数。浮点值的精确度最高可达 17 位小数，但在算术计算中不精确，因此永远不要测试某个特定的浮点值。

对于非常大或非常小的数值，浮点值可以用科学记数法来表示。ECMAScript 中科学记数法的格式要求是一个数值(整数或浮点数)后跟一个大写或小写的字母 e，再加上一个要乘的 10 的多少次幂。默认情况下，ECMAScript 会将小数点后至少包含 6 个零的浮点值转换为科学记数法。

#### 范围
ECMAScript 可以表示的最小数值保存在 Number.MIN_VALUE 中，可以表示的最大数值保存在 Number.MAX_VALUE 中。

如果某个计算得到的数值结果超出了 JavaScript 可以表示的范围，那么这个数值会被自动转换为一个特殊的Infinity(无穷)值。任何无法表示的负数以-Infinity(负无穷大)表示，任何无法表示的正数以Infinity(正无穷大)表示。

如果计算返回正 Infinity 或负 Infinity，则该值将不能再进一步用于任何计算。要确定一个值是不是有限大(即介于 JavaScript 能表示的最小值和最大值之间)，可以使用isFinite()函数。

#### NaN
有一个特殊的数值叫 NaN，意思是“不是数值”(Not a Number)，用于表示本来要返回数值的操作失败了(而不是抛出错误)。例如除0操作。

在 ECMAScript 中，0、+0 或-0 相除会返回 NaN，如果分子是非 0 值，分母是有符号 0 或无符号 0，则会返回 Infinity 或 -Infinity。

NaN有几个特性：
1. 任何涉及 NaN 的操作始终返回 NaN
2. NaN 不等于包括 NaN 在内的任何值

ECMAScript 提供了isNaN()函数。该函数接收一个参数，可以是任意数据类型，然后判断这个参数是否“不是数值”。把一个值传给isNaN()后，该函数会尝试把它转换为数值。任何不能转换为数值的值都会导致这个函数返回 true。

isNaN()可以用于测试对象：首先会调用对象的valueOf()方法，然后再确定返回的值是否可以转换为数值。如果不能，再调用 toString()方法，并测试其返回值。


#### 转换
有 3 个函数可以将非数值转换为数值:Number()、parseInt()和 parseFloat()。Number()是转型函数，可用于任何数据类型。后两个函数主要用于将字符串转换为数值。

##### Number()
Number()函数基于如下规则执行转换：
* 布尔值，true 转换为 1，false 转换为 0。
* 数值，直接返回。
* null，返回 0。
* undefined，返回 NaN。
* 字符串，应用以下规则：
  * 如果字符串包含数值字符，包括数值字符前面带加、减号的情况，则转换为一个十进制数值(忽略前面的零)。
  * 如果字符串包含有效的浮点值格式，则会转换为相应的浮点值(忽略前面的零)。
  * 如果字符串包含有效的十六进制格式，则会转换为与该十六进制值对应的十进制整数值。
  * 如果是空字符串(不包含字符)，则返回 0。
  * 如果字符串包含除上述情况之外的其他字符，则返回 NaN。
* 对象，调用 valueOf()方法，并按照上述规则转换返回的值。如果转换结果是 NaN，则调用 toString()方法，再按照转换字符串的规则转换。

##### parseInt()
parseInt()函数更专注于字符串是否包含数值模式：  
* 字符串最前面的空格会被忽略，从第一个非空格字符开始转换。如果第一个字符不是数值字符、加号或减号，parseInt()立即 返回 NaN。这意味着空字符串也会返回 NaN(这一点跟 Number()不一样，它返回 0)。如果第一个字符是数值字符、加号或减号，则继续依次检测每个字符，直到字符串末尾，或碰到非数值字符。
* parseInt()函数也能识别不同的整数格式(十进制、八进制、十六进制)。
* parseInt()接收第二个参数，用于指定底数(进制数)。

##### parseFloat()
parseFloat()函数的工作方式跟parseInt()函数类似：
* 从位置 0 开始检测每个字符，解析到字符串末尾或者解析到一个无效的浮点数值字符为止。这意味着第一次出现的小数点是有效的，但第二次出现的小数点就无效了，此时字符串的剩余字符都会被忽略。
* parseFloat()函数始终忽略字符串开头的零。
* parseFloat()只解析十进制值，因此不能指定底数。
* 如果字符串表示整数(没有小数点或者小 数点后面只有一个零)，则 parseFloat()返回整数。


### String类型
String(字符串)数据类型表示零或多个 16 位 Unicode 字符序列。字符串可以使用双引号(")、单引号(')或反引号(`)标示。

#### 字面量
字符串数据类型包含一些字符字面量，用于表示非打印字符或有其他用途的字符，如下表所示:
|字面量|含义|
|\n|换行|
|\t|制表|
|\b|退格|
|\r|回车|
|\f|换页|
|\\|反斜杠(\)|
|\'|单引号(')，在字符串以单引号标示时使用|
|\"|双引号(")，在字符串以双引号标示时使用|
|\`|反引号(`)，在字符串以反引号标示时使用|
|\xnn|以十六进制编码 nn 表示的字符(其中 n 是十六进制数字 0~F)|
|\unnnn|以十六进制编码 nnnn 表示的 Unicode 字符(其中 n 是十六进制数字 0~F)|

这些字符字面量可以出现在字符串中的任意位置，且作为单个字符被解释。

字符串的长度可以通过其 length 属性获取，如果字符串中包含双字节字符，那么length属性返回的值可能不是准确的字符数。


#### 特点
ECMAScript 中的字符串是不可变的(immutable)，意思是一旦创建，它们的值就不能变了。

#### 转换
有两种方式把一个值转换为字符串。

##### toString()方法
几乎所有值都有的 toString()方法，这个方法返回当前值的字符串等价物。null 和 undefined 值没有 toString()方法。

在对数值调用这个方法时，toString()可以接收一个底数参数，即以什么底数来输出数值的字符串表示。默认情况下，toString()返回数值的十进制字符串表示。

##### String()转型函数
String()转型函数始终会返回表示相应类型值的字符串，String()函数遵循如下规则：
* 如果值有 toString()方法，则调用该方法(不传参数)并返回结果。
* 如果值是 null，返回"null"。
* 如果值是 undefined，返回"undefined"。

#### 模板字面量
ECMAScript 6 新增了使用模板字面量定义字符串的能力（使用反引号），模板字面量保留空格和换行字符，可以跨行定义字符串。

技术上讲，模板字面量不是字符串，而是一种特殊的 JavaScript 句法表达式，只不过求值后得到的是字符串。

##### 插值
模板字面量最常用的一个特性是支持字符串插值，通过在${}中使用一个 JavaScript 表达式实现，所有插入的值都会使用 toString()强制转型为字符串。

嵌套的模板字符串无须转义。

##### 标签函数
模板字面量也支持定义标签函数(tag function)，而通过标签函数可以自定义插值行为。标签函数会接收被插值记号分隔后的模板和对每个表达式求值的结果。

标签函数本身是一个常规函数，通过前缀到模板字面量来应用自定义行为。标签函数接收到的参数依次是原始字符串数组和对每个表达式求值的结果，函数的返回值是对模板字面量求值得到的字符串。

对于有 n 个插值的模板字面量，传给标签函数的表达式参数的个数始终是 n，而传给标签函数的第一个参数所包含的字符串个数则始终是 n+1。因此，如果你想把这些字符串和对表达式求值的结果拼接起来作为默认返回的字符串，可以这样做:
```javascript
// 这个标签函数描述/模仿了“默认的插值行为”
// strings 参数接收到了原始字符串数组，个数为 n+1
// expressions 参数接收到了表达式数组，个数为 n
function zipTag(strings, ...expressions) {
    return strings[0] +
        expressions.map((e, i) => `${e}${strings[i + 1]}`)
                .join('');
}
```

##### 原始字符串
使用模板字面量也可以直接获取原始的模板字面量内容(如换行符或 Unicode 字符)，而不是被转换后的字符表示。为此，可以使用默认的 String.raw 标签函数：
```js
// \u00A9 是版权符号 ©
// \n 是换行符
console.log(String.raw`\u00A9\n`); // \u00A9\n
```

另外，也可以通过标签函数的第一个参数，即*字符串数组的.raw属性*取得每个字符串的原始内容:
```js
function printRaw(strings) { // 不接收每个表达式求值的结果
    console.log('Actual characters:');
    for (const string of strings) {
        console.log(string);
    }
    console.log('Escaped characters;');
    for (const rawString of strings.raw) {
        console.log(rawString);
    }
}
printRaw`\u00A9${ 'and' }\n`;
// Actual characters:
// ©
//(换行符)
// Escaped characters:
// \u00A9
// \n
```

### Symbol类型
Symbol(符号)是 ECMAScript 6 新增的数据类型。符号是原始值，且符号实例是唯一、不可变的。符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险。

#### 基本用法
符号需要使用 Symbol()函数初始化。因为符号本身是原始类型，所以 typeof 操作符对符号返回 symbol。

调用 Symbol()函数时，也可以传入一个字符串参数作为对符号的**描述**(description)，将来可以通过这个字符串来调试代码。但是，这个字符串参数与符号定义或标识完全无关。

Symbol()函数不能与 new 关键字一起作为构造函数使用。这样做是为了避免创建符号包装对象，如果确实想使用符号包装对象，可以借用 Object()函数。

#### 全局符号注册表
如果运行时的不同部分需要共享和重用符号实例，那么可以用一个字符串作为**键**，在全局符号注册表中创建并重用符号。为此，需要使用 Symbol.for()方法。

Symbol.for()对每个字符串**键**都执行幂等操作。第一次使用某个字符串调用时，它会检查全局运行时注册表，发现不存在对应的符号，于是就会生成一个新符号实例并添加到注册表中。后续使用相同字符串的调用同样会检查注册表，发现存在与该字符串对应的符号，然后就会返回该符号实例。

即使采用相同的符号**描述**，在全局注册表中定义的符号跟使用Symbol()定义的符号也并不等同。

全局注册表中的符号必须使用字符串**键**来创建，因此作为参数传给 Symbol.for()的任何值都会被转换为字符串。此外，注册表中使用的**键**同时也会被用作符号**描述**。

还可以使用 Symbol.keyFor()来查询全局注册表，这个方法接收符号，返回该全局符号对应的字符串**键**。如果查询的不是全局符号，则返回 undefined。如果传给 Symbol.keyFor()的不是符号，则该方法抛出 TypeError。

#### 使用符号作为属性
是可以使用字符串或数值作为属性的地方，都可以使用符号。这就包括了对象字面量属性和 Object.defineProperty()/Object.defineProperties()定义的属性。

todo
todo
todo
todo
todo
todo
todo

### Object类型
ECMAScript 中的对象其实就是一组数据和功能的集合。对象通过 new 操作符后跟对象类型的名称来创建。

ECMAScript 中的 Object 是派生其他对象的基类，Object 类型的所有属性和方法在派生的对象上同样存在。
每个 Object 实例都有如下属性和方法：
* constructor: 用于创建当前对象的函数。在`new Object()`的例子中，这个属性的值就是 Object() 函数。
* hasOwnProperty(propertyName):用于判断当前对象实例(不是原型)上是否存在给定的属性。要检查的属性名必须是字符串(如 o.hasOwnProperty("name"))或符号。
* isPrototypeOf(object):用于判断当前对象是否为另一个对象的原型。
* propertyIsEnumerable(propertyName):用于判断给定的属性是否可以使用 for-in 语句枚举。与 hasOwnProperty()一样，属性名必须是字符串。
* toLocaleString():返回对象的字符串表示，该字符串反映对象所在的本地化执行环境。
* toString():返回对象的字符串表示。
* valueOf():返回对象对应的字符串、数值或布尔值表示。通常与 toString()的返回值相同。

严格来讲，ECMA-262 中对象的行为不一定适合 JavaScript 中的其他对象。比如浏览器环境中的 BOM 和 DOM 对象，都是由宿主环境定义和提供的宿主对象。而宿主对象不受 ECMA-262 约束，所以它们可能会也可能不会继承 Object。


## 操作符
ECMAScript 中的操作符是独特的，因为它们可用于各种值，包括字符串、数值、布尔值，甚至还有对象。在应用给对象时，操作符通常会调用 valueOf()和/或 toString()方法来取得可以计算的值。


### 一元操作符
只操作一个值的操作符叫一元操作符(unary operator)。

#### 递增/递减操作符
递增和递减操作符有两个版本：
* 前缀版：前缀版就是位于要操作的变量前头，变量的值都会在语句被求值之前改变
  * 前缀递增操作符会给数值加 1，把两个加号(++)放到变量前头
  * 前缀递减操作符会给数值减 1，把两个减号(--)放到变量前头
* 后缀版：后缀版就是位于要操作的变量后头，变量的值都会在语句被求值之后改变
  * 后缀递增操作符会给数值加 1，把两个加号(++)放到变量后头
  * 后缀递减操作符会给数值减 1，把两个减号(--)放到变量后头

这 4 个操作符可以作用于任何值，遵循如下规则：
* 对于字符串，如果是有效的数值形式，则转换为数值再应用改变。变量类型从字符串变成数值。
* 对于字符串，如果不是有效的数值形式，则将变量的值设置为 NaN 。变量类型从字符串变成数值。
* 对于布尔值，如果是 false，则转换为 0 再应用改变。变量类型从布尔值变成数值。
* 对于布尔值，如果是 true，则转换为 1 再应用改变。变量类型从布尔值变成数值。
* 对于浮点值，加 1 或减 1。
* 如果是对象，则调用其valueOf()方法取得可以操作的值。对得到的值应用上述规则。如果是 NaN，则调用 toString()并再次应用其他规则。变量类型从对象变成数值。

#### 一元加和减
一元加由一个加号(+)表示，放在变量前头，对数值没有任何影响。如果将一元加应用到非数值，则会执行与使用 Number()转型函数一样的类型转换:布尔值 false 和 true 转换为 0 和 1，字符串根据特殊规则进行解析，对象会调用它们的 valueOf() 和/或 toString() 方法以得到可以转换的值。

一元减由一个减号(-)表示，放在变量前头，主要用于把数值变成负值。在应用到非数值时，一元减会遵循与一元加同样的规则，先对它们进行转换，然后再取负值。


### 位操作符
ECMAScript 12 中的所有数值都以 IEEE 754 64 位格式存储，但位操作并不直接应用到 64 位表示，而是先把值转换为 32 位整数，再进行位操作，之后再把结果转换为 64 位。对开发者而言，只需要考虑 32 位整数即可。

有符号整数使用 32 位的前 31 位表示整数值。第 32 位表示数值的符号，如 0 表示正，1 表示负。这一位称为符号位(sign bit)，它的值决定了数值其余部分的格式。在处理有符号整数时，开发者无法访问第 31 位(符号位)。正值以真正的二进制格式存储，即 31 位中的每一位都代表 2 的幂。第一位(称为第 0 位)表示 2^0，第二位表示 2^1，依此类推。如果一个位是空的，则以 0 填充，相当于忽略不计。

负值以一种称为二补数(或补码)的二进制编码存储。一个数值的二补数通过如下 3 个步骤计算得到:
1. 确定绝对值的二进制表示；
2. 找到数值的一补数(或反码)，换句话说，就是每个 0 都变成 1，每个 1 都变成 0;
3. 给结果加 1。

特殊值 NaN 和 Infinity 在位操作中都会被当成 0 处理，如果将位操作符应用到非数值，那么首先会使用Number()函数将该值转换为数值(这个过程是自动的)，然后再应用位操作。最终结果是数值。

#### 按位非
按位非操作符用波浪符(~)表示，它的作用是返回数值的一补数。按位非的最终效果是对数值取反并减 1。

#### 按位与
按位与操作符用和号(&)表示，有两个操作数。本质上，按位与就是将两个数的每一个位对齐，然后基于真值表中的规则，对每一位执行相应的与操作。

|第一个数值的位|第二个数值的位|结果|
||||
|1|1|1|
|1|0|0|
|0|1|0|
|0|0|0|

#### 按位或
按位或操作符用管道符(|)表示，同样有两个操作数。按位或遵循如下真值表:
|第一个数值的位|第二个数值的位|结果|
||||
|1|1|1|
|1|0|1|
|0|1|1|
|0|0|0|

#### 按位异或
按位异或用脱字符(^)表示，同样有两个操作数。
|第一个数的位|第二个数的位|结果|
|1|1|0|
|1|0|1|
|0|1|1|
|0|0|0|

#### 左移
左移操作符用两个小于号(<<)表示，会按照指定的位数将数值的所有位向左移动。左移会以 0 填充空位，让结果是完整的 32 位数值。左移会保留它所操作数值的符号。

#### 有符号右移
有符号右移由两个大于号(>>)表示，会将数值的所有 32 位都向右移，同时保留符号(正或负)。有符号右移实际上是左移的逆运算。有符号右移会用符号位的值来填充空位，以得到完整的数值。

#### 无符号右移
无符号右移用 3 个大于号表示(>>>)，会将数值的所有 32 位都向右移。对于正数，无符号右移与有符号右移结果相同。无符号右移会给空位补 0，不管符号位是什么。


### 布尔操作符
布尔操作符一共有 3 个:逻辑非、逻辑与和逻辑或。

#### 逻辑非
逻辑非操作符由一个叹号(!)表示，可应用给 ECMAScript 中的任何值。这个操作符始终返回布尔值，无论应用到的是什么数据类型。逻辑非操作符首先将操作数转换为布尔值，然后再对其取反。逻辑非操作符会遵循如下规则：
* 如果操作数是对象，则返回 false。
* 如果操作数是空字符串，则返回 true。
* 如果操作数是非空字符串，则返回 false。
* 如果操作数是数值 0，则返回 true。
* 如果操作数是非 0 数值(包括 Infinity)，则返回 false。
* 如果操作数是 null，则返回 true。
* 如果操作数是 NaN，则返回 true。
* 如果操作数是 undefined，则返回 true。

逻辑非操作符也可以用于把任意值转换为布尔值。同时使用两个叹号(!!)，相当于调用了转型函数 Boolean()。

#### 逻辑与
逻辑与操作符由两个和号(&&)表示，应用到两个值。逻辑与操作符遵循如下真值表:

|第一个操作数|第二个操作数|结果|
||||
|true|true|true|
|true|false|false|
|false|true|false|
|false|false|false|

逻辑与操作符可用于任何类型的操作数，不限于布尔值。如果有操作数不是布尔值，则逻辑与操作符不一定会返回布尔值，而是遵循如下规则:
* 如果第一个操作数是对象，则返回第二个操作数。
* 如果第二个操作数是对象，则只有第一个操作数求值为 true 才会返回该对象。
* 如果两个操作数都是对象，则返回第二个操作数。
* 如果有一个操作数是 null，则返回 null。
* 如果有一个操作数是 NaN，则返回 NaN。
* 如果有一个操作数是 undefined，则返回 undefined。

逻辑与操作符是一种短路操作符，如果第：个操作数决定了结果，那么永远不会对第二个操作数求值。

#### 逻辑或
逻辑或操作符由两个管道符(||)表示，应用到两个值。逻辑或操作符遵循如下真值表:
|第一个操作数|第二个操作数|结果|
||||
|true|true|true|
|true|false|true|
|false|true|true|
|false|false|false|

逻辑或操作符可用于任何类型的操作数，不限于布尔值。如果有操作数不是布尔值，则逻辑或操作符不一定会返回布尔值，而遵循如下规则：
* 如果第一个操作数是对象，则返回第一个操作数。
* 如果第一个操作数求值为 false，则返回第二个操作数。
* 如果两个操作数都是对象，则返回第一个操作数。
* 如果两个操作数都是 null，则返回 null。
* 如果两个操作数都是 NaN，则返回 NaN。
* 如果两个操作数都是 undefined，则返回 undefined。

逻辑或操作符是一种短路操作符，如果第：个操作数决定了结果，那么永远不会对第二个操作数求值。


### 乘性操作符
ECMAScript 定义了 3 个乘性操作符:乘法、除法和取模。如果乘性操作符有不是数值的操作数，则该操作数会在后台被使用 Number()转型函数转换为数值。

#### 乘法操作符
乘法操作符由一个星号(*)表示，可以用于计算两个数值的乘积。乘法操作符在处理特殊值时也有一些特殊的行为：
* 如果操作数都是数值，则执行常规的乘法运算，即两个正值相乘是正值，两个负值相乘也是正值，正负符号不同的值相乘得到负值。如果 ECMAScript 不能表示乘积，则返回 Infinity 或 -Infinity。
* 如果有任一操作数是 NaN，则返回 NaN。
* 如果是 Infinity 乘以 0，则返回 NaN。
* 如果是 Infinity 乘以非 0 的有限数值，则根据第二个操作数的符号返回 Infinity 或-Infinity。
* 如果是 Infinity 乘以 Infinity，则返回 Infinity。
* 如果有不是数值的操作数，则先在后台用 Number()将其转换为数值，然后再应用上述规则。

#### 除法操作符
除法操作符由一个斜杠(/)表示，用于计算第一个操作数除以第二个操作数的商。除法操作符针对特殊值也有一些特殊的行为：
* 如果操作数都是数值，则执行常规的除法运算，即两个正值相除是正值，两个负值相除也是正值，符号不同的值相除得到负值。如果 ECMAScript 不能表示商，则返回 Infinity 或-Infinity。
* 如果有任一操作数是 NaN，则返回 NaN。
* 如果是 Infinity 除以 Infinity，则返回 NaN。
* 如果是 0 除以 0，则返回 NaN。
* 如果是 Infinity 除以任何数值，则根据第二个操作数的符号返回 Infinity 或 -Infinity。
* 如果是非 0 的有限值除以 0，则根据第一个操作数的符号返回 Infinity 或 -Infinity。
* 如果有不是数值的操作数，则先在后台用 Number()函数将其转换为数值，然后再应用上述规则。

#### 取模操作符
取模(余数)操作符由一个百分比符号(%)表示，取模操作符对特殊值也有一些特殊的行为：
* 如果操作数是数值，则执行常规除法运算，返回余数。
* 如果被除数是无限值，除数是有限值，则返回 NaN。
* 如果被除数是有限值，除数是 0，则返回 NaN。
* 如果被除数是 0，除数不是 0，则返回 0。
* 如果是 Infinity 除以 Infinity，则返回 NaN。
* 如果被除数是有限值，除数是无限值，则返回被除数。
* 如果有不是数值的操作数，则先在后台用 Number()函数将其转换为数值，然后再应用上述规则。


### 指数操作符
ECMAScript 7 新增了指数操作符，Math.pow()现在有了自己的操作符**，结果是一样的。指数操作符也有自己的指数赋值操作符**=，该操作符执行指数运算和结果的赋值操作。

### 加性操作符
加性操作符，即加法和减法操作符。加性操作符在后台会发生不同数据类型的转换。

#### 加法操作符
加法操作符(+)用于求两个数的和。

如果两个操作数都是数值，加法操作符执行加法运算并根据如下规则返回结果:
* 如果有任一操作数是 NaN，则返回 NaN;
* 如果是 Infinity 加 Infinity，则返回 Infinity;
* 如果是-Infinity 加-Infinity，则返回-Infinity;
* 如果是 Infinity 加-Infinity，则返回 NaN;
* 如果是+0 加+0，则返回+0;
* 如果是-0 加+0，则返回+0;
* 如果是-0 加-0，则返回-0。

如果有一个操作数是字符串，则要应用如下规则：
* 如果两个操作数都是字符串，则将第二个字符串拼接到第一个字符串后面;
* 如果只有一个操作数是字符串，则将另一个操作数转换为字符串，再将两个字符串拼接在一起。
* 如果有任一操作数是对象、数值或布尔值，则调用它们的 toString()方法以获取字符串，然后再应用前面的关于字符串的规则。对于 undefined 和 null，则调用 String()函数，分别获取"undefined"和"null"。

#### 减法操作符
减法操作符也有一组规则用于处理 ECMAScript 中不同类型之间的转换：
* 如果两个操作数都是数值，则执行数学减法运算并返回结果。
* 如果有任一操作数是 NaN，则返回 NaN。
* 如果是 Infinity 减 Infinity，则返回 NaN。
* 如果是-Infinity 减-Infinity，则返回 NaN。
* 如果是 Infinity 减-Infinity，则返回 Infinity。
* 如果是-Infinity 减 Infinity，则返回-Infinity。
* 如果是+0 减+0，则返回+0。
* 如果是+0 减-0，则返回-0。
* 如果是-0 减-0，则返回+0。
* 如果有任一操作数是字符串、布尔值、null 或 undefined，则先在后台使用 Number()将其转换为数值，然后再根据前面的规则执行数学运算。如果转换结果是 NaN，则减法计算的结果是 NaN。
* 如果有任一操作数是对象，则调用其 valueOf()方法取得表示它的数值。如果该值是 NaN，则减法计算的结果是 NaN。如果对象没有 valueOf()方法，则调用其 toString()方法，然后再将得到的字符串转换为数值。


### 关系操作符
关系操作符执行比较两个值的操作，包括小于(<)、大于(>)、小于等于(<=)和大于等于(>=)，这几个操作符都返回布尔值。

将它们应用到不同数据类型时也会发生类型转换和其他行为：
* 如果操作数都是数值，则执行数值比较。
* 如果操作数都是字符串，则逐个比较字符串中对应字符的编码。
* 如果有任一操作数是数值，则将另一个操作数转换为数值，执行数值比较。
* 如果有任一操作数是对象，则调用其 valueOf()方法，取得结果后再根据前面的规则执行比较。如果没有 valueOf()操作符，则调用 toString()方法，取得结果后再根据前面的规则执行比较。
* 如果有任一操作数是布尔值，则将其转换为数值再执行比较。
* 如果不能转换成任何有意义的数值，那就转换为 NaN。任何关系操作符在涉及比较 NaN 时都返回 false。

### 相等操作符
ECMAScript提供了两组操作符。第一组是等于和不等于，它们在比较之前执行类型转换。第二组是全等和不全等，它们
在比较之前不执行类型转换。

#### 等于和不等于
ECMAScript 中的等于操作符用两个等于号(==)表示，如果操作数相等，则会返回 true。不等于 操作符用叹号和等于号(!=)表示，如果两个操作数不相等，则会返回 true。这两个操作符都会先进 行类型转换(通常称为强制类型转换)再确定操作数是否相等。

在转换操作数的类型时，相等和不相等操作符遵循如下规则：
* 如果任一操作数是布尔值，则将其转换为数值再比较是否相等。false 转换为 0，true 转换为 1。
* 如果一个操作数是字符串，另一个操作数是数值，则尝试将字符串转换为数值，再比较是否相等。
* 如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf()方法取得其原始值，再根据前面的规则进行比较。

在进行比较时，这两个操作符会遵循如下规则：
* null 和 undefined 相等。
* null 和 undefined 不能转换为其他类型的值再进行比较。
* 如果有任一操作数是 NaN，则相等操作符返回 false，不相等操作符返回 true。NaN 不等于 NaN。
*  如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 true。否则，两者不相等。

下表总结了一些特殊情况及比较的结果：
|表达式|结果|
|null == undefined|true|
|"NaN" == NaN|false|
|5 == NaN|false|
|NaN == NaN|false|
|NaN != NaN|true|
|false == 0|true|
|true == 1|true|
|true == 2|false|
|undefined == 0|false|
|null == 0|false|
|"5" == 5|true|

#### 全等和不全等
全等操作符由 3 个等于号(===)表示，只有两个操作数在不转换的前提下相等才返回 true。  
不全等操作符用一个叹号和两个等于号(!==)表示，只有两个操作数在不转换的前提下不相等才返回 true。

虽然 `null == undefined` 是 true(因为这两个值类似)，但 `null === undefined` 是 false(因为它们不是相同的数据类型)。


### 条件操作符
```js
variable = boolean_expression ? true_value : false_value;
```
上面的代码执行了条件赋值操作，即根据条件表达式 `boolean_expression` 的值决定将哪个值赋给变量 `variable` 。如果 `boolean_expression` 是 `true` ， 则赋值 `true_value` ;如果 `boolean_expression` 是 `false`，则赋值 `false_value`。

### 赋值操作符
简单赋值用等于号(=)表示，将右手边的值赋给左手边的变量。

复合赋值使用乘性、加性或位操作符后跟等于号(=)表示，每个数学操作符以及其他一些操作符都有对应的复合赋值操作符：
* 乘后赋值(*=)
* 除后赋值(/=)
* 取模后赋值(%=)
* 加后赋值(+=)
* 减后赋值(-=)
* 左移后赋值(<<=)
* 右移后赋值(>>=)
* 无符号右移后赋值(>>>=)

### 逗号操作符
逗号操作符可以用来在一条语句中执行多个操作，在一条语句中同时声明多个变量是逗号操作符最常用的场景。在赋值时使用逗号操作符分隔值，最终会返回表达式中最后一个值。

## 语句

### if语句
```js
if (condition) statement1 else statement2
```
这里的条件(condition)可以是任何表达式，并且求值结果不一定是布尔值。ECMAScript 会自动调用 Boolean()函数将这个表达式的值转换为布尔值。如果条件求值为 true，则执行语句 statement1;如果条件求值为 false，则执行语句 statement2。

这里的语句可以是一行代码，也可以是一个代码块。但最佳实践是使用语句块，即使只有一行代码要执行也是如此。

可以连续使用多个 if 语句:
```js
if (condition1) statement1 else if (condition2) statement2 else statement3
```

### do-while语句
do-while 语句是一种后测试循环语句，即循环体中的代码执行后才会对退出条件进行求值。换句话说，循环体内的代码至少执行一次。do-while 的语法如下:
```js
do {
  statement
} while (expression);
```

### while语句
while 语句是一种先测试循环语句，即先检测退出条件，再执行循环体内的代码。因此，while 循环体内的代码有可能不会执行。下面是 while 循环的语法:
```js
while(expression) statement
```

### for语句
for 语句是先测试语句，增加了进入循环之前的初始化代码，以及循环执行后要执行的表达式，语法如下:
```js
for (initialization; expression; post-loop-expression) statement
```

### for-in语句
for-in 语句是一种严格的迭代语句，用于枚举对象中的非符号键属性，语法如下:
```js
for (property in expression) statement
```

每次执行循环，都会给变量 propName 赋予一个对象的属性作为值，直到所有属性都被枚举一遍。为了确保局部变量 propName 不被修改，推荐使用 const。

ECMAScript 中对象的属性是无序的，因此 for-in 语句不能保证返回对象属性的顺序。

如果 for-in 循环要迭代的变量是 null 或 undefined，则不执行循环体。

### for-of语句
for-of 语句是一种严格的迭代语句，用于遍历可迭代对象的元素，语法如下:
```js
for (property of expression) statement
```

for-of 循环会按照可迭代对象的next()方法产生值的顺序迭代元素，循环会一直持续到将所有元素都迭代完。为了确保 这个局部变量 property 不被修改，推荐使用 const。

如果尝试迭代的变量不支持迭代，则 for-of 语句会抛出错误。

### 标签语句
标签语句用于给语句加标签，语法如下:
```js
label: statement
```

标签语句的典型应用场景是嵌套循环：在循环体里通过 break 或 continue 语句引用。

### break和continue语句
break和continue语句为执行循环代码提供了更严格的控制手段。其中，break语句用于立即退出循环，强制执行循环后的下一条语句。而 continue 语句也用于立即退出循环，但会再次从循环顶部开始执行。

break 和 continue 都可以与标签语句一起使用，返回代码中特定的位置。

### with语句
with 语句的用途是将代码作用域设置为特定的对象，其语法是:
```js
with (expression) statement;
```
with 语句用于连接 `expression` 对象。这意味着在这个语句内部，每个变量首先会被认为是一个局部变量。如果没有找到该局部变量，则会搜索 `expression` 对象，看它是否有一个同名的属性。如果有，则该变量会被求值为 `expression` 对象的属性。

### switch语句
ECMAScript 中 switch 语句的语法如下所示:
```js
switch (expression) {
  case value1:
    statement
    break;
  case value2:
    statement
    break;
  case value3:
    statement
    break;
  case value4:
    statement
    break;
  default:
    statement
}
```
这里的每个 case(条件/分支)相当于:“如果表达式等于后面的值，则执行下面的语句。”break关键字会导致代码执行跳出 switch 语句。如果没有 break，则代码会继续匹配下一个条件。default关键字用于在任何条件都没有满足时指定默认执行的语句。

switch 语句可以用于所有数据类型，可以使用字符串甚至对象。条件的值不需要是常量，也可以是变量或表达式。

switch 语句在比较每个条件的值时会使用全等操作符，因此不会强制转换数据类型。


## 函数
ECMAScript 中的函数使用 function 关键字声明，后跟一组参数，然后是函数体。以下是函数的基本语法:
```js
function functionName(arg0, arg1,...,argN) {
  statements
}
```
可以通过函数名来调用函数，要传给函数的参数放在括号里(如果有多个参数，则用逗号隔开)。

ECMAScript 中的函数不需要指定是否返回值。任何函数在任何时候都可以使用 return 语句来返回函数的值，用法是后跟要返回的值。除了return语句之外没有任何特殊声明表明该函数有返回值。

只要碰到 return 语句，函数就会立即停止执行并退出。因此，return 语句后面的代码不会被执行。

return 语句也可以不带返回值。这时候，函数会立即停止执行并返回 undefined。
