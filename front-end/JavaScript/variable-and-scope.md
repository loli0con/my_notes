# 变量和作用域
JavaScript 变量是松散类型的，变量就是特定时间点一个特定值的名称，变量的值和数据类型在脚本生命期内可以改变。


## 变量
ECMAScript 变量可以包含两种不同类型的数据:
* 原始值：原始值(primitive value)就是最简单的数据。包括Undefined、Null、Boolean、Number、String 和 Symbol。保存原始值的变量是按值(by value)访问的，我们操作的就是存储在变量中的实际值。
* 引用值：引用值(reference value)则是由多个值构成的对象。引用值是保存在内存中的对象。在操作对象时，实际上操作的是对该对象的引用(reference)而非实际的对象本身。为此，保存引用值的变量是按引用(by reference)访问的。


### 动态属性
对于引用值而言，可以随时添加、修改和删除其属性和方法。

原始类型的初始化可以只使用原始字面量形式。如果使用的是 new 关键字，则 JavaScript 会创建一个 Object 类型的实例，但其行为类似原始值。


### 复制值
原始值和引用值在通过变量复制时也有所不同：
* 在通过变量把一个原始值赋值到另一个变量时，原始值会被复制到新变量的位置，两个变量可以独立使用，互不干扰。
* 在把引用值从一个变量赋给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置。区别在于，这里复制的值实际上是一个指针，它指向存储在堆内存中的对象。操作完成后，两个变量实际上指向同一个对象，因此一个对象上面的变化会在另一个对象上反映出来。


### 传递参数
ECMAScript 中所有函数的参数都是按值传递的。函数外的值会被复制到函数内部的参数 中，就像从一个变量复制到另一个变量一样。如果是原始值，那么就跟原始值变量的复制一样，如果是引用值，那么就跟引用值变量的复制一样。

在按值传递参数时，值会被复制到一个局部变量(即一个命名参数，或者用 ECMAScript 的话说， 就是 arguments 对象中的一个槽位)。在按引用传递参数时，值在内存中的位置会被保存在一个局部变量，这意味着对本地变量的修改会反映到函数外部。


### 确定类型
typeof 操作符最适合用来判断一个变量是否为原始类型。更确切地说，它是判断一个变量是否为字符串、数值、布尔值或 undefined 的最好方式。如果值是对象或 null，那么 typeof返回"object"。

typeof 虽然对原始值很有用，但它对引用值的用处不大。我们通常不关心一个值是不是对象，而是想知道它是什么类型的对象。为了解决这个问题，ECMAScript 提供了 instanceof 操作符，语法如下:
```js
result = variable instanceof constructor
```

如果变量是给定引用类型(由其原型链决定)的实例，则 instanceof 操作符返回 true。


## 作用域
变量或函数的上下文决定了它们可以访问哪些数据，以及它们的行为。每个上下文都有一个关联的*变量对象(variable object)*，而这个上下文中定义的所有变量和函数都存在于这个对象上。虽然无法通过代码访问*变量对象*，但后台处理数据会用到它。

全局上下文是最外层的上下文。在浏览器中，全局上下文就是我们常说的 window 对象，因此所有通过 var 定 义的全局变量和函数都会成为 window 对象的属性和方法。使用 let 和 const 的顶级声明不会定义在全局上下文中，但在作用域链解析上效果是一样的。上下文在其所有代码都执行完毕后会被销毁，包括定义在它上面的所有变量和函数。

每个函数调用都有自己的上下文。当代码执行流进入函数时，函数的上下文被推到一个上下文栈上。在函数执行完之后，上下文栈会弹出该函数上下文，将控制权返还给之前的执行上下文。ECMAScript 程序的执行流就是通过这个上下文栈进行控制的。

上下文中的代码在执行的时候，会创建*变量对象*的一个**作用域链(scope chain)**。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。代码正在执行的上下文的*变量对象*始终位于作用域链的最前端。如果上下文是函数，则其**活动对象(activation object)**用作*变量对象*。**活动对象**最初只有一个定义变量:arguments。(全局上下文中没有这个变量。)作用域链中的下一个*变量对象*来自包含上下文，再下一个对象来自再下一个包含上下文。以此类推直至全局上下文;全局上下文的*变量对象*始终是作用域链的最后一个*变量对象*。

代码执行时的标识符解析是通过沿作用域链逐级搜索标识符名称完成的。搜索过程始终从作用域链的最前端开始，然后逐级往后，直到找到标识符。(如果没有找到标识符，那么通常会报错。)

内部上下文可以通过作用域链访问外部上下文中的一切，但外部上下文无法访问内部上下文中的任何东西。上下文之间的连接是线性的、有序的。每个上下文都可以到上一级上下文中去搜索变量和函数，但任何上下文都不能到下一级上下文中去搜索。

函数参数被认为是当前上下文中的变量，因此也跟上下文中的其他变量遵循相同的访问规则。


### 作用域链增强
某些语句会导致在作用域链前端临时添加一个上下文，这个上下文在代码执行后会被删除。通常在两种情况下会出现这个现象，即代码执行到下面任意一种情况时:
* try/catch 语句的 catch 块
* with 语句

这两种情况下，都会在作用域链前端添加一个变量对象。对 with 语句来说，会向作用域链前端添加指定的对象;对 catch 语句而言，则会创建一个新的变量对象，这个变量对象会包含要抛出的错误对象的声明。

### 变量声明

#### 使用 var 的函数作用域声明
在使用 var 声明变量时，变量会被自动添加到最接近的上下文。在函数中，最接近的上下文就是函数的局部上下文。在 with 语句中，最接近的上下文也是函数上下文。如果变量未经声明就被初始化了，那么它就会自动被添加到全局上下文。

var 声明会被拿到函数或全局作用域的顶部，位于作用域中所有代码之前。这个现象叫作“提升”(hoisting)。提升让同一作用域中的代码不必考虑变量是否已经声明就可以直接使用。

#### 使用 let 的块级作用域声明
let 关键字的作用域是块级的。块级作用域由最近的一对包含花括号{}界定。换句话说，if 块、while 块、function 块，甚至连单独的块也是 let 声明变量的作用域。

重复的 var 声明会被忽略，而重复的 let 声明会抛出 SyntaxError。

let 的行为非常适合在循环中声明迭代变量。使用 var 声明的迭代变量会泄漏到循环外部，这种情况应该避免。

严格来讲，let 在 JavaScript 运行时中也会被提升，但由于“暂时性死区”(temporal dead zone)的缘故，实际上不能在声明之前使用 let 变量。

#### 使用 const 的常量声明
使用 const 声明的变量必须同时初始化为某个值。一经声明，在其生命周期的任何时候都不能再重新赋予新值。

const 声明只应用到顶级原语或者对象。换句话说，赋值为对象的 const 变量不能再被重新赋值为其他引用值，但对象的键则不受限制。

如果想让整个对象都不能修改，可以使用`Object.freeze()`，这样再给属性赋值时虽然不会报错，但会静默失败。

由于 const 声明暗示变量的值是单一类型且不可修改，JavaScript 运行时编译器可以将其所有实例都替换成实际的值，而不会通过查询表进行变量查找。

#### 标识符查找
当在特定上下文中为读取或写入而引用一个标识符时，必须通过搜索确定这个标识符表示什么。搜索开始于作用域链前端，以给定的名称搜索对应的标识符。如果在局部上下文中找到该标识符，则搜索停止，变量确定;如果没有找到变量名，则继续沿作用域链搜索。(注意，作用域链中的对象也有一个原型链，因此搜索可能涉及每个对象的原型链。)这个过程一直持续到搜索至全局上下文的变量对象。如果仍然没有找到标识符，则说明其未声明。

对这个搜索过程而言，引用局部变量会让搜索自动停止，而不继续搜索下一级变量对象。也就是说，如果局部上下文中有一个同名的标识符，那就不能在该上下文中引用父上下文中的同名标识符。


## 垃圾回收
JavaScript 是使用垃圾回收的编程语言，开发者不需要操心内存分配和回收。

JavaScript 的垃圾回收程序可以总结如下：
* 离开作用域的值会被自动标记为可回收，然后在垃圾回收期间被删除。
* 主流的垃圾回收算法是标记清理，即先给当前不使用的值加上标记，再回来回收它们的内存。
* 引用计数是另一种垃圾回收策略，需要记录值被引用了多少次。引用计数在代码中存在循环引用时会出现问题。


解除变量的引用不仅可以消除循环引用，而且对垃圾回收也有帮助。为促进内存回收，全局对
象、全局对象的属性和循环引用都应该在不需要时解除引用。