# 用例模型

## 组成
用例模型的组成：
* 参与者
* 用例(取名:短小精悍的动名词，如“取钱”、“修改密码)
* 用例描述 (作为领域模型的输入、设计的输入、开发的输入...)
* 系统边界
* 系统顺序图
* 操作契约

### 参与者
位于系统之外并和系统进行交互的一类事物（人、物、其他软件子系统等)。

参与者主要有三类：
* 主要参与者Primary – 这类用户希望通过新系统实现自己的商业目标
* 协助性参与者Supporting – 提供支持，比如关于第三方软件接口
* 幕后参与者 Offstage – 对系统功能感兴趣，但不是很强烈

### 用例
系统为响应参与者引发的一个事件而执行的**一系列的处理/动作**，这些处 理应该为参与者产生一种**有价值的结果**

用例描述的三种详细程度：
* 简短格式 brief
  * 一段扼要的总结，通常是主事件流
  * 在早期阶段的分析中很有用，标识系统范围、可能的风险等
* 随意的 casual
  * 非正式的一段、一段描述，每一段也许是一个场景scenarios
* 正式的 fully
  * 根据指定的格式，一步步地描述每个动作，包括前置条件、后置条件、成功保证、约束等
  * 重要的用例，都需要有详细的描述。有助于建立词汇表、抽取概念类、评估风险等
  * 在后续的迭代过程中，可能需要来回修改这些描述
  * 至少有10%的关键用例，必须以这种方式来描述

#### 标识“合适的”用例
如何判断一个用例是否是一个合适的用例?
1. 用例是否描述了应该做什么，而不是如何做?
2. 用例的描述是否采取了参与者的视点?
   * 在确定用例的关键特征时，应该依据参与者的视点。也就是说，应该从参与者如何使用系统的角度出发定义用例，而不是从系统自身的角度
3. 用例是否对参与者有价值?
   * 用例不是动作步骤的任意集合，它必须为参与者提供可辨识的价值
4. 用例描述的时间流是否是一个完整场景?
   * 每一个用例必须描述出，在一个给定场景下参与者将如何使用系统的完整事件流。这有助于避免产生单步用例、部分用例或者功能分解用例
5. 是否所有的参与者、用例都有相应的关联用例或关联参与者

#### 高质量的用例
1. 用例描述事物本质（参与者的目标），与界面（包括其他实现细节）无关
2. 用例描写要简洁
3. 把用例视作“黑盒”，通过职责来描述用例，不描述系统内部是如何工作的、内部有哪些构件等，即描述系统应该完成那些功能，但不去描述系统是如何完成这些功能的
4. 从参与者及其目标的角度进行描述

### 操作契约
操作契约是“用例描述”的补充，用例中重要的动作的开始与结束是需要一些约束。
#### 契约式设计
契约式设计是可信软件设计的基础思想

一份契约承载了相互间(client/server) 的义务与利益：
* 客户端只有在能够满足服务端的“前置条件”的情况下，才能调用服务端的服务
* 服务端在结束服务后，必须保证满足其后置条件

每个功能定义了一个前置条件、一个后置条件。

##### 断言assertion
在类的代码中，加入一些断言，则定义了契约。断言仅仅是一些逻辑表达式，不影响程序的执行，它可以被评估或者忽略。

##### 规格说明
假定有一个人拿着一个程序到你面前问：“这个程序正确吗？”。这个问题有意义的前提是：程序应该完成什么功能有一个精确的描述。

这样的一个描述，就是规格说明 specification，规格说明必须精确，否则不可
能推理出是否正确。

规格说明的形式化表示：`{P} A {Q}`，每次要执行`A`，满足`P`(pre-condition)才能开始，结束的时候，`Q`(post-condition)必须得到满足。 

##### 前置条件/后置条件
一个正确的系统永远不会在被调用操作的前置条件不满足的情况下开始执行，一个正确的系统永远在调用结束时处于满足被调用操作的后置条件的状态。

##### 类不变量
前置条件与后置条件描述了单个操作的特性。类不变量是类定义的一个断言，类不变量是类实例的全局特性，在所有的操作中应得到遵守。