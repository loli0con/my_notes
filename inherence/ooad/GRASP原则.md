# GRASP原则
通用的职责分配软件原则：General Responsibility Assignment Software Pattern。

GRASP原则可以帮助设计人员理解面向对象设计的本质，并以一种有条理的、理性的、可解释的方式应用这些设计原则。



## Creator - 创建者
creator原则的本质是创建类对象职责应该委托给某个对象，也就是谁应该负责产生某个类的实例。

### 问题
谁应该负责创建某个类的实例对象？

### 解决
如果符合下面的一个或者多个条件，则可以将创建A的实例的职责分配给B：
* B包含A
* B聚合A
* B记录A的实例
* B频发使用A
* B拥有初始化A的数据并在创建A的实例时将数据传递给A

### 优点
创建者与被创建者之间存在关联，这意味着被创建的类在任何情况下都对创建者可见，这就可以带来提高内聚、降低耦合。



## Information Expert - 信息专家
信息专家原则的本质指的是我们应该将职责委托给哪一个对象，这个职责可以是一个方法，也可以是一个算法或者其他内容。它是面向对象设计过程中最基本的原则。

### 问题
分配职责给对象的通用原则是什么？

### 解决
如果某个对象拥有完成某个职责所需要的所有信息，那么这个职责就分配给这个对象实现。

#### 步骤
1. Clearly state the responsibility，明确地陈述职责
2. Look in Design Model for relevant classes，在设计模型中寻找相关的类
3. Else look in Domain Model and create design classes，或者在领域模型中寻在并创建一个设计类

### 优点
1. 充分利用对象自身的信息，降低耦合，实现封装性
2. 将系统行为分布到不同的类，提高内聚



## Low Coupling - 低耦合

### 耦合的定义
耦合的定义: 一个元素与其它元素的联接、感知以及依赖程度的度量。

### 耦合的表现
两个类具有以下特性中的其中一个，我们就说这两个类是耦合的：
* A具有一个类型为B的属性
* A调用B的方法
* A的方法包含对B的引用(参数或者返回值的方式)
* A是B的直接或者间接的子类
* A是接口B的一种实现

### 耦合与内聚
耦合和内聚的比较：
* Cohesion，内聚: 模块内的操作之间联系紧密的程度
* Coupling，耦合: 两个子模块之间联系的强度

### 耦合的弊端
高耦合带来的问题：
* “牵一发动全身”：A依赖B，A与B之间有耦合，一旦B变化了，A就会受影响
* 系统难以维护和理解 
* 系统的重用性差，在重用一个高耦合类的时候，不得不重用它所依赖的所有类

### 问题
怎样支持低耦合、降低变化的影响和提高复用率？

### 解决
在设计的时候始终把低耦合放在心中：
1. 评判多个设计中耦合性最低的方案
2. 信息专家方案本身是低耦合的

低耦合是所有设计决策时自然而然要考虑的原则，低耦合是一种评估原则，是设计师用来对设计方案进行评价的一种指标。

### 优点
低耦合支持类的设计相对独立，减少了变化带来的相互影响

### 注意
不能单独考虑低耦合。极端情况“类之间没有耦合”，这不符合“对象与对象之间通过消息相互协作，共同完成任务”的面向对象思想。并且这样的设计意味着一个模块将承担相当多的职责，或者说整个系统就只有一个类。

继承关系中，子类与父类的耦合非常紧密，所以能用组合的地方不要用继承。

#### 组合和继承
组合和继承是两种基本的代码重用方式，能用组合的地方不要用继承。

##### 继承
继承的特点：
* 子类获得父系“全部功能”，“稍微”调整一下，比如覆盖实现几个方法。
  * 既快又容易
  * 代码实现时明确展示，由编程语言加以支持。

继承的副作用：
* 继承打破了封装性，导致父类与子类之间高度耦合
* 继承的代码是静态/编译时绑定的
  * 必须修改代码重新打包
* 客户需要购买整个软件包
* 父类定义了许多硬性的规定
  * 不得不了解父类的代码以求真正理解

##### 组合
组合的特点：
* 没有打破封装性
* 对象组合是一种动态/运行时绑定
  * 在运行时切换对象引用，就可以改变行为 
* 整体与部分之间只有接口边界关联，耦合较低
  * 对私有数据不存在“窥视与拨弄”
  * 不存在大量无用代码一类的负担
* 各部分的职责明确
  * 每个对象清晰地集中在少量的任务上，容易理解、容易维护
  * 只要阅读接口，就可以了解系统
  * 容易独立测试 
  * 每个类依然“苗条”，避免的“巨无霸”这种反模式的现象，即一个类似乎完成了几乎全部的功能
  * 重用的概率大增



## Controller - 控制器

### 定义
控制器模式的实质是将一些系统事件的接受和处理委托给一个的对象controller，这个对象可以是一个类，系统或者子系统，它不与UI进行交互，它只负责系统信息的接收和处理。

一般情况下，控制器是一个系统，这个系统中包括多个处理器，分别对应处理不同的事务。通常情况下，一个控制器应当把要完成的功能委托给其他对象，而它只负责任务的协调控制和分配。

### 问题
哪个对象是第一个位于UI层之外，接收并且协调(控制)系统操作？

### 解决
把职责分配给一个能代表整个系统的类，有如下两种选择：
1. 外观控制器：相当于领域层对外部世界的“脸”
2. 用例/会话控制器：处理系统某个明确的功能集，比如相关的一组系统事件

#### 外观控制器
外观控制器为子系统中的一组接口提供一个一致的界面，适用于：
* 相对较小的系统
* 有限数量的系统操作 
* 在消息处理系统中，不能转发消息到可选的控制器时

#### 会话控制器
会话控制器是一种纯虚构出来的概念，即领域模型中没有的概念，适用于：
* 当采用外观控制器会导致高耦合、低内聚时
* 很多系统事件跨越多个不同的处理过程
* 概念上容易理解和构建（一个会话控制器负责一类系统事件）

会话控制器的命名习惯：
* \<UseCaseName> Handler
* \<UseCaseName> Coordinator
* \<UseCaseName> Session

### 控制器和UI层
1. UI层不应负责处理系统操作
2. 系统操作一定在领域层进行处理
3. 控制器负责委托(转发)消息

### 优点
1. 容易适应UI层的变化
2. 领域层代码易于重用(因为UI层一般与应用关系密切)
3. 有助于保证应用所需要的操作顺序
4. 可以对系统的状态进行推理(UI层不保存系统状态)

### 注意
臃肿控制器的问题：
1. 当一个外观控制器处理了大部分系统事件时
2. 当一个控制器做了太多的事情，而不是委托给其他的对象去处理
3. 当控制器掌握了太多的系统信息

臃肿控制器的解决方法：
1. 增加更多的控制器
2. 采用会话控制器替换外观控制器
3. 控制器委托任务给别的对象，而不是自己做



## High Cohesion - 高内聚
内聚是评价一个对象的职责被关联的尺度或者强弱，也可以说是功能性内聚的职责。也就是功能性紧密的相关职责应该放在同一个类中，并共同完成有限的功能。这样做更加有利于对类的理解和重用，也可以降低类的维护成本。

### 低内聚

#### 低内聚的表现
类低内聚的具有症状：
* 做了许多相互无关的工作
* 做了太多工作

#### 低内聚的原因
类低内聚的的原因：
* 大粒度的抽象
* 做了太多本应该委托给其他类去做的工作

#### 低内聚的缺点
类低内聚的问题：
* 难以理解
* 难以重用
* 难以维护
* 没有稳定的时刻，总是在修改 (通常都会高耦合)

### 问题
如何保证对象专注、可理解、可管理，同时又支持低耦合？

### 解决
分配职责的时候要保证高内聚：
1. 用作评价工具，选择更合适的设计

为了达到高内聚，我们需要对类的职责进行分解，使分解出来的类具有独立的职责，满足单一职责原则。

高内聚的类：
* 有较少数量的操作，操作的性质基本一致，不会做太多的事情
* 如果同类别的工作太多，则会定义新的类分担任务，相互间合作



## Polymorphism - 多态

### 问题
如何处理依据类型不同而有不同行为的一类需求?

### 解决
使用多态操作为依据类型变化的行为进行职责分配

### 注意
* 不要去测试对象的类型或者条件逻辑，并以此选择相应的行为
* 不要使用条件逻辑，而是为不同的类定义相同名字的方法
* 不同的类实现了相同的接口、或者有一个共同的父类



## Pure Fabrication - 纯虚构
纯虚构的作用是用来解决高内聚和低耦合之间的矛盾的。高内聚低耦合是我们系统设计的终极目标，高内聚意味着我们要将类拆分成多个功能集中的类，但是拆分的多个类之间需要进行协作才能正常工作，这样又增加了类之间的耦合性。

纯虚构原则是用来解决上述问题的方案。它要求将一部分类的职责转移到纯虚构类中，在理想的情况下，分配给这种虚构类的职责是为了达到高内聚低耦合的效果。

### 问题
依据一些原则(比如，信息专家)获得的解决方案不合适的情况下，既不想违反低耦合、高内聚，也不想违反其他的原则，如何把职责分配给对象?

### 解决
把高度内聚的职责分配给虚构出来的一个类，这个类在领域模型里没有对应的概念。这种方式在有的场合能起到支持低耦合、高内聚、重用的效果。

### 案例
在实际的操作过程中，纯虚构类的实现又很多种方式，例如将数据库中操作的方法从数据库实体中分离出来，形成专门的数据访问类；通过对类的分解来实现类的重用，新增加的数据访问类对应于数据的持久化存储，这是软件开发过程中为了方便虚构出来的一个概念。

### 注意
应用纯虚构原则：
* 纯虚构应该应用于可重用的模块上，要保证系统的低耦合高内聚
* 多数情况下是按功能类定义新的类，是一种“功能为中心的”对象。即把同一类功能放在一个新的类中。
* 如果功能的相关性比较高的话，满足高内聚



## Indirection - 间接

### 问题
把职责分配到哪里可以避免两个或者多个对象之间的直接耦合?如何解耦对象以保持较高的可重用性?

### 解决
把职责分配给一个中介对象，隔离对象与其他构件或者服务，使它们不产生直接耦合



## Protected Variations - 隔离变化
找到系统中不稳定的变化点，使用统一的接口封装起来，如果未来发生变化的时候，可以通过扩展接口来扩展新的功能，而不需要改变旧的代码。

### 问题
如何设计对象、系统和子系统，使得这些成分里面的变化因素、不稳定因素不会对系统的其余部分造成意想不到的影响?

### 解决
标识出能够预计的变化点或者不稳定点，职责分配的时候创建一个稳定的接口，把它们与系统的其余部分隔离开来

### 注意
隔离变化是一种高度抽象的原则，它鼓励使用一个稳定的接口来封装可以预知的变更点，指导了设计和编程过程的大多数机制、模式。

数据封装、多态、数据-驱动设计、服务查询、配置文件、接口等技巧都使用了隔离变化原则。